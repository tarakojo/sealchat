/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./cubism/Framework/src/cubismdefaultparameterid.ts":
/*!**********************************************************!*\
  !*** ./cubism/Framework/src/cubismdefaultparameterid.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismDefaultParameterId = void 0;\n/**\n * @brief パラメータIDのデフォルト値を保持する定数<br>\n *         デフォルト値の仕様は以下のマニュアルに基づく<br>\n *         https://docs.live2d.com/cubism-editor-manual/standard-parametor-list/\n */\nexports.CubismDefaultParameterId = Object.freeze({\n    // パーツID\n    HitAreaPrefix: 'HitArea',\n    HitAreaHead: 'Head',\n    HitAreaBody: 'Body',\n    PartsIdCore: 'Parts01Core',\n    PartsArmPrefix: 'Parts01Arm_',\n    PartsArmLPrefix: 'Parts01ArmL_',\n    PartsArmRPrefix: 'Parts01ArmR_',\n    // パラメータID\n    ParamAngleX: 'ParamAngleX',\n    ParamAngleY: 'ParamAngleY',\n    ParamAngleZ: 'ParamAngleZ',\n    ParamEyeLOpen: 'ParamEyeLOpen',\n    ParamEyeLSmile: 'ParamEyeLSmile',\n    ParamEyeROpen: 'ParamEyeROpen',\n    ParamEyeRSmile: 'ParamEyeRSmile',\n    ParamEyeBallX: 'ParamEyeBallX',\n    ParamEyeBallY: 'ParamEyeBallY',\n    ParamEyeBallForm: 'ParamEyeBallForm',\n    ParamBrowLY: 'ParamBrowLY',\n    ParamBrowRY: 'ParamBrowRY',\n    ParamBrowLX: 'ParamBrowLX',\n    ParamBrowRX: 'ParamBrowRX',\n    ParamBrowLAngle: 'ParamBrowLAngle',\n    ParamBrowRAngle: 'ParamBrowRAngle',\n    ParamBrowLForm: 'ParamBrowLForm',\n    ParamBrowRForm: 'ParamBrowRForm',\n    ParamMouthForm: 'ParamMouthForm',\n    ParamMouthOpenY: 'ParamMouthOpenY',\n    ParamCheek: 'ParamCheek',\n    ParamBodyAngleX: 'ParamBodyAngleX',\n    ParamBodyAngleY: 'ParamBodyAngleY',\n    ParamBodyAngleZ: 'ParamBodyAngleZ',\n    ParamBreath: 'ParamBreath',\n    ParamArmLA: 'ParamArmLA',\n    ParamArmRA: 'ParamArmRA',\n    ParamArmLB: 'ParamArmLB',\n    ParamArmRB: 'ParamArmRB',\n    ParamHandL: 'ParamHandL',\n    ParamHandR: 'ParamHandR',\n    ParamHairFront: 'ParamHairFront',\n    ParamHairSide: 'ParamHairSide',\n    ParamHairBack: 'ParamHairBack',\n    ParamHairFluffy: 'ParamHairFluffy',\n    ParamShoulderY: 'ParamShoulderY',\n    ParamBustX: 'ParamBustX',\n    ParamBustY: 'ParamBustY',\n    ParamBaseX: 'ParamBaseX',\n    ParamBaseY: 'ParamBaseY',\n    ParamNONE: 'NONE:',\n});\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismdefaultparameterid */ \"./cubism/Framework/src/cubismdefaultparameterid.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.HitAreaBody = $.CubismDefaultParameterId.HitAreaBody;\n    Live2DCubismFramework.HitAreaHead = $.CubismDefaultParameterId.HitAreaHead;\n    Live2DCubismFramework.HitAreaPrefix = $.CubismDefaultParameterId.HitAreaPrefix;\n    Live2DCubismFramework.ParamAngleX = $.CubismDefaultParameterId.ParamAngleX;\n    Live2DCubismFramework.ParamAngleY = $.CubismDefaultParameterId.ParamAngleY;\n    Live2DCubismFramework.ParamAngleZ = $.CubismDefaultParameterId.ParamAngleZ;\n    Live2DCubismFramework.ParamArmLA = $.CubismDefaultParameterId.ParamArmLA;\n    Live2DCubismFramework.ParamArmLB = $.CubismDefaultParameterId.ParamArmLB;\n    Live2DCubismFramework.ParamArmRA = $.CubismDefaultParameterId.ParamArmRA;\n    Live2DCubismFramework.ParamArmRB = $.CubismDefaultParameterId.ParamArmRB;\n    Live2DCubismFramework.ParamBaseX = $.CubismDefaultParameterId.ParamBaseX;\n    Live2DCubismFramework.ParamBaseY = $.CubismDefaultParameterId.ParamBaseY;\n    Live2DCubismFramework.ParamBodyAngleX = $.CubismDefaultParameterId.ParamBodyAngleX;\n    Live2DCubismFramework.ParamBodyAngleY = $.CubismDefaultParameterId.ParamBodyAngleY;\n    Live2DCubismFramework.ParamBodyAngleZ = $.CubismDefaultParameterId.ParamBodyAngleZ;\n    Live2DCubismFramework.ParamBreath = $.CubismDefaultParameterId.ParamBreath;\n    Live2DCubismFramework.ParamBrowLAngle = $.CubismDefaultParameterId.ParamBrowLAngle;\n    Live2DCubismFramework.ParamBrowLForm = $.CubismDefaultParameterId.ParamBrowLForm;\n    Live2DCubismFramework.ParamBrowLX = $.CubismDefaultParameterId.ParamBrowLX;\n    Live2DCubismFramework.ParamBrowLY = $.CubismDefaultParameterId.ParamBrowLY;\n    Live2DCubismFramework.ParamBrowRAngle = $.CubismDefaultParameterId.ParamBrowRAngle;\n    Live2DCubismFramework.ParamBrowRForm = $.CubismDefaultParameterId.ParamBrowRForm;\n    Live2DCubismFramework.ParamBrowRX = $.CubismDefaultParameterId.ParamBrowRX;\n    Live2DCubismFramework.ParamBrowRY = $.CubismDefaultParameterId.ParamBrowRY;\n    Live2DCubismFramework.ParamBustX = $.CubismDefaultParameterId.ParamBustX;\n    Live2DCubismFramework.ParamBustY = $.CubismDefaultParameterId.ParamBustY;\n    Live2DCubismFramework.ParamCheek = $.CubismDefaultParameterId.ParamCheek;\n    Live2DCubismFramework.ParamEyeBallForm = $.CubismDefaultParameterId.ParamEyeBallForm;\n    Live2DCubismFramework.ParamEyeBallX = $.CubismDefaultParameterId.ParamEyeBallX;\n    Live2DCubismFramework.ParamEyeBallY = $.CubismDefaultParameterId.ParamEyeBallY;\n    Live2DCubismFramework.ParamEyeLOpen = $.CubismDefaultParameterId.ParamEyeLOpen;\n    Live2DCubismFramework.ParamEyeLSmile = $.CubismDefaultParameterId.ParamEyeLSmile;\n    Live2DCubismFramework.ParamEyeROpen = $.CubismDefaultParameterId.ParamEyeROpen;\n    Live2DCubismFramework.ParamEyeRSmile = $.CubismDefaultParameterId.ParamEyeRSmile;\n    Live2DCubismFramework.ParamHairBack = $.CubismDefaultParameterId.ParamHairBack;\n    Live2DCubismFramework.ParamHairFluffy = $.CubismDefaultParameterId.ParamHairFluffy;\n    Live2DCubismFramework.ParamHairFront = $.CubismDefaultParameterId.ParamHairFront;\n    Live2DCubismFramework.ParamHairSide = $.CubismDefaultParameterId.ParamHairSide;\n    Live2DCubismFramework.ParamHandL = $.CubismDefaultParameterId.ParamHandL;\n    Live2DCubismFramework.ParamHandR = $.CubismDefaultParameterId.ParamHandR;\n    Live2DCubismFramework.ParamMouthForm = $.CubismDefaultParameterId.ParamMouthForm;\n    Live2DCubismFramework.ParamMouthOpenY = $.CubismDefaultParameterId.ParamMouthOpenY;\n    Live2DCubismFramework.ParamNONE = $.CubismDefaultParameterId.ParamNONE;\n    Live2DCubismFramework.ParamShoulderY = $.CubismDefaultParameterId.ParamShoulderY;\n    Live2DCubismFramework.PartsArmLPrefix = $.CubismDefaultParameterId.PartsArmLPrefix;\n    Live2DCubismFramework.PartsArmPrefix = $.CubismDefaultParameterId.PartsArmPrefix;\n    Live2DCubismFramework.PartsArmRPrefix = $.CubismDefaultParameterId.PartsArmRPrefix;\n    Live2DCubismFramework.PartsIdCore = $.CubismDefaultParameterId.PartsIdCore;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/cubismdefaultparameterid.ts?");

/***/ }),

/***/ "./cubism/Framework/src/cubismframeworkconfig.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/cubismframeworkconfig.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CSM_LOG_LEVEL = exports.CSM_LOG_LEVEL_OFF = exports.CSM_LOG_LEVEL_ERROR = exports.CSM_LOG_LEVEL_WARNING = exports.CSM_LOG_LEVEL_INFO = exports.CSM_LOG_LEVEL_DEBUG = exports.CSM_LOG_LEVEL_VERBOSE = void 0;\n//========================================================\n//  ログ出力関数の設定\n//========================================================\n//---------- ログ出力レベル 選択項目 定義 ----------\n// 詳細ログ出力設定\nexports.CSM_LOG_LEVEL_VERBOSE = 0;\n// デバッグログ出力設定\nexports.CSM_LOG_LEVEL_DEBUG = 1;\n// Infoログ出力設定\nexports.CSM_LOG_LEVEL_INFO = 2;\n// 警告ログ出力設定\nexports.CSM_LOG_LEVEL_WARNING = 3;\n// エラーログ出力設定\nexports.CSM_LOG_LEVEL_ERROR = 4;\n// ログ出力オフ設定\nexports.CSM_LOG_LEVEL_OFF = 5;\n/**\n * ログ出力レベル設定。\n *\n * 強制的にログ出力レベルを変える時に定義を有効にする。\n * CSM_LOG_LEVEL_VERBOSE ～ CSM_LOG_LEVEL_OFF を選択する。\n */\nexports.CSM_LOG_LEVEL = exports.CSM_LOG_LEVEL_VERBOSE;\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/cubismframeworkconfig.ts?");

/***/ }),

/***/ "./cubism/Framework/src/cubismmodelsettingjson.ts":
/*!********************************************************!*\
  !*** ./cubism/Framework/src/cubismmodelsettingjson.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismModelSettingJson = void 0;\nconst icubismmodelsetting_1 = __webpack_require__(/*! ./icubismmodelsetting */ \"./cubism/Framework/src/icubismmodelsetting.ts\");\nconst live2dcubismframework_1 = __webpack_require__(/*! ./live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmvector_1 = __webpack_require__(/*! ./type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ./utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\n/**\n * Model3Jsonのキー文字列\n */\n// JSON Keys\nconst Version = 'Version';\nconst FileReferences = 'FileReferences';\nconst Groups = 'Groups';\nconst Layout = 'Layout';\nconst HitAreas = 'HitAreas';\nconst Moc = 'Moc';\nconst Textures = 'Textures';\nconst Physics = 'Physics';\nconst Pose = 'Pose';\nconst Expressions = 'Expressions';\nconst Motions = 'Motions';\nconst UserData = 'UserData';\nconst Name = 'Name';\nconst FilePath = 'File';\nconst Id = 'Id';\nconst Ids = 'Ids';\nconst Target = 'Target';\n// Motions\nconst Idle = 'Idle';\nconst TapBody = 'TapBody';\nconst PinchIn = 'PinchIn';\nconst PinchOut = 'PinchOut';\nconst Shake = 'Shake';\nconst FlickHead = 'FlickHead';\nconst Parameter = 'Parameter';\nconst SoundPath = 'Sound';\nconst FadeInTime = 'FadeInTime';\nconst FadeOutTime = 'FadeOutTime';\n// Layout\nconst CenterX = 'CenterX';\nconst CenterY = 'CenterY';\nconst X = 'X';\nconst Y = 'Y';\nconst Width = 'Width';\nconst Height = 'Height';\nconst LipSync = 'LipSync';\nconst EyeBlink = 'EyeBlink';\nconst InitParameter = 'init_param';\nconst InitPartsVisible = 'init_parts_visible';\nconst Val = 'val';\nvar FrequestNode;\n(function (FrequestNode) {\n    FrequestNode[FrequestNode[\"FrequestNode_Groups\"] = 0] = \"FrequestNode_Groups\";\n    FrequestNode[FrequestNode[\"FrequestNode_Moc\"] = 1] = \"FrequestNode_Moc\";\n    FrequestNode[FrequestNode[\"FrequestNode_Motions\"] = 2] = \"FrequestNode_Motions\";\n    FrequestNode[FrequestNode[\"FrequestNode_Expressions\"] = 3] = \"FrequestNode_Expressions\";\n    FrequestNode[FrequestNode[\"FrequestNode_Textures\"] = 4] = \"FrequestNode_Textures\";\n    FrequestNode[FrequestNode[\"FrequestNode_Physics\"] = 5] = \"FrequestNode_Physics\";\n    FrequestNode[FrequestNode[\"FrequestNode_Pose\"] = 6] = \"FrequestNode_Pose\";\n    FrequestNode[FrequestNode[\"FrequestNode_HitAreas\"] = 7] = \"FrequestNode_HitAreas\";\n})(FrequestNode || (FrequestNode = {}));\n/**\n * Model3Jsonパーサー\n *\n * model3.jsonファイルをパースして値を取得する\n */\nclass CubismModelSettingJson extends icubismmodelsetting_1.ICubismModelSetting {\n    /**\n     * 引数付きコンストラクタ\n     *\n     * @param buffer    Model3Jsonをバイト配列として読み込んだデータバッファ\n     * @param size      Model3Jsonのデータサイズ\n     */\n    constructor(buffer, size) {\n        super();\n        this._json = cubismjson_1.CubismJson.create(buffer, size);\n        if (this._json) {\n            this._jsonValue = new csmvector_1.csmVector();\n            // 順番はenum FrequestNodeと一致させる\n            this._jsonValue.pushBack(this._json.getRoot().getValueByString(Groups));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Moc));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Motions));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Expressions));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Textures));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Physics));\n            this._jsonValue.pushBack(this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Pose));\n            this._jsonValue.pushBack(this._json.getRoot().getValueByString(HitAreas));\n        }\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        cubismjson_1.CubismJson.delete(this._json);\n        this._jsonValue = null;\n    }\n    /**\n     * CubismJsonオブジェクトを取得する\n     *\n     * @return CubismJson\n     */\n    GetJson() {\n        return this._json;\n    }\n    /**\n     * Mocファイルの名前を取得する\n     * @return Mocファイルの名前\n     */\n    getModelFileName() {\n        if (!this.isExistModelFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Moc).getRawString();\n    }\n    /**\n     * モデルが使用するテクスチャの数を取得する\n     * テクスチャの数\n     */\n    getTextureCount() {\n        if (!this.isExistTextureFiles()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getSize();\n    }\n    /**\n     * テクスチャが配置されたディレクトリの名前を取得する\n     * @return テクスチャが配置されたディレクトリの名前\n     */\n    getTextureDirectory() {\n        const texturePath = this._jsonValue\n            .at(FrequestNode.FrequestNode_Textures)\n            .getValueByIndex(0)\n            .getRawString();\n        const pathArray = texturePath.split('/');\n        // 最後の要素はテクスチャ名なので不要\n        const arrayLength = pathArray.length - 1;\n        let textureDirectoryStr = '';\n        // 分割したパスを結合\n        for (let i = 0; i < arrayLength; i++) {\n            textureDirectoryStr += pathArray[i];\n            if (i < arrayLength - 1) {\n                textureDirectoryStr += '/';\n            }\n        }\n        return textureDirectoryStr;\n    }\n    /**\n     * モデルが使用するテクスチャの名前を取得する\n     * @param index 配列のインデックス値\n     * @return テクスチャの名前\n     */\n    getTextureFileName(index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Textures)\n            .getValueByIndex(index)\n            .getRawString();\n    }\n    /**\n     * モデルに設定された当たり判定の数を取得する\n     * @return モデルに設定された当たり判定の数\n     */\n    getHitAreasCount() {\n        if (!this.isExistHitAreas()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getSize();\n    }\n    /**\n     * 当たり判定に設定されたIDを取得する\n     *\n     * @param index 配列のindex\n     * @return 当たり判定に設定されたID\n     */\n    getHitAreaId(index) {\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(this._jsonValue\n            .at(FrequestNode.FrequestNode_HitAreas)\n            .getValueByIndex(index)\n            .getValueByString(Id)\n            .getRawString());\n    }\n    /**\n     * 当たり判定に設定された名前を取得する\n     * @param index 配列のインデックス値\n     * @return 当たり判定に設定された名前\n     */\n    getHitAreaName(index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_HitAreas)\n            .getValueByIndex(index)\n            .getValueByString(Name)\n            .getRawString();\n    }\n    /**\n     * 物理演算設定ファイルの名前を取得する\n     * @return 物理演算設定ファイルの名前\n     */\n    getPhysicsFileName() {\n        if (!this.isExistPhysicsFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Physics).getRawString();\n    }\n    /**\n     * パーツ切り替え設定ファイルの名前を取得する\n     * @return パーツ切り替え設定ファイルの名前\n     */\n    getPoseFileName() {\n        if (!this.isExistPoseFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Pose).getRawString();\n    }\n    /**\n     * 表情設定ファイルの数を取得する\n     * @return 表情設定ファイルの数\n     */\n    getExpressionCount() {\n        if (!this.isExistExpressionFile()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getSize();\n    }\n    /**\n     * 表情設定ファイルを識別する名前（別名）を取得する\n     * @param index 配列のインデックス値\n     * @return 表情の名前\n     */\n    getExpressionName(index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Expressions)\n            .getValueByIndex(index)\n            .getValueByString(Name)\n            .getRawString();\n    }\n    /**\n     * 表情設定ファイルの名前を取得する\n     * @param index 配列のインデックス値\n     * @return 表情設定ファイルの名前\n     */\n    getExpressionFileName(index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Expressions)\n            .getValueByIndex(index)\n            .getValueByString(FilePath)\n            .getRawString();\n    }\n    /**\n     * モーショングループの数を取得する\n     * @return モーショングループの数\n     */\n    getMotionGroupCount() {\n        if (!this.isExistMotionGroups()) {\n            return 0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getKeys()\n            .getSize();\n    }\n    /**\n     * モーショングループの名前を取得する\n     * @param index 配列のインデックス値\n     * @return モーショングループの名前\n     */\n    getMotionGroupName(index) {\n        if (!this.isExistMotionGroups()) {\n            return null;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getKeys()\n            .at(index);\n    }\n    /**\n     * モーショングループに含まれるモーションの数を取得する\n     * @param groupName モーショングループの名前\n     * @return モーショングループの数\n     */\n    getMotionCount(groupName) {\n        if (!this.isExistMotionGroupName(groupName)) {\n            return 0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getSize();\n    }\n    /**\n     * グループ名とインデックス値からモーションファイル名を取得する\n     * @param groupName モーショングループの名前\n     * @param index     配列のインデックス値\n     * @return モーションファイルの名前\n     */\n    getMotionFileName(groupName, index) {\n        if (!this.isExistMotionGroupName(groupName)) {\n            return '';\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FilePath)\n            .getRawString();\n    }\n    /**\n     * モーションに対応するサウンドファイルの名前を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return サウンドファイルの名前\n     */\n    getMotionSoundFileName(groupName, index) {\n        if (!this.isExistMotionSoundFile(groupName, index)) {\n            return '';\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(SoundPath)\n            .getRawString();\n    }\n    /**\n     * モーション開始時のフェードイン処理時間を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return フェードイン処理時間[秒]\n     */\n    getMotionFadeInTimeValue(groupName, index) {\n        if (!this.isExistMotionFadeIn(groupName, index)) {\n            return -1.0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    }\n    /**\n     * モーション終了時のフェードアウト処理時間を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return フェードアウト処理時間[秒]\n     */\n    getMotionFadeOutTimeValue(groupName, index) {\n        if (!this.isExistMotionFadeOut(groupName, index)) {\n            return -1.0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    }\n    /**\n     * ユーザーデータのファイル名を取得する\n     * @return ユーザーデータのファイル名\n     */\n    getUserDataFile() {\n        if (!this.isExistUserDataFile()) {\n            return '';\n        }\n        return this._json\n            .getRoot()\n            .getValueByString(FileReferences)\n            .getValueByString(UserData)\n            .getRawString();\n    }\n    /**\n     * レイアウト情報を取得する\n     * @param outLayoutMap csmMapクラスのインスタンス\n     * @return true レイアウト情報が存在する\n     * @return false レイアウト情報が存在しない\n     */\n    getLayoutMap(outLayoutMap) {\n        // 存在しない要素にアクセスするとエラーになるためValueがnullの場合はnullを代入する\n        const map = this._json\n            .getRoot()\n            .getValueByString(Layout)\n            .getMap();\n        if (map == null) {\n            return false;\n        }\n        let ret = false;\n        for (const ite = map.begin(); ite.notEqual(map.end()); ite.preIncrement()) {\n            outLayoutMap.setValue(ite.ptr().first, ite.ptr().second.toFloat());\n            ret = true;\n        }\n        return ret;\n    }\n    /**\n     * 目パチに関連付けられたパラメータの数を取得する\n     * @return 目パチに関連付けられたパラメータの数\n     */\n    getEyeBlinkParameterCount() {\n        if (!this.isExistEyeBlinkParameters()) {\n            return 0;\n        }\n        let num = 0;\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            const refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == EyeBlink) {\n                num = refI.getValueByString(Ids).getVector().getSize();\n                break;\n            }\n        }\n        return num;\n    }\n    /**\n     * 目パチに関連付けられたパラメータのIDを取得する\n     * @param index 配列のインデックス値\n     * @return パラメータID\n     */\n    getEyeBlinkParameterId(index) {\n        if (!this.isExistEyeBlinkParameters()) {\n            return null;\n        }\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            const refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == EyeBlink) {\n                return live2dcubismframework_1.CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());\n            }\n        }\n        return null;\n    }\n    /**\n     * リップシンクに関連付けられたパラメータの数を取得する\n     * @return リップシンクに関連付けられたパラメータの数\n     */\n    getLipSyncParameterCount() {\n        if (!this.isExistLipSyncParameters()) {\n            return 0;\n        }\n        let num = 0;\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            const refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == LipSync) {\n                num = refI.getValueByString(Ids).getVector().getSize();\n                break;\n            }\n        }\n        return num;\n    }\n    /**\n     * リップシンクに関連付けられたパラメータの数を取得する\n     * @param index 配列のインデックス値\n     * @return パラメータID\n     */\n    getLipSyncParameterId(index) {\n        if (!this.isExistLipSyncParameters()) {\n            return null;\n        }\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            const refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == LipSync) {\n                return live2dcubismframework_1.CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());\n            }\n        }\n        return null;\n    }\n    /**\n     * モデルファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistModelFile() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Moc);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * テクスチャファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistTextureFiles() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Textures);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 当たり判定のキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistHitAreas() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_HitAreas);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 物理演算ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistPhysicsFile() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Physics);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * ポーズ設定ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistPoseFile() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Pose);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 表情設定ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistExpressionFile() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Expressions);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * モーショングループのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistMotionGroups() {\n        const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 引数で指定したモーショングループのキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistMotionGroupName(groupName) {\n        const node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 引数で指定したモーションに対応するサウンドファイルのキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistMotionSoundFile(groupName, index) {\n        const node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(SoundPath);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 引数で指定したモーションに対応するフェードイン時間のキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistMotionFadeIn(groupName, index) {\n        const node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeInTime);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 引数で指定したモーションに対応するフェードアウト時間のキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistMotionFadeOut(groupName, index) {\n        const node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeOutTime);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * UserDataのファイル名が存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistUserDataFile() {\n        const node = this._json\n            .getRoot()\n            .getValueByString(FileReferences)\n            .getValueByString(UserData);\n        return !node.isNull() && !node.isError();\n    }\n    /**\n     * 目ぱちに対応付けられたパラメータが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistEyeBlinkParameters() {\n        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() ||\n            this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {\n            return false;\n        }\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {\n            if (this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i)\n                .getValueByString(Name)\n                .getRawString() == EyeBlink) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * リップシンクに対応付けられたパラメータが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    isExistLipSyncParameters() {\n        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() ||\n            this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {\n            return false;\n        }\n        for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {\n            if (this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i)\n                .getValueByString(Name)\n                .getRawString() == LipSync) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.CubismModelSettingJson = CubismModelSettingJson;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmodelsettingjson */ \"./cubism/Framework/src/cubismmodelsettingjson.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelSettingJson = $.CubismModelSettingJson;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/cubismmodelsettingjson.ts?");

/***/ }),

/***/ "./cubism/Framework/src/effect/cubismbreath.ts":
/*!*****************************************************!*\
  !*** ./cubism/Framework/src/effect/cubismbreath.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.BreathParameterData = exports.CubismBreath = void 0;\n/**\n * 呼吸機能\n *\n * 呼吸機能を提供する。\n */\nclass CubismBreath {\n    /**\n     * インスタンスの作成\n     */\n    static create() {\n        return new CubismBreath();\n    }\n    /**\n     * インスタンスの破棄\n     * @param instance 対象のCubismBreath\n     */\n    static delete(instance) {\n        if (instance != null) {\n            instance = null;\n        }\n    }\n    /**\n     * 呼吸のパラメータの紐づけ\n     * @param breathParameters 呼吸を紐づけたいパラメータのリスト\n     */\n    setParameters(breathParameters) {\n        this._breathParameters = breathParameters;\n    }\n    /**\n     * 呼吸に紐づいているパラメータの取得\n     * @return 呼吸に紐づいているパラメータのリスト\n     */\n    getParameters() {\n        return this._breathParameters;\n    }\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    updateParameters(model, deltaTimeSeconds) {\n        this._currentTime += deltaTimeSeconds;\n        const t = this._currentTime * 2.0 * 3.14159;\n        for (let i = 0; i < this._breathParameters.getSize(); ++i) {\n            const data = this._breathParameters.at(i);\n            model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t / data.cycle), data.weight);\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._currentTime = 0.0;\n    }\n}\nexports.CubismBreath = CubismBreath;\n/**\n * 呼吸のパラメータ情報\n */\nclass BreathParameterData {\n    /**\n     * コンストラクタ\n     * @param parameterId   呼吸をひもづけるパラメータID\n     * @param offset        呼吸を正弦波としたときの、波のオフセット\n     * @param peak          呼吸を正弦波としたときの、波の高さ\n     * @param cycle         呼吸を正弦波としたときの、波の周期\n     * @param weight        パラメータへの重み\n     */\n    constructor(parameterId, offset, peak, cycle, weight) {\n        this.parameterId = parameterId == undefined ? null : parameterId;\n        this.offset = offset == undefined ? 0.0 : offset;\n        this.peak = peak == undefined ? 0.0 : peak;\n        this.cycle = cycle == undefined ? 0.0 : cycle;\n        this.weight = weight == undefined ? 0.0 : weight;\n    }\n}\nexports.BreathParameterData = BreathParameterData;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismbreath */ \"./cubism/Framework/src/effect/cubismbreath.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.BreathParameterData = $.BreathParameterData;\n    Live2DCubismFramework.CubismBreath = $.CubismBreath;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/effect/cubismbreath.ts?");

/***/ }),

/***/ "./cubism/Framework/src/effect/cubismeyeblink.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/effect/cubismeyeblink.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.EyeState = exports.CubismEyeBlink = void 0;\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\n/**\n * 自動まばたき機能\n *\n * 自動まばたき機能を提供する。\n */\nclass CubismEyeBlink {\n    /**\n     * インスタンスを作成する\n     * @param modelSetting モデルの設定情報\n     * @return 作成されたインスタンス\n     * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。\n     */\n    static create(modelSetting = null) {\n        return new CubismEyeBlink(modelSetting);\n    }\n    /**\n     * インスタンスの破棄\n     * @param eyeBlink 対象のCubismEyeBlink\n     */\n    static delete(eyeBlink) {\n        if (eyeBlink != null) {\n            eyeBlink = null;\n        }\n    }\n    /**\n     * まばたきの間隔の設定\n     * @param blinkingInterval まばたきの間隔の時間[秒]\n     */\n    setBlinkingInterval(blinkingInterval) {\n        this._blinkingIntervalSeconds = blinkingInterval;\n    }\n    /**\n     * まばたきのモーションの詳細設定\n     * @param closing   まぶたを閉じる動作の所要時間[秒]\n     * @param closed    まぶたを閉じている動作の所要時間[秒]\n     * @param opening   まぶたを開く動作の所要時間[秒]\n     */\n    setBlinkingSetting(closing, closed, opening) {\n        this._closingSeconds = closing;\n        this._closedSeconds = closed;\n        this._openingSeconds = opening;\n    }\n    /**\n     * まばたきさせるパラメータIDのリストの設定\n     * @param parameterIds パラメータのIDのリスト\n     */\n    setParameterIds(parameterIds) {\n        this._parameterIds = parameterIds;\n    }\n    /**\n     * まばたきさせるパラメータIDのリストの取得\n     * @return パラメータIDのリスト\n     */\n    getParameterIds() {\n        return this._parameterIds;\n    }\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    updateParameters(model, deltaTimeSeconds) {\n        this._userTimeSeconds += deltaTimeSeconds;\n        let parameterValue;\n        let t = 0.0;\n        switch (this._blinkingState) {\n            case EyeState.EyeState_Closing:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._closingSeconds;\n                if (t >= 1.0) {\n                    t = 1.0;\n                    this._blinkingState = EyeState.EyeState_Closed;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 1.0 - t;\n                break;\n            case EyeState.EyeState_Closed:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._closedSeconds;\n                if (t >= 1.0) {\n                    this._blinkingState = EyeState.EyeState_Opening;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 0.0;\n                break;\n            case EyeState.EyeState_Opening:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._openingSeconds;\n                if (t >= 1.0) {\n                    t = 1.0;\n                    this._blinkingState = EyeState.EyeState_Interval;\n                    this._nextBlinkingTime = this.determinNextBlinkingTiming();\n                }\n                parameterValue = t;\n                break;\n            case EyeState.EyeState_Interval:\n                if (this._nextBlinkingTime < this._userTimeSeconds) {\n                    this._blinkingState = EyeState.EyeState_Closing;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 1.0;\n                break;\n            case EyeState.EyeState_First:\n            default:\n                this._blinkingState = EyeState.EyeState_Interval;\n                this._nextBlinkingTime = this.determinNextBlinkingTiming();\n                parameterValue = 1.0;\n                break;\n        }\n        if (!CubismEyeBlink.CloseIfZero) {\n            parameterValue = -parameterValue;\n        }\n        for (let i = 0; i < this._parameterIds.getSize(); ++i) {\n            model.setParameterValueById(this._parameterIds.at(i), parameterValue);\n        }\n    }\n    /**\n     * コンストラクタ\n     * @param modelSetting モデルの設定情報\n     */\n    constructor(modelSetting) {\n        this._blinkingState = EyeState.EyeState_First;\n        this._nextBlinkingTime = 0.0;\n        this._stateStartTimeSeconds = 0.0;\n        this._blinkingIntervalSeconds = 4.0;\n        this._closingSeconds = 0.1;\n        this._closedSeconds = 0.05;\n        this._openingSeconds = 0.15;\n        this._userTimeSeconds = 0.0;\n        this._parameterIds = new csmvector_1.csmVector();\n        if (modelSetting == null) {\n            return;\n        }\n        for (let i = 0; i < modelSetting.getEyeBlinkParameterCount(); ++i) {\n            this._parameterIds.pushBack(modelSetting.getEyeBlinkParameterId(i));\n        }\n    }\n    /**\n     * 次の瞬きのタイミングの決定\n     *\n     * @return 次のまばたきを行う時刻[秒]\n     */\n    determinNextBlinkingTiming() {\n        const r = Math.random();\n        return (this._userTimeSeconds + r * (2.0 * this._blinkingIntervalSeconds - 1.0));\n    }\n}\nexports.CubismEyeBlink = CubismEyeBlink;\n/**\n * IDで指定された目のパラメータが、0のときに閉じるなら true 、1の時に閉じるなら false 。\n */\nCubismEyeBlink.CloseIfZero = true;\n/**\n * まばたきの状態\n *\n * まばたきの状態を表す列挙型\n */\nvar EyeState;\n(function (EyeState) {\n    EyeState[EyeState[\"EyeState_First\"] = 0] = \"EyeState_First\";\n    EyeState[EyeState[\"EyeState_Interval\"] = 1] = \"EyeState_Interval\";\n    EyeState[EyeState[\"EyeState_Closing\"] = 2] = \"EyeState_Closing\";\n    EyeState[EyeState[\"EyeState_Closed\"] = 3] = \"EyeState_Closed\";\n    EyeState[EyeState[\"EyeState_Opening\"] = 4] = \"EyeState_Opening\";\n})(EyeState || (exports.EyeState = EyeState = {}));\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismeyeblink */ \"./cubism/Framework/src/effect/cubismeyeblink.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismEyeBlink = $.CubismEyeBlink;\n    Live2DCubismFramework.EyeState = $.EyeState;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/effect/cubismeyeblink.ts?");

/***/ }),

/***/ "./cubism/Framework/src/effect/cubismpose.ts":
/*!***************************************************!*\
  !*** ./cubism/Framework/src/effect/cubismpose.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.PartData = exports.CubismPose = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ../utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\nconst Epsilon = 0.001;\nconst DefaultFadeInSeconds = 0.5;\n// Pose.jsonのタグ\nconst FadeIn = 'FadeInTime';\nconst Link = 'Link';\nconst Groups = 'Groups';\nconst Id = 'Id';\n/**\n * パーツの不透明度の設定\n *\n * パーツの不透明度の管理と設定を行う。\n */\nclass CubismPose {\n    /**\n     * インスタンスの作成\n     * @param pose3json pose3.jsonのデータ\n     * @param size pose3.jsonのデータのサイズ[byte]\n     * @return 作成されたインスタンス\n     */\n    static create(pose3json, size) {\n        const ret = new CubismPose();\n        const json = cubismjson_1.CubismJson.create(pose3json, size);\n        const root = json.getRoot();\n        // フェード時間の指定\n        if (!root.getValueByString(FadeIn).isNull()) {\n            ret._fadeTimeSeconds = root\n                .getValueByString(FadeIn)\n                .toFloat(DefaultFadeInSeconds);\n            if (ret._fadeTimeSeconds <= 0.0) {\n                ret._fadeTimeSeconds = DefaultFadeInSeconds;\n            }\n        }\n        // パーツグループ\n        const poseListInfo = root.getValueByString(Groups);\n        const poseCount = poseListInfo.getSize();\n        for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {\n            const idListInfo = poseListInfo.getValueByIndex(poseIndex);\n            const idCount = idListInfo.getSize();\n            let groupCount = 0;\n            for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {\n                const partInfo = idListInfo.getValueByIndex(groupIndex);\n                const partData = new PartData();\n                const parameterId = live2dcubismframework_1.CubismFramework.getIdManager().getId(partInfo.getValueByString(Id).getRawString());\n                partData.partId = parameterId;\n                // リンクするパーツの設定\n                if (!partInfo.getValueByString(Link).isNull()) {\n                    const linkListInfo = partInfo.getValueByString(Link);\n                    const linkCount = linkListInfo.getSize();\n                    for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {\n                        const linkPart = new PartData();\n                        const linkId = live2dcubismframework_1.CubismFramework.getIdManager().getId(linkListInfo.getValueByIndex(linkIndex).getString());\n                        linkPart.partId = linkId;\n                        partData.link.pushBack(linkPart);\n                    }\n                }\n                ret._partGroups.pushBack(partData.clone());\n                ++groupCount;\n            }\n            ret._partGroupCounts.pushBack(groupCount);\n        }\n        cubismjson_1.CubismJson.delete(json);\n        return ret;\n    }\n    /**\n     * インスタンスを破棄する\n     * @param pose 対象のCubismPose\n     */\n    static delete(pose) {\n        if (pose != null) {\n            pose = null;\n        }\n    }\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    updateParameters(model, deltaTimeSeconds) {\n        // 前回のモデルと同じでない場合は初期化が必要\n        if (model != this._lastModel) {\n            // パラメータインデックスの初期化\n            this.reset(model);\n        }\n        this._lastModel = model;\n        // 設定から時間を変更すると、経過時間がマイナスになる事があるので、経過時間0として対応\n        if (deltaTimeSeconds < 0.0) {\n            deltaTimeSeconds = 0.0;\n        }\n        let beginIndex = 0;\n        for (let i = 0; i < this._partGroupCounts.getSize(); i++) {\n            const partGroupCount = this._partGroupCounts.at(i);\n            this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);\n            beginIndex += partGroupCount;\n        }\n        this.copyPartOpacities(model);\n    }\n    /**\n     * 表示を初期化\n     * @param model 対象のモデル\n     * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する\n     */\n    reset(model) {\n        let beginIndex = 0;\n        for (let i = 0; i < this._partGroupCounts.getSize(); ++i) {\n            const groupCount = this._partGroupCounts.at(i);\n            for (let j = beginIndex; j < beginIndex + groupCount; ++j) {\n                this._partGroups.at(j).initialize(model);\n                const partsIndex = this._partGroups.at(j).partIndex;\n                const paramIndex = this._partGroups.at(j).parameterIndex;\n                if (partsIndex < 0) {\n                    continue;\n                }\n                model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1.0 : 0.0);\n                model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1.0 : 0.0);\n                for (let k = 0; k < this._partGroups.at(j).link.getSize(); ++k) {\n                    this._partGroups.at(j).link.at(k).initialize(model);\n                }\n            }\n            beginIndex += groupCount;\n        }\n    }\n    /**\n     * パーツの不透明度をコピー\n     *\n     * @param model 対象のモデル\n     */\n    copyPartOpacities(model) {\n        for (let groupIndex = 0; groupIndex < this._partGroups.getSize(); ++groupIndex) {\n            const partData = this._partGroups.at(groupIndex);\n            if (partData.link.getSize() == 0) {\n                continue; // 連動するパラメータはない\n            }\n            const partIndex = this._partGroups.at(groupIndex).partIndex;\n            const opacity = model.getPartOpacityByIndex(partIndex);\n            for (let linkIndex = 0; linkIndex < partData.link.getSize(); ++linkIndex) {\n                const linkPart = partData.link.at(linkIndex);\n                const linkPartIndex = linkPart.partIndex;\n                if (linkPartIndex < 0) {\n                    continue;\n                }\n                model.setPartOpacityByIndex(linkPartIndex, opacity);\n            }\n        }\n    }\n    /**\n     * パーツのフェード操作を行う。\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     * @param beginIndex フェード操作を行うパーツグループの先頭インデックス\n     * @param partGroupCount フェード操作を行うパーツグループの個数\n     */\n    doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {\n        let visiblePartIndex = -1;\n        let newOpacity = 1.0;\n        const phi = 0.5;\n        const backOpacityThreshold = 0.15;\n        // 現在、表示状態になっているパーツを取得\n        for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n            const partIndex = this._partGroups.at(i).partIndex;\n            const paramIndex = this._partGroups.at(i).parameterIndex;\n            if (model.getParameterValueByIndex(paramIndex) > Epsilon) {\n                if (visiblePartIndex >= 0) {\n                    break;\n                }\n                visiblePartIndex = i;\n                newOpacity = model.getPartOpacityByIndex(partIndex);\n                // 新しい不透明度を計算\n                newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;\n                if (newOpacity > 1.0) {\n                    newOpacity = 1.0;\n                }\n            }\n        }\n        if (visiblePartIndex < 0) {\n            visiblePartIndex = 0;\n            newOpacity = 1.0;\n        }\n        // 表示パーツ、非表示パーツの不透明度を設定する\n        for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n            const partsIndex = this._partGroups.at(i).partIndex;\n            // 表示パーツの設定\n            if (visiblePartIndex == i) {\n                model.setPartOpacityByIndex(partsIndex, newOpacity); // 先に設定\n            }\n            // 非表示パーツの設定\n            else {\n                let opacity = model.getPartOpacityByIndex(partsIndex);\n                let a1; // 計算によって求められる不透明度\n                if (newOpacity < phi) {\n                    a1 = (newOpacity * (phi - 1)) / phi + 1.0; // (0,1),(phi,phi)を通る直線式\n                }\n                else {\n                    a1 = ((1 - newOpacity) * phi) / (1.0 - phi); // (1,0),(phi,phi)を通る直線式\n                }\n                // 背景の見える割合を制限する場合\n                const backOpacity = (1.0 - a1) * (1.0 - newOpacity);\n                if (backOpacity > backOpacityThreshold) {\n                    a1 = 1.0 - backOpacityThreshold / (1.0 - newOpacity);\n                }\n                if (opacity > a1) {\n                    opacity = a1; // 計算の不透明度よりも大きければ（濃ければ）不透明度を上げる\n                }\n                model.setPartOpacityByIndex(partsIndex, opacity);\n            }\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._fadeTimeSeconds = DefaultFadeInSeconds;\n        this._lastModel = null;\n        this._partGroups = new csmvector_1.csmVector();\n        this._partGroupCounts = new csmvector_1.csmVector();\n    }\n}\nexports.CubismPose = CubismPose;\n/**\n * パーツにまつわるデータを管理\n */\nclass PartData {\n    /**\n     * コンストラクタ\n     */\n    constructor(v) {\n        this.parameterIndex = 0;\n        this.partIndex = 0;\n        this.link = new csmvector_1.csmVector();\n        if (v != undefined) {\n            this.partId = v.partId;\n            for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {\n                this.link.pushBack(ite.ptr().clone());\n            }\n        }\n    }\n    /**\n     * =演算子のオーバーロード\n     */\n    assignment(v) {\n        this.partId = v.partId;\n        for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {\n            this.link.pushBack(ite.ptr().clone());\n        }\n        return this;\n    }\n    /**\n     * 初期化\n     * @param model 初期化に使用するモデル\n     */\n    initialize(model) {\n        this.parameterIndex = model.getParameterIndex(this.partId);\n        this.partIndex = model.getPartIndex(this.partId);\n        model.setParameterValueByIndex(this.parameterIndex, 1);\n    }\n    /**\n     * オブジェクトのコピーを生成する\n     */\n    clone() {\n        const clonePartData = new PartData();\n        clonePartData.partId = this.partId;\n        clonePartData.parameterIndex = this.parameterIndex;\n        clonePartData.partIndex = this.partIndex;\n        clonePartData.link = new csmvector_1.csmVector();\n        for (let ite = this.link.begin(); ite.notEqual(this.link.end()); ite.increment()) {\n            clonePartData.link.pushBack(ite.ptr().clone());\n        }\n        return clonePartData;\n    }\n}\nexports.PartData = PartData;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismpose */ \"./cubism/Framework/src/effect/cubismpose.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPose = $.CubismPose;\n    Live2DCubismFramework.PartData = $.PartData;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/effect/cubismpose.ts?");

/***/ }),

/***/ "./cubism/Framework/src/icubismmodelsetting.ts":
/*!*****************************************************!*\
  !*** ./cubism/Framework/src/icubismmodelsetting.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.ICubismModelSetting = void 0;\n/**\n * モデル設定情報を取り扱う関数を宣言した純粋仮想クラス。\n *\n * このクラスを継承することで、モデル設定情報を取り扱うクラスになる。\n */\nclass ICubismModelSetting {\n}\nexports.ICubismModelSetting = ICubismModelSetting;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./icubismmodelsetting */ \"./cubism/Framework/src/icubismmodelsetting.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.ICubismModelSetting = $.ICubismModelSetting;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/icubismmodelsetting.ts?");

/***/ }),

/***/ "./cubism/Framework/src/id/cubismid.ts":
/*!*********************************************!*\
  !*** ./cubism/Framework/src/id/cubismid.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismId = void 0;\nconst csmstring_1 = __webpack_require__(/*! ../type/csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\n/**\n * パラメータ名・パーツ名・Drawable名を保持\n *\n * パラメータ名・パーツ名・Drawable名を保持するクラス。\n */\nclass CubismId {\n    /**\n     * ID名を取得する\n     */\n    getString() {\n        return this._id;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor(id) {\n        if (typeof id === 'string') {\n            this._id = new csmstring_1.csmString(id);\n            return;\n        }\n        this._id = id;\n    }\n    /**\n     * idを比較\n     * @param c 比較するid\n     * @return 同じならばtrue,異なっていればfalseを返す\n     */\n    isEqual(c) {\n        if (typeof c === 'string') {\n            return this._id.isEqual(c);\n        }\n        else if (c instanceof csmstring_1.csmString) {\n            return this._id.isEqual(c.s);\n        }\n        else if (c instanceof CubismId) {\n            return this._id.isEqual(c._id.s);\n        }\n        return false;\n    }\n    /**\n     * idを比較\n     * @param c 比較するid\n     * @return 同じならばtrue,異なっていればfalseを返す\n     */\n    isNotEqual(c) {\n        if (typeof c == 'string') {\n            return !this._id.isEqual(c);\n        }\n        else if (c instanceof csmstring_1.csmString) {\n            return !this._id.isEqual(c.s);\n        }\n        else if (c instanceof CubismId) {\n            return !this._id.isEqual(c._id.s);\n        }\n        return false;\n    }\n}\nexports.CubismId = CubismId;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismid */ \"./cubism/Framework/src/id/cubismid.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismId = $.CubismId;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/id/cubismid.ts?");

/***/ }),

/***/ "./cubism/Framework/src/id/cubismidmanager.ts":
/*!****************************************************!*\
  !*** ./cubism/Framework/src/id/cubismidmanager.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismIdManager = void 0;\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismid_1 = __webpack_require__(/*! ./cubismid */ \"./cubism/Framework/src/id/cubismid.ts\");\n/**\n * ID名の管理\n *\n * ID名を管理する。\n */\nclass CubismIdManager {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._ids = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        for (let i = 0; i < this._ids.getSize(); ++i) {\n            this._ids.set(i, void 0);\n        }\n        this._ids = null;\n    }\n    /**\n     * ID名をリストから登録\n     *\n     * @param ids ID名リスト\n     * @param count IDの個数\n     */\n    registerIds(ids) {\n        for (let i = 0; i < ids.length; i++) {\n            this.registerId(ids[i]);\n        }\n    }\n    /**\n     * ID名を登録\n     *\n     * @param id ID名\n     */\n    registerId(id) {\n        let result = null;\n        if ('string' == typeof id) {\n            if ((result = this.findId(id)) != null) {\n                return result;\n            }\n            result = new cubismid_1.CubismId(id);\n            this._ids.pushBack(result);\n        }\n        else {\n            return this.registerId(id.s);\n        }\n        return result;\n    }\n    /**\n     * ID名からIDを取得する\n     *\n     * @param id ID名\n     */\n    getId(id) {\n        return this.registerId(id);\n    }\n    /**\n     * ID名からIDの確認\n     *\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    isExist(id) {\n        if ('string' == typeof id) {\n            return this.findId(id) != null;\n        }\n        return this.isExist(id.s);\n    }\n    /**\n     * ID名からIDを検索する。\n     *\n     * @param id ID名\n     * @return 登録されているID。なければNULL。\n     */\n    findId(id) {\n        for (let i = 0; i < this._ids.getSize(); ++i) {\n            if (this._ids.at(i).getString().isEqual(id)) {\n                return this._ids.at(i);\n            }\n        }\n        return null;\n    }\n}\nexports.CubismIdManager = CubismIdManager;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismidmanager */ \"./cubism/Framework/src/id/cubismidmanager.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismIdManager = $.CubismIdManager;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/id/cubismidmanager.ts?");

/***/ }),

/***/ "./cubism/Framework/src/live2dcubismframework.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/live2dcubismframework.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.LogLevel = exports.Option = exports.CubismFramework = exports.csmDelete = exports.Constant = exports.strtod = void 0;\nconst cubismidmanager_1 = __webpack_require__(/*! ./id/cubismidmanager */ \"./cubism/Framework/src/id/cubismidmanager.ts\");\nconst cubismrenderer_1 = __webpack_require__(/*! ./rendering/cubismrenderer */ \"./cubism/Framework/src/rendering/cubismrenderer.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ./utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ./utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\nfunction strtod(s, endPtr) {\n    let index = 0;\n    for (let i = 1;; i++) {\n        const testC = s.slice(i - 1, i);\n        // 指数・マイナスの可能性があるのでスキップする\n        if (testC == 'e' || testC == '-' || testC == 'E') {\n            continue;\n        } // 文字列の範囲を広げていく\n        const test = s.substring(0, i);\n        const number = Number(test);\n        if (isNaN(number)) {\n            // 数値として認識できなくなったので終了\n            break;\n        } // 最後に数値としてできたindexを格納しておく\n        index = i;\n    }\n    let d = parseFloat(s); // パースした数値\n    if (isNaN(d)) {\n        // 数値として認識できなくなったので終了\n        d = NaN;\n    }\n    endPtr[0] = s.slice(index); // 後続の文字列\n    return d;\n}\nexports.strtod = strtod;\n// ファイルスコープの変数を初期化\nlet s_isStarted = false;\nlet s_isInitialized = false;\nlet s_option = null;\nlet s_cubismIdManager = null;\n/**\n * Framework内で使う定数の宣言\n */\nexports.Constant = Object.freeze({\n    vertexOffset: 0,\n    vertexStep: 2, // メッシュ頂点のステップ値\n});\nfunction csmDelete(address) {\n    if (!address) {\n        return;\n    }\n    address = void 0;\n}\nexports.csmDelete = csmDelete;\n/**\n * Live2D Cubism SDK Original Workflow SDKのエントリポイント\n * 利用開始時はCubismFramework.initialize()を呼び、CubismFramework.dispose()で終了する。\n */\nclass CubismFramework {\n    /**\n     * Cubism FrameworkのAPIを使用可能にする。\n     *  APIを実行する前に必ずこの関数を実行すること。\n     *  一度準備が完了して以降は、再び実行しても内部処理がスキップされます。\n     *\n     * @param    option      Optionクラスのインスタンス\n     *\n     * @return   準備処理が完了したらtrueが返ります。\n     */\n    static startUp(option = null) {\n        if (s_isStarted) {\n            (0, cubismdebug_1.CubismLogInfo)('CubismFramework.startUp() is already done.');\n            return s_isStarted;\n        }\n        s_option = option;\n        if (s_option != null) {\n            Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);\n        }\n        s_isStarted = true;\n        // Live2D Cubism Coreバージョン情報を表示\n        if (s_isStarted) {\n            const version = Live2DCubismCore.Version.csmGetVersion();\n            const major = (version & 0xff000000) >> 24;\n            const minor = (version & 0x00ff0000) >> 16;\n            const patch = version & 0x0000ffff;\n            const versionNumber = version;\n            (0, cubismdebug_1.CubismLogInfo)(`Live2D Cubism Core version: {0}.{1}.{2} ({3})`, ('00' + major).slice(-2), ('00' + minor).slice(-2), ('0000' + patch).slice(-4), versionNumber);\n        }\n        (0, cubismdebug_1.CubismLogInfo)('CubismFramework.startUp() is complete.');\n        return s_isStarted;\n    }\n    /**\n     * StartUp()で初期化したCubismFrameworkの各パラメータをクリアします。\n     * Dispose()したCubismFrameworkを再利用する際に利用してください。\n     */\n    static cleanUp() {\n        s_isStarted = false;\n        s_isInitialized = false;\n        s_option = null;\n        s_cubismIdManager = null;\n    }\n    /**\n     * Cubism Framework内のリソースを初期化してモデルを表示可能な状態にします。<br>\n     *     再度Initialize()するには先にDispose()を実行する必要があります。\n     *\n     * @param memorySize 初期化時メモリ量 [byte(s)]\n     *    複数モデル表示時などにモデルが更新されない際に使用してください。\n     *    指定する際は必ず1024*1024*16 byte(16MB)以上の値を指定してください。\n     *    それ以外はすべて1024*1024*16 byteに丸めます。\n     */\n    static initialize(memorySize = 0) {\n        (0, cubismdebug_1.CSM_ASSERT)(s_isStarted);\n        if (!s_isStarted) {\n            (0, cubismdebug_1.CubismLogWarning)('CubismFramework is not started.');\n            return;\n        }\n        // --- s_isInitializedによる連続初期化ガード ---\n        // 連続してリソース確保が行われないようにする。\n        // 再度Initialize()するには先にDispose()を実行する必要がある。\n        if (s_isInitialized) {\n            (0, cubismdebug_1.CubismLogWarning)('CubismFramework.initialize() skipped, already initialized.');\n            return;\n        }\n        //---- static 初期化 ----\n        cubismjson_1.Value.staticInitializeNotForClientCall();\n        s_cubismIdManager = new cubismidmanager_1.CubismIdManager();\n        // --- HACK: 初期化時メモリ量の拡張(単位byte) ---\n        // 複数モデル表示時などにモデルが更新されない際に使用してください。\n        // 指定する際は必ず1024*1024*16 byte(16MB)以上の値を指定してください。\n        // それ以外はすべて1024*1024*16 byteに丸めます。\n        Live2DCubismCore.Memory.initializeAmountOfMemory(memorySize);\n        s_isInitialized = true;\n        (0, cubismdebug_1.CubismLogInfo)('CubismFramework.initialize() is complete.');\n    }\n    /**\n     * Cubism Framework内の全てのリソースを解放します。\n     *      ただし、外部で確保されたリソースについては解放しません。\n     *      外部で適切に破棄する必要があります。\n     */\n    static dispose() {\n        (0, cubismdebug_1.CSM_ASSERT)(s_isStarted);\n        if (!s_isStarted) {\n            (0, cubismdebug_1.CubismLogWarning)('CubismFramework is not started.');\n            return;\n        }\n        // --- s_isInitializedによる未初期化解放ガード ---\n        // dispose()するには先にinitialize()を実行する必要がある。\n        if (!s_isInitialized) {\n            // false...リソース未確保の場合\n            (0, cubismdebug_1.CubismLogWarning)('CubismFramework.dispose() skipped, not initialized.');\n            return;\n        }\n        cubismjson_1.Value.staticReleaseNotForClientCall();\n        s_cubismIdManager.release();\n        s_cubismIdManager = null;\n        // レンダラの静的リソース（シェーダプログラム他）を解放する\n        cubismrenderer_1.CubismRenderer.staticRelease();\n        s_isInitialized = false;\n        (0, cubismdebug_1.CubismLogInfo)('CubismFramework.dispose() is complete.');\n    }\n    /**\n     * Cubism FrameworkのAPIを使用する準備が完了したかどうか\n     * @return APIを使用する準備が完了していればtrueが返ります。\n     */\n    static isStarted() {\n        return s_isStarted;\n    }\n    /**\n     * Cubism Frameworkのリソース初期化がすでに行われているかどうか\n     * @return リソース確保が完了していればtrueが返ります\n     */\n    static isInitialized() {\n        return s_isInitialized;\n    }\n    /**\n     * Core APIにバインドしたログ関数を実行する\n     *\n     * @praram message ログメッセージ\n     */\n    static coreLogFunction(message) {\n        // Return if logging not possible.\n        if (!Live2DCubismCore.Logging.csmGetLogFunction()) {\n            return;\n        }\n        Live2DCubismCore.Logging.csmGetLogFunction()(message);\n    }\n    /**\n     * 現在のログ出力レベル設定の値を返す。\n     *\n     * @return  現在のログ出力レベル設定の値\n     */\n    static getLoggingLevel() {\n        if (s_option != null) {\n            return s_option.loggingLevel;\n        }\n        return LogLevel.LogLevel_Off;\n    }\n    /**\n     * IDマネージャのインスタンスを取得する\n     * @return CubismManagerクラスのインスタンス\n     */\n    static getIdManager() {\n        return s_cubismIdManager;\n    }\n    /**\n     * 静的クラスとして使用する\n     * インスタンス化させない\n     */\n    constructor() { }\n}\nexports.CubismFramework = CubismFramework;\nclass Option {\n}\nexports.Option = Option;\n/**\n * ログ出力のレベル\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"LogLevel_Verbose\"] = 0] = \"LogLevel_Verbose\";\n    LogLevel[LogLevel[\"LogLevel_Debug\"] = 1] = \"LogLevel_Debug\";\n    LogLevel[LogLevel[\"LogLevel_Info\"] = 2] = \"LogLevel_Info\";\n    LogLevel[LogLevel[\"LogLevel_Warning\"] = 3] = \"LogLevel_Warning\";\n    LogLevel[LogLevel[\"LogLevel_Error\"] = 4] = \"LogLevel_Error\";\n    LogLevel[LogLevel[\"LogLevel_Off\"] = 5] = \"LogLevel_Off\";\n})(LogLevel || (exports.LogLevel = LogLevel = {}));\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.Constant = $.Constant;\n    Live2DCubismFramework.csmDelete = $.csmDelete;\n    Live2DCubismFramework.CubismFramework = $.CubismFramework;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/live2dcubismframework.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismmath.ts":
/*!*************************************************!*\
  !*** ./cubism/Framework/src/math/cubismmath.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMath = void 0;\nconst cubismvector2_1 = __webpack_require__(/*! ./cubismvector2 */ \"./cubism/Framework/src/math/cubismvector2.ts\");\n/**\n * 数値計算などに使用するユーティリティクラス\n */\nclass CubismMath {\n    /**\n     * 第一引数の値を最小値と最大値の範囲に収めた値を返す\n     *\n     * @param value 収められる値\n     * @param min   範囲の最小値\n     * @param max   範囲の最大値\n     * @return 最小値と最大値の範囲に収めた値\n     */\n    static range(value, min, max) {\n        if (value < min) {\n            value = min;\n        }\n        else if (value > max) {\n            value = max;\n        }\n        return value;\n    }\n    /**\n     * サイン関数の値を求める\n     *\n     * @param x 角度値（ラジアン）\n     * @return サイン関数sin(x)の値\n     */\n    static sin(x) {\n        return Math.sin(x);\n    }\n    /**\n     * コサイン関数の値を求める\n     *\n     * @param x 角度値(ラジアン)\n     * @return コサイン関数cos(x)の値\n     */\n    static cos(x) {\n        return Math.cos(x);\n    }\n    /**\n     * 値の絶対値を求める\n     *\n     * @param x 絶対値を求める値\n     * @return 値の絶対値\n     */\n    static abs(x) {\n        return Math.abs(x);\n    }\n    /**\n     * 平方根(ルート)を求める\n     * @param x -> 平方根を求める値\n     * @return 値の平方根\n     */\n    static sqrt(x) {\n        return Math.sqrt(x);\n    }\n    /**\n     * 立方根を求める\n     * @param x -> 立方根を求める値\n     * @return 値の立方根\n     */\n    static cbrt(x) {\n        if (x === 0) {\n            return x;\n        }\n        let cx = x;\n        const isNegativeNumber = cx < 0;\n        if (isNegativeNumber) {\n            cx = -cx;\n        }\n        let ret;\n        if (cx === Infinity) {\n            ret = Infinity;\n        }\n        else {\n            ret = Math.exp(Math.log(cx) / 3);\n            ret = (cx / (ret * ret) + 2 * ret) / 3;\n        }\n        return isNegativeNumber ? -ret : ret;\n    }\n    /**\n     * イージング処理されたサインを求める\n     * フェードイン・アウト時のイージングに利用できる\n     *\n     * @param value イージングを行う値\n     * @return イージング処理されたサイン値\n     */\n    static getEasingSine(value) {\n        if (value < 0.0) {\n            return 0.0;\n        }\n        else if (value > 1.0) {\n            return 1.0;\n        }\n        return 0.5 - 0.5 * this.cos(value * Math.PI);\n    }\n    /**\n     * 大きい方の値を返す\n     *\n     * @param left 左辺の値\n     * @param right 右辺の値\n     * @return 大きい方の値\n     */\n    static max(left, right) {\n        return left > right ? left : right;\n    }\n    /**\n     * 小さい方の値を返す\n     *\n     * @param left  左辺の値\n     * @param right 右辺の値\n     * @return 小さい方の値\n     */\n    static min(left, right) {\n        return left > right ? right : left;\n    }\n    /**\n     * 角度値をラジアン値に変換する\n     *\n     * @param degrees   角度値\n     * @return 角度値から変換したラジアン値\n     */\n    static degreesToRadian(degrees) {\n        return (degrees / 180.0) * Math.PI;\n    }\n    /**\n     * ラジアン値を角度値に変換する\n     *\n     * @param radian    ラジアン値\n     * @return ラジアン値から変換した角度値\n     */\n    static radianToDegrees(radian) {\n        return (radian * 180.0) / Math.PI;\n    }\n    /**\n     * ２つのベクトルからラジアン値を求める\n     *\n     * @param from  始点ベクトル\n     * @param to    終点ベクトル\n     * @return ラジアン値から求めた方向ベクトル\n     */\n    static directionToRadian(from, to) {\n        const q1 = Math.atan2(to.y, to.x);\n        const q2 = Math.atan2(from.y, from.x);\n        let ret = q1 - q2;\n        while (ret < -Math.PI) {\n            ret += Math.PI * 2.0;\n        }\n        while (ret > Math.PI) {\n            ret -= Math.PI * 2.0;\n        }\n        return ret;\n    }\n    /**\n     * ２つのベクトルから角度値を求める\n     *\n     * @param from  始点ベクトル\n     * @param to    終点ベクトル\n     * @return 角度値から求めた方向ベクトル\n     */\n    static directionToDegrees(from, to) {\n        const radian = this.directionToRadian(from, to);\n        let degree = this.radianToDegrees(radian);\n        if (to.x - from.x > 0.0) {\n            degree = -degree;\n        }\n        return degree;\n    }\n    /**\n     * ラジアン値を方向ベクトルに変換する。\n     *\n     * @param totalAngle    ラジアン値\n     * @return ラジアン値から変換した方向ベクトル\n     */\n    static radianToDirection(totalAngle) {\n        const ret = new cubismvector2_1.CubismVector2();\n        ret.x = this.sin(totalAngle);\n        ret.y = this.cos(totalAngle);\n        return ret;\n    }\n    /**\n     * 三次方程式の三次項の係数が0になったときに補欠的に二次方程式の解をもとめる。\n     * a * x^2 + b * x + c = 0\n     *\n     * @param   a -> 二次項の係数値\n     * @param   b -> 一次項の係数値\n     * @param   c -> 定数項の値\n     * @return  二次方程式の解\n     */\n    static quadraticEquation(a, b, c) {\n        if (this.abs(a) < CubismMath.Epsilon) {\n            if (this.abs(b) < CubismMath.Epsilon) {\n                return -c;\n            }\n            return -c / b;\n        }\n        return -(b + this.sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n    }\n    /**\n     * カルダノの公式によってベジェのt値に該当する３次方程式の解を求める。\n     * 重解になったときには0.0～1.0の値になる解を返す。\n     *\n     * a * x^3 + b * x^2 + c * x + d = 0\n     *\n     * @param   a -> 三次項の係数値\n     * @param   b -> 二次項の係数値\n     * @param   c -> 一次項の係数値\n     * @param   d -> 定数項の値\n     * @return  0.0～1.0の間にある解\n     */\n    static cardanoAlgorithmForBezier(a, b, c, d) {\n        if (this.sqrt(a) < CubismMath.Epsilon) {\n            return this.range(this.quadraticEquation(b, c, d), 0.0, 1.0);\n        }\n        const ba = b / a;\n        const ca = c / a;\n        const da = d / a;\n        const p = (3.0 * ca - ba * ba) / 3.0;\n        const p3 = p / 3.0;\n        const q = (2.0 * ba * ba * ba - 9.0 * ba * ca + 27.0 * da) / 27.0;\n        const q2 = q / 2.0;\n        const discriminant = q2 * q2 + p3 * p3 * p3;\n        const center = 0.5;\n        const threshold = center + 0.01;\n        if (discriminant < 0.0) {\n            const mp3 = -p / 3.0;\n            const mp33 = mp3 * mp3 * mp3;\n            const r = this.sqrt(mp33);\n            const t = -q / (2.0 * r);\n            const cosphi = this.range(t, -1.0, 1.0);\n            const phi = Math.acos(cosphi);\n            const crtr = this.cbrt(r);\n            const t1 = 2.0 * crtr;\n            const root1 = t1 * this.cos(phi / 3.0) - ba / 3.0;\n            if (this.abs(root1 - center) < threshold) {\n                return this.range(root1, 0.0, 1.0);\n            }\n            const root2 = t1 * this.cos((phi + 2.0 * Math.PI) / 3.0) - ba / 3.0;\n            if (this.abs(root2 - center) < threshold) {\n                return this.range(root2, 0.0, 1.0);\n            }\n            const root3 = t1 * this.cos((phi + 4.0 * Math.PI) / 3.0) - ba / 3.0;\n            return this.range(root3, 0.0, 1.0);\n        }\n        if (discriminant == 0.0) {\n            let u1;\n            if (q2 < 0.0) {\n                u1 = this.cbrt(-q2);\n            }\n            else {\n                u1 = -this.cbrt(q2);\n            }\n            const root1 = 2.0 * u1 - ba / 3.0;\n            if (this.abs(root1 - center) < threshold) {\n                return this.range(root1, 0.0, 1.0);\n            }\n            const root2 = -u1 - ba / 3.0;\n            return this.range(root2, 0.0, 1.0);\n        }\n        const sd = this.sqrt(discriminant);\n        const u1 = this.cbrt(sd - q2);\n        const v1 = this.cbrt(sd + q2);\n        const root1 = u1 - v1 - ba / 3.0;\n        return this.range(root1, 0.0, 1.0);\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() { }\n}\nexports.CubismMath = CubismMath;\nCubismMath.Epsilon = 0.00001;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmath */ \"./cubism/Framework/src/math/cubismmath.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMath = $.CubismMath;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismmath.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismmatrix44.ts":
/*!*****************************************************!*\
  !*** ./cubism/Framework/src/math/cubismmatrix44.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMatrix44 = void 0;\n/**\n * 4x4の行列\n *\n * 4x4行列の便利クラス。\n */\nclass CubismMatrix44 {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._tr = new Float32Array(16); // 4 * 4のサイズ\n        this.loadIdentity();\n    }\n    /**\n     * 受け取った２つの行列の乗算を行う。\n     *\n     * @param a 行列a\n     * @param b 行列b\n     * @return 乗算結果の行列\n     */\n    static multiply(a, b, dst) {\n        const c = new Float32Array([\n            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n            0.0,\n        ]);\n        const n = 4;\n        for (let i = 0; i < n; ++i) {\n            for (let j = 0; j < n; ++j) {\n                for (let k = 0; k < n; ++k) {\n                    c[j + i * 4] += a[k + i * 4] * b[j + k * 4];\n                }\n            }\n        }\n        for (let i = 0; i < 16; ++i) {\n            dst[i] = c[i];\n        }\n    }\n    /**\n     * 単位行列に初期化する\n     */\n    loadIdentity() {\n        const c = new Float32Array([\n            1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,\n            1.0,\n        ]);\n        this.setMatrix(c);\n    }\n    /**\n     * 行列を設定\n     *\n     * @param tr 16個の浮動小数点数で表される4x4の行列\n     */\n    setMatrix(tr) {\n        for (let i = 0; i < 16; ++i) {\n            this._tr[i] = tr[i];\n        }\n    }\n    /**\n     * 行列を浮動小数点数の配列で取得\n     *\n     * @return 16個の浮動小数点数で表される4x4の行列\n     */\n    getArray() {\n        return this._tr;\n    }\n    /**\n     * X軸の拡大率を取得\n     * @return X軸の拡大率\n     */\n    getScaleX() {\n        return this._tr[0];\n    }\n    /**\n     * Y軸の拡大率を取得する\n     *\n     * @return Y軸の拡大率\n     */\n    getScaleY() {\n        return this._tr[5];\n    }\n    /**\n     * X軸の移動量を取得\n     * @return X軸の移動量\n     */\n    getTranslateX() {\n        return this._tr[12];\n    }\n    /**\n     * Y軸の移動量を取得\n     * @return Y軸の移動量\n     */\n    getTranslateY() {\n        return this._tr[13];\n    }\n    /**\n     * X軸の値を現在の行列で計算\n     *\n     * @param src X軸の値\n     * @return 現在の行列で計算されたX軸の値\n     */\n    transformX(src) {\n        return this._tr[0] * src + this._tr[12];\n    }\n    /**\n     * Y軸の値を現在の行列で計算\n     *\n     * @param src Y軸の値\n     * @return 現在の行列で計算されたY軸の値\n     */\n    transformY(src) {\n        return this._tr[5] * src + this._tr[13];\n    }\n    /**\n     * X軸の値を現在の行列で逆計算\n     */\n    invertTransformX(src) {\n        return (src - this._tr[12]) / this._tr[0];\n    }\n    /**\n     * Y軸の値を現在の行列で逆計算\n     */\n    invertTransformY(src) {\n        return (src - this._tr[13]) / this._tr[5];\n    }\n    /**\n     * 現在の行列の位置を起点にして移動\n     *\n     * 現在の行列の位置を起点にして相対的に移動する。\n     *\n     * @param x X軸の移動量\n     * @param y Y軸の移動量\n     */\n    translateRelative(x, y) {\n        const tr1 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            x,\n            y,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    }\n    /**\n     * 現在の行列の位置を移動\n     *\n     * 現在の行列の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     * @param y y軸の移動量\n     */\n    translate(x, y) {\n        this._tr[12] = x;\n        this._tr[13] = y;\n    }\n    /**\n     * 現在の行列のX軸の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     */\n    translateX(x) {\n        this._tr[12] = x;\n    }\n    /**\n     * 現在の行列のY軸の位置を指定した位置へ移動する\n     *\n     * @param y Y軸の移動量\n     */\n    translateY(y) {\n        this._tr[13] = y;\n    }\n    /**\n     * 現在の行列の拡大率を相対的に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    scaleRelative(x, y) {\n        const tr1 = new Float32Array([\n            x,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            y,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    }\n    /**\n     * 現在の行列の拡大率を指定した倍率に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    scale(x, y) {\n        this._tr[0] = x;\n        this._tr[5] = y;\n    }\n    /**\n     * 現在の行列に行列を乗算\n     *\n     * @param m 行列\n     */\n    multiplyByMatrix(m) {\n        CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);\n    }\n    /**\n     * オブジェクトのコピーを生成する\n     */\n    clone() {\n        const cloneMatrix = new CubismMatrix44();\n        for (let i = 0; i < this._tr.length; i++) {\n            cloneMatrix._tr[i] = this._tr[i];\n        }\n        return cloneMatrix;\n    }\n}\nexports.CubismMatrix44 = CubismMatrix44;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMatrix44 = $.CubismMatrix44;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismmatrix44.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismmodelmatrix.ts":
/*!********************************************************!*\
  !*** ./cubism/Framework/src/math/cubismmodelmatrix.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismModelMatrix = void 0;\nconst cubismmatrix44_1 = __webpack_require__(/*! ./cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\n/**\n * モデル座標設定用の4x4行列\n *\n * モデル座標設定用の4x4行列クラス\n */\nclass CubismModelMatrix extends cubismmatrix44_1.CubismMatrix44 {\n    /**\n     * コンストラクタ\n     *\n     * @param w 横幅\n     * @param h 縦幅\n     */\n    constructor(w, h) {\n        super();\n        this._width = w !== undefined ? w : 0.0;\n        this._height = h !== undefined ? h : 0.0;\n        this.setHeight(2.0);\n    }\n    /**\n     * 横幅を設定\n     *\n     * @param w 横幅\n     */\n    setWidth(w) {\n        const scaleX = w / this._width;\n        const scaleY = scaleX;\n        this.scale(scaleX, scaleY);\n    }\n    /**\n     * 縦幅を設定\n     * @param h 縦幅\n     */\n    setHeight(h) {\n        const scaleX = h / this._height;\n        const scaleY = scaleX;\n        this.scale(scaleX, scaleY);\n    }\n    /**\n     * 位置を設定\n     *\n     * @param x X軸の位置\n     * @param y Y軸の位置\n     */\n    setPosition(x, y) {\n        this.translate(x, y);\n    }\n    /**\n     * 中心位置を設定\n     *\n     * @param x X軸の中心位置\n     * @param y Y軸の中心位置\n     *\n     * @note widthかheightを設定したあとでないと、拡大率が正しく取得できないためずれる。\n     */\n    setCenterPosition(x, y) {\n        this.centerX(x);\n        this.centerY(y);\n    }\n    /**\n     * 上辺の位置を設定する\n     *\n     * @param y 上辺のY軸位置\n     */\n    top(y) {\n        this.setY(y);\n    }\n    /**\n     * 下辺の位置を設定する\n     *\n     * @param y 下辺のY軸位置\n     */\n    bottom(y) {\n        const h = this._height * this.getScaleY();\n        this.translateY(y - h);\n    }\n    /**\n     * 左辺の位置を設定\n     *\n     * @param x 左辺のX軸位置\n     */\n    left(x) {\n        this.setX(x);\n    }\n    /**\n     * 右辺の位置を設定\n     *\n     * @param x 右辺のX軸位置\n     */\n    right(x) {\n        const w = this._width * this.getScaleX();\n        this.translateX(x - w);\n    }\n    /**\n     * X軸の中心位置を設定\n     *\n     * @param x X軸の中心位置\n     */\n    centerX(x) {\n        const w = this._width * this.getScaleX();\n        this.translateX(x - w / 2.0);\n    }\n    /**\n     * X軸の位置を設定\n     *\n     * @param x X軸の位置\n     */\n    setX(x) {\n        this.translateX(x);\n    }\n    /**\n     * Y軸の中心位置を設定\n     *\n     * @param y Y軸の中心位置\n     */\n    centerY(y) {\n        const h = this._height * this.getScaleY();\n        this.translateY(y - h / 2.0);\n    }\n    /**\n     * Y軸の位置を設定する\n     *\n     * @param y Y軸の位置\n     */\n    setY(y) {\n        this.translateY(y);\n    }\n    /**\n     * レイアウト情報から位置を設定\n     *\n     * @param layout レイアウト情報\n     */\n    setupFromLayout(layout) {\n        const keyWidth = 'width';\n        const keyHeight = 'height';\n        const keyX = 'x';\n        const keyY = 'y';\n        const keyCenterX = 'center_x';\n        const keyCenterY = 'center_y';\n        const keyTop = 'top';\n        const keyBottom = 'bottom';\n        const keyLeft = 'left';\n        const keyRight = 'right';\n        for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {\n            const key = ite.ptr().first;\n            const value = ite.ptr().second;\n            if (key == keyWidth) {\n                this.setWidth(value);\n            }\n            else if (key == keyHeight) {\n                this.setHeight(value);\n            }\n        }\n        for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {\n            const key = ite.ptr().first;\n            const value = ite.ptr().second;\n            if (key == keyX) {\n                this.setX(value);\n            }\n            else if (key == keyY) {\n                this.setY(value);\n            }\n            else if (key == keyCenterX) {\n                this.centerX(value);\n            }\n            else if (key == keyCenterY) {\n                this.centerY(value);\n            }\n            else if (key == keyTop) {\n                this.top(value);\n            }\n            else if (key == keyBottom) {\n                this.bottom(value);\n            }\n            else if (key == keyLeft) {\n                this.left(value);\n            }\n            else if (key == keyRight) {\n                this.right(value);\n            }\n        }\n    }\n}\nexports.CubismModelMatrix = CubismModelMatrix;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmodelmatrix */ \"./cubism/Framework/src/math/cubismmodelmatrix.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelMatrix = $.CubismModelMatrix;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismmodelmatrix.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismtargetpoint.ts":
/*!********************************************************!*\
  !*** ./cubism/Framework/src/math/cubismtargetpoint.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismTargetPoint = void 0;\nconst cubismmath_1 = __webpack_require__(/*! ./cubismmath */ \"./cubism/Framework/src/math/cubismmath.ts\");\nconst FrameRate = 30;\nconst Epsilon = 0.01;\n/**\n * 顔の向きの制御機能\n *\n * 顔の向きの制御機能を提供するクラス。\n */\nclass CubismTargetPoint {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._faceTargetX = 0.0;\n        this._faceTargetY = 0.0;\n        this._faceX = 0.0;\n        this._faceY = 0.0;\n        this._faceVX = 0.0;\n        this._faceVY = 0.0;\n        this._lastTimeSeconds = 0.0;\n        this._userTimeSeconds = 0.0;\n    }\n    /**\n     * 更新処理\n     */\n    update(deltaTimeSeconds) {\n        // デルタ時間を加算する\n        this._userTimeSeconds += deltaTimeSeconds;\n        // 首を中央から左右に振るときの平均的な速さは 秒速度。加速・減速を考慮して、その２倍を最高速度とする\n        // 顔の振り具合を、中央（0.0）から、左右は（+-1.0）とする\n        const faceParamMaxV = 40.0 / 10.0; // 7.5秒間に40分移動(5.3/sc)\n        const maxV = (faceParamMaxV * 1.0) / FrameRate; // 1frameあたりに変化できる速度の上限\n        if (this._lastTimeSeconds == 0.0) {\n            this._lastTimeSeconds = this._userTimeSeconds;\n            return;\n        }\n        const deltaTimeWeight = (this._userTimeSeconds - this._lastTimeSeconds) * FrameRate;\n        this._lastTimeSeconds = this._userTimeSeconds;\n        // 最高速度になるまでの時間を\n        const timeToMaxSpeed = 0.15;\n        const frameToMaxSpeed = timeToMaxSpeed * FrameRate; // sec * frame/sec\n        const maxA = (deltaTimeWeight * maxV) / frameToMaxSpeed; // 1frameあたりの加速度\n        // 目指す向きは、（dx, dy）方向のベクトルとなる\n        const dx = this._faceTargetX - this._faceX;\n        const dy = this._faceTargetY - this._faceY;\n        if (cubismmath_1.CubismMath.abs(dx) <= Epsilon && cubismmath_1.CubismMath.abs(dy) <= Epsilon) {\n            return; // 変化なし\n        }\n        // 速度の最大よりも大きい場合は、速度を落とす\n        const d = cubismmath_1.CubismMath.sqrt(dx * dx + dy * dy);\n        // 進行方向の最大速度ベクトル\n        const vx = (maxV * dx) / d;\n        const vy = (maxV * dy) / d;\n        // 現在の速度から、新規速度への変化（加速度）を求める\n        let ax = vx - this._faceVX;\n        let ay = vy - this._faceVY;\n        const a = cubismmath_1.CubismMath.sqrt(ax * ax + ay * ay);\n        // 加速のとき\n        if (a < -maxA || a > maxA) {\n            ax *= maxA / a;\n            ay *= maxA / a;\n        }\n        // 加速度を元の速度に足して、新速度とする\n        this._faceVX += ax;\n        this._faceVY += ay;\n        // 目的の方向に近づいたとき、滑らかに減速するための処理\n        // 設定された加速度で止まる事の出来る距離と速度の関係から\n        // 現在とりうる最高速度を計算し、それ以上の時は速度を落とす\n        // ※本来、人間は筋力で力（加速度）を調整できるため、より自由度が高いが、簡単な処理で済ませている\n        {\n            // 加速度、速度、距離の関係式。\n            //            2  6           2               3\n            //      sqrt(a  t  + 16 a h t  - 8 a h) - a t\n            // v = --------------------------------------\n            //                    2\n            //                 4 t  - 2\n            // (t=1)\n            // \t時刻tは、あらかじめ加速度、速度を1/60(フレームレート、単位なし)で\n            // \t考えているので、t＝１として消してよい（※未検証）\n            const maxV = 0.5 *\n                (cubismmath_1.CubismMath.sqrt(maxA * maxA + 16.0 * maxA * d - 8.0 * maxA * d) -\n                    maxA);\n            const curV = cubismmath_1.CubismMath.sqrt(this._faceVX * this._faceVX + this._faceVY * this._faceVY);\n            if (curV > maxV) {\n                // 現在の速度 > 最高速度のとき、最高速度まで減速\n                this._faceVX *= maxV / curV;\n                this._faceVY *= maxV / curV;\n            }\n        }\n        this._faceX += this._faceVX;\n        this._faceY += this._faceVY;\n    }\n    /**\n     * X軸の顔の向きの値を取得\n     *\n     * @return X軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    getX() {\n        return this._faceX;\n    }\n    /**\n     * Y軸の顔の向きの値を取得\n     *\n     * @return Y軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    getY() {\n        return this._faceY;\n    }\n    /**\n     * 顔の向きの目標値を設定\n     *\n     * @param x X軸の顔の向きの値（-1.0 ~ 1.0）\n     * @param y Y軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    set(x, y) {\n        this._faceTargetX = x;\n        this._faceTargetY = y;\n    }\n}\nexports.CubismTargetPoint = CubismTargetPoint;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismtargetpoint */ \"./cubism/Framework/src/math/cubismtargetpoint.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismTargetPoint = $.CubismTargetPoint;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismtargetpoint.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismvector2.ts":
/*!****************************************************!*\
  !*** ./cubism/Framework/src/math/cubismvector2.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismVector2 = void 0;\n/**\n * 2次元ベクトル型\n *\n * 2次元ベクトル型の機能を提供する。\n */\nclass CubismVector2 {\n    /**\n     * コンストラクタ\n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.x = x == undefined ? 0.0 : x;\n        this.y = y == undefined ? 0.0 : y;\n    }\n    /**\n     * ベクトルの加算\n     *\n     * @param vector2 加算するベクトル値\n     * @return 加算結果 ベクトル値\n     */\n    add(vector2) {\n        const ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x + vector2.x;\n        ret.y = this.y + vector2.y;\n        return ret;\n    }\n    /**\n     * ベクトルの減算\n     *\n     * @param vector2 減算するベクトル値\n     * @return 減算結果 ベクトル値\n     */\n    substract(vector2) {\n        const ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x - vector2.x;\n        ret.y = this.y - vector2.y;\n        return ret;\n    }\n    /**\n     * ベクトルの乗算\n     *\n     * @param vector2 乗算するベクトル値\n     * @return 乗算結果 ベクトル値\n     */\n    multiply(vector2) {\n        const ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x * vector2.x;\n        ret.y = this.y * vector2.y;\n        return ret;\n    }\n    /**\n     * ベクトルの乗算(スカラー)\n     *\n     * @param scalar 乗算するスカラー値\n     * @return 乗算結果 ベクトル値\n     */\n    multiplyByScaler(scalar) {\n        return this.multiply(new CubismVector2(scalar, scalar));\n    }\n    /**\n     * ベクトルの除算\n     *\n     * @param vector2 除算するベクトル値\n     * @return 除算結果 ベクトル値\n     */\n    division(vector2) {\n        const ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x / vector2.x;\n        ret.y = this.y / vector2.y;\n        return ret;\n    }\n    /**\n     * ベクトルの除算(スカラー)\n     *\n     * @param scalar 除算するスカラー値\n     * @return 除算結果 ベクトル値\n     */\n    divisionByScalar(scalar) {\n        return this.division(new CubismVector2(scalar, scalar));\n    }\n    /**\n     * ベクトルの長さを取得する\n     *\n     * @return ベクトルの長さ\n     */\n    getLength() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * ベクトルの距離の取得\n     *\n     * @param a 点\n     * @return ベクトルの距離\n     */\n    getDistanceWith(a) {\n        return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));\n    }\n    /**\n     * ドット積の計算\n     *\n     * @param a 値\n     * @return 結果\n     */\n    dot(a) {\n        return this.x * a.x + this.y * a.y;\n    }\n    /**\n     * 正規化の適用\n     */\n    normalize() {\n        const length = Math.pow(this.x * this.x + this.y * this.y, 0.5);\n        this.x = this.x / length;\n        this.y = this.y / length;\n    }\n    /**\n     * 等しさの確認（等しいか？）\n     *\n     * 値が等しいか？\n     *\n     * @param rhs 確認する値\n     * @return true 値は等しい\n     * @return false 値は等しくない\n     */\n    isEqual(rhs) {\n        return this.x == rhs.x && this.y == rhs.y;\n    }\n    /**\n     * 等しさの確認（等しくないか？）\n     *\n     * 値が等しくないか？\n     *\n     * @param rhs 確認する値\n     * @return true 値は等しくない\n     * @return false 値は等しい\n     */\n    isNotEqual(rhs) {\n        return !this.isEqual(rhs);\n    }\n}\nexports.CubismVector2 = CubismVector2;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismvector2 */ \"./cubism/Framework/src/math/cubismvector2.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismVector2 = $.CubismVector2;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismvector2.ts?");

/***/ }),

/***/ "./cubism/Framework/src/math/cubismviewmatrix.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/math/cubismviewmatrix.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismViewMatrix = void 0;\nconst cubismmatrix44_1 = __webpack_require__(/*! ./cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\n/**\n * カメラの位置変更に使うと便利な4x4行列\n *\n * カメラの位置変更に使うと便利な4x4行列のクラス。\n */\nclass CubismViewMatrix extends cubismmatrix44_1.CubismMatrix44 {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._screenLeft = 0.0;\n        this._screenRight = 0.0;\n        this._screenTop = 0.0;\n        this._screenBottom = 0.0;\n        this._maxLeft = 0.0;\n        this._maxRight = 0.0;\n        this._maxTop = 0.0;\n        this._maxBottom = 0.0;\n        this._maxScale = 0.0;\n        this._minScale = 0.0;\n    }\n    /**\n     * 移動を調整\n     *\n     * @param x X軸の移動量\n     * @param y Y軸の移動量\n     */\n    adjustTranslate(x, y) {\n        if (this._tr[0] * this._maxLeft + (this._tr[12] + x) > this._screenLeft) {\n            x = this._screenLeft - this._tr[0] * this._maxLeft - this._tr[12];\n        }\n        if (this._tr[0] * this._maxRight + (this._tr[12] + x) < this._screenRight) {\n            x = this._screenRight - this._tr[0] * this._maxRight - this._tr[12];\n        }\n        if (this._tr[5] * this._maxTop + (this._tr[13] + y) < this._screenTop) {\n            y = this._screenTop - this._tr[5] * this._maxTop - this._tr[13];\n        }\n        if (this._tr[5] * this._maxBottom + (this._tr[13] + y) >\n            this._screenBottom) {\n            y = this._screenBottom - this._tr[5] * this._maxBottom - this._tr[13];\n        }\n        const tr1 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            x,\n            y,\n            0.0,\n            1.0,\n        ]);\n        cubismmatrix44_1.CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    }\n    /**\n     * 拡大率を調整\n     *\n     * @param cx 拡大を行うX軸の中心位置\n     * @param cy 拡大を行うY軸の中心位置\n     * @param scale 拡大率\n     */\n    adjustScale(cx, cy, scale) {\n        const maxScale = this.getMaxScale();\n        const minScale = this.getMinScale();\n        const targetScale = scale * this._tr[0];\n        if (targetScale < minScale) {\n            if (this._tr[0] > 0.0) {\n                scale = minScale / this._tr[0];\n            }\n        }\n        else if (targetScale > maxScale) {\n            if (this._tr[0] > 0.0) {\n                scale = maxScale / this._tr[0];\n            }\n        }\n        const tr1 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            cx,\n            cy,\n            0.0,\n            1.0,\n        ]);\n        const tr2 = new Float32Array([\n            scale,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            scale,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n        ]);\n        const tr3 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            -cx,\n            -cy,\n            0.0,\n            1.0,\n        ]);\n        cubismmatrix44_1.CubismMatrix44.multiply(tr3, this._tr, this._tr);\n        cubismmatrix44_1.CubismMatrix44.multiply(tr2, this._tr, this._tr);\n        cubismmatrix44_1.CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    }\n    /**\n     * デバイスに対応する論理座養生の範囲の設定\n     *\n     * @param left      左辺のX軸の位置\n     * @param right     右辺のX軸の位置\n     * @param bottom    下辺のY軸の位置\n     * @param top       上辺のY軸の位置\n     */\n    setScreenRect(left, right, bottom, top) {\n        this._screenLeft = left;\n        this._screenRight = right;\n        this._screenBottom = bottom;\n        this._screenTop = top;\n    }\n    /**\n     * デバイスに対応する論理座標上の移動可能範囲の設定\n     * @param left      左辺のX軸の位置\n     * @param right     右辺のX軸の位置\n     * @param bottom    下辺のY軸の位置\n     * @param top       上辺のY軸の位置\n     */\n    setMaxScreenRect(left, right, bottom, top) {\n        this._maxLeft = left;\n        this._maxRight = right;\n        this._maxTop = top;\n        this._maxBottom = bottom;\n    }\n    /**\n     * 最大拡大率の設定\n     * @param maxScale 最大拡大率\n     */\n    setMaxScale(maxScale) {\n        this._maxScale = maxScale;\n    }\n    /**\n     * 最小拡大率の設定\n     * @param minScale 最小拡大率\n     */\n    setMinScale(minScale) {\n        this._minScale = minScale;\n    }\n    /**\n     * 最大拡大率の取得\n     * @return 最大拡大率\n     */\n    getMaxScale() {\n        return this._maxScale;\n    }\n    /**\n     * 最小拡大率の取得\n     * @return 最小拡大率\n     */\n    getMinScale() {\n        return this._minScale;\n    }\n    /**\n     * 拡大率が最大になっているかを確認する\n     *\n     * @return true 拡大率は最大\n     * @return false 拡大率は最大ではない\n     */\n    isMaxScale() {\n        return this.getScaleX() >= this._maxScale;\n    }\n    /**\n     * 拡大率が最小になっているかを確認する\n     *\n     * @return true 拡大率は最小\n     * @return false 拡大率は最小ではない\n     */\n    isMinScale() {\n        return this.getScaleX() <= this._minScale;\n    }\n    /**\n     * デバイスに対応する論理座標の左辺のＸ軸位置を取得する\n     * @return デバイスに対応する論理座標の左辺のX軸位置\n     */\n    getScreenLeft() {\n        return this._screenLeft;\n    }\n    /**\n     * デバイスに対応する論理座標の右辺のＸ軸位置を取得する\n     * @return デバイスに対応する論理座標の右辺のX軸位置\n     */\n    getScreenRight() {\n        return this._screenRight;\n    }\n    /**\n     * デバイスに対応する論理座標の下辺のY軸位置を取得する\n     * @return デバイスに対応する論理座標の下辺のY軸位置\n     */\n    getScreenBottom() {\n        return this._screenBottom;\n    }\n    /**\n     * デバイスに対応する論理座標の上辺のY軸位置を取得する\n     * @return デバイスに対応する論理座標の上辺のY軸位置\n     */\n    getScreenTop() {\n        return this._screenTop;\n    }\n    /**\n     * 左辺のX軸位置の最大値の取得\n     * @return 左辺のX軸位置の最大値\n     */\n    getMaxLeft() {\n        return this._maxLeft;\n    }\n    /**\n     * 右辺のX軸位置の最大値の取得\n     * @return 右辺のX軸位置の最大値\n     */\n    getMaxRight() {\n        return this._maxRight;\n    }\n    /**\n     * 下辺のY軸位置の最大値の取得\n     * @return 下辺のY軸位置の最大値\n     */\n    getMaxBottom() {\n        return this._maxBottom;\n    }\n    /**\n     * 上辺のY軸位置の最大値の取得\n     * @return 上辺のY軸位置の最大値\n     */\n    getMaxTop() {\n        return this._maxTop;\n    }\n}\nexports.CubismViewMatrix = CubismViewMatrix;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismviewmatrix */ \"./cubism/Framework/src/math/cubismviewmatrix.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismViewMatrix = $.CubismViewMatrix;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/math/cubismviewmatrix.ts?");

/***/ }),

/***/ "./cubism/Framework/src/model/cubismmoc.ts":
/*!*************************************************!*\
  !*** ./cubism/Framework/src/model/cubismmoc.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMoc = void 0;\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst cubismmodel_1 = __webpack_require__(/*! ./cubismmodel */ \"./cubism/Framework/src/model/cubismmodel.ts\");\n/**\n * Mocデータの管理\n *\n * Mocデータの管理を行うクラス。\n */\nclass CubismMoc {\n    /**\n     * Mocデータの作成\n     */\n    static create(mocBytes, shouldCheckMocConsistency) {\n        let cubismMoc = null;\n        if (shouldCheckMocConsistency) {\n            // .moc3の整合性を確認\n            const consistency = this.hasMocConsistency(mocBytes);\n            if (!consistency) {\n                // 整合性が確認できなければ処理しない\n                (0, cubismdebug_1.CubismLogError)(`Inconsistent MOC3.`);\n                return cubismMoc;\n            }\n        }\n        const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);\n        if (moc) {\n            cubismMoc = new CubismMoc(moc);\n            cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(moc, mocBytes);\n        }\n        return cubismMoc;\n    }\n    /**\n     * Mocデータを削除\n     *\n     * Mocデータを削除する\n     */\n    static delete(moc) {\n        moc._moc._release();\n        moc._moc = null;\n        moc = null;\n    }\n    /**\n     * モデルを作成する\n     *\n     * @return Mocデータから作成されたモデル\n     */\n    createModel() {\n        let cubismModel = null;\n        const model = Live2DCubismCore.Model.fromMoc(this._moc);\n        if (model) {\n            cubismModel = new cubismmodel_1.CubismModel(model);\n            cubismModel.initialize();\n            ++this._modelCount;\n        }\n        return cubismModel;\n    }\n    /**\n     * モデルを削除する\n     */\n    deleteModel(model) {\n        if (model != null) {\n            model.release();\n            model = null;\n            --this._modelCount;\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor(moc) {\n        this._moc = moc;\n        this._modelCount = 0;\n        this._mocVersion = 0;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        (0, cubismdebug_1.CSM_ASSERT)(this._modelCount == 0);\n        this._moc._release();\n        this._moc = null;\n    }\n    /**\n     * 最新の.moc3 Versionを取得\n     */\n    getLatestMocVersion() {\n        return Live2DCubismCore.Version.csmGetLatestMocVersion();\n    }\n    /**\n     * 読み込んだモデルの.moc3 Versionを取得\n     */\n    getMocVersion() {\n        return this._mocVersion;\n    }\n    /**\n     * .moc3 の整合性を検証する\n     */\n    static hasMocConsistency(mocBytes) {\n        const isConsistent = Live2DCubismCore.Moc.prototype.hasMocConsistency(mocBytes);\n        return isConsistent === 1 ? true : false;\n    }\n}\nexports.CubismMoc = CubismMoc;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmoc */ \"./cubism/Framework/src/model/cubismmoc.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMoc = $.CubismMoc;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/model/cubismmoc.ts?");

/***/ }),

/***/ "./cubism/Framework/src/model/cubismmodel.ts":
/*!***************************************************!*\
  !*** ./cubism/Framework/src/model/cubismmodel.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismModel = exports.DrawableCullingData = exports.PartColorData = exports.DrawableColorData = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismrenderer_1 = __webpack_require__(/*! ../rendering/cubismrenderer */ \"./cubism/Framework/src/rendering/cubismrenderer.ts\");\nconst csmmap_1 = __webpack_require__(/*! ../type/csmmap */ \"./cubism/Framework/src/type/csmmap.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\n/**\n * SDK側から与えられたDrawableの乗算色・スクリーン色上書きフラグと\n * その色を保持する構造体\n */\nclass DrawableColorData {\n    constructor(isOverwritten = false, color = new cubismrenderer_1.CubismTextureColor()) {\n        this.isOverwritten = isOverwritten;\n        this.Color = color;\n    }\n}\nexports.DrawableColorData = DrawableColorData;\n/**\n * @brief テクスチャの色をRGBAで扱うための構造体\n */\nclass PartColorData {\n    constructor(isOverwritten = false, color = new cubismrenderer_1.CubismTextureColor()) {\n        this.isOverwritten = isOverwritten;\n        this.Color = color;\n    }\n}\nexports.PartColorData = PartColorData;\n/**\n * テクスチャのカリング設定を管理するための構造体\n */\nclass DrawableCullingData {\n    /**\n     * コンストラクタ\n     *\n     * @param isOverwritten\n     * @param isCulling\n     */\n    constructor(isOverwritten = false, isCulling = false) {\n        this.isOverwritten = isOverwritten;\n        this.isCulling = isCulling;\n    }\n}\nexports.DrawableCullingData = DrawableCullingData;\n/**\n * モデル\n *\n * Mocデータから生成されるモデルのクラス。\n */\nclass CubismModel {\n    /**\n     * モデルのパラメータの更新\n     */\n    update() {\n        // Update model\n        this._model.update();\n        this._model.drawables.resetDynamicFlags();\n    }\n    /**\n     * PixelsPerUnitを取得する\n     * @returns PixelsPerUnit\n     */\n    getPixelsPerUnit() {\n        if (this._model == null) {\n            return 0.0;\n        }\n        return this._model.canvasinfo.PixelsPerUnit;\n    }\n    /**\n     * キャンバスの幅を取得する\n     */\n    getCanvasWidth() {\n        if (this._model == null) {\n            return 0.0;\n        }\n        return (this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit);\n    }\n    /**\n     * キャンバスの高さを取得する\n     */\n    getCanvasHeight() {\n        if (this._model == null) {\n            return 0.0;\n        }\n        return (this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit);\n    }\n    /**\n     * パラメータを保存する\n     */\n    saveParameters() {\n        const parameterCount = this._model.parameters.count;\n        const savedParameterCount = this._savedParameters.getSize();\n        for (let i = 0; i < parameterCount; ++i) {\n            if (i < savedParameterCount) {\n                this._savedParameters.set(i, this._parameterValues[i]);\n            }\n            else {\n                this._savedParameters.pushBack(this._parameterValues[i]);\n            }\n        }\n    }\n    /**\n     * 乗算色を取得する\n     * @param index Drawablesのインデックス\n     * @returns 指定したdrawableの乗算色(RGBA)\n     */\n    getMultiplyColor(index) {\n        // Drawableとモデル全体の乗算色上書きフラグがどちらもtrueな場合、モデル全体の上書きフラグが優先される\n        if (this.getOverwriteFlagForModelMultiplyColors() ||\n            this.getOverwriteFlagForDrawableMultiplyColors(index)) {\n            return this._userMultiplyColors.at(index).Color;\n        }\n        const color = this.getDrawableMultiplyColor(index);\n        return color;\n    }\n    /**\n     * スクリーン色を取得する\n     * @param index Drawablesのインデックス\n     * @returns 指定したdrawableのスクリーン色(RGBA)\n     */\n    getScreenColor(index) {\n        // Drawableとモデル全体のスクリーン色上書きフラグがどちらもtrueな場合、モデル全体の上書きフラグが優先される\n        if (this.getOverwriteFlagForModelScreenColors() ||\n            this.getOverwriteFlagForDrawableScreenColors(index)) {\n            return this._userScreenColors.at(index).Color;\n        }\n        const color = this.getDrawableScreenColor(index);\n        return color;\n    }\n    /**\n     * 乗算色をセットする\n     * @param index Drawablesのインデックス\n     * @param color 設定する乗算色(CubismTextureColor)\n     */\n    setMultiplyColorByTextureColor(index, color) {\n        this.setMultiplyColorByRGBA(index, color.R, color.G, color.B, color.A);\n    }\n    /**\n     * 乗算色をセットする\n     * @param index Drawablesのインデックス\n     * @param r 設定する乗算色のR値\n     * @param g 設定する乗算色のG値\n     * @param b 設定する乗算色のB値\n     * @param a 設定する乗算色のA値\n     */\n    setMultiplyColorByRGBA(index, r, g, b, a = 1.0) {\n        this._userMultiplyColors.at(index).Color.R = r;\n        this._userMultiplyColors.at(index).Color.G = g;\n        this._userMultiplyColors.at(index).Color.B = b;\n        this._userMultiplyColors.at(index).Color.A = a;\n    }\n    /**\n     * スクリーン色をセットする\n     * @param index Drawablesのインデックス\n     * @param color 設定するスクリーン色(CubismTextureColor)\n     */\n    setScreenColorByTextureColor(index, color) {\n        this.setScreenColorByRGBA(index, color.R, color.G, color.B, color.A);\n    }\n    /**\n     * スクリーン色をセットする\n     * @param index Drawablesのインデックス\n     * @param r 設定するスクリーン色のR値\n     * @param g 設定するスクリーン色のG値\n     * @param b 設定するスクリーン色のB値\n     * @param a 設定するスクリーン色のA値\n     */\n    setScreenColorByRGBA(index, r, g, b, a = 1.0) {\n        this._userScreenColors.at(index).Color.R = r;\n        this._userScreenColors.at(index).Color.G = g;\n        this._userScreenColors.at(index).Color.B = b;\n        this._userScreenColors.at(index).Color.A = a;\n    }\n    /**\n     * partの乗算色を取得する\n     * @param partIndex partのインデックス\n     * @returns 指定したpartの乗算色\n     */\n    getPartMultiplyColor(partIndex) {\n        return this._userPartMultiplyColors.at(partIndex).Color;\n    }\n    /**\n     * partのスクリーン色を取得する\n     * @param partIndex partのインデックス\n     * @returns 指定したpartのスクリーン色\n     */\n    getPartScreenColor(partIndex) {\n        return this._userPartScreenColors.at(partIndex).Color;\n    }\n    /**\n     * partのOverwriteColor setter関数\n     * @param partIndex partのインデックス\n     * @param r 設定する色のR値\n     * @param g 設定する色のG値\n     * @param b 設定する色のB値\n     * @param a 設定する色のA値\n     * @param partColors 設定するpartのカラーデータ配列\n     * @param drawableColors partに関連するDrawableのカラーデータ配列\n     */\n    setPartColor(partIndex, r, g, b, a, partColors, drawableColors) {\n        partColors.at(partIndex).Color.R = r;\n        partColors.at(partIndex).Color.G = g;\n        partColors.at(partIndex).Color.B = b;\n        partColors.at(partIndex).Color.A = a;\n        if (partColors.at(partIndex).isOverwritten) {\n            for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {\n                const drawableIndex = this._partChildDrawables.at(partIndex).at(i);\n                drawableColors.at(drawableIndex).Color.R = r;\n                drawableColors.at(drawableIndex).Color.G = g;\n                drawableColors.at(drawableIndex).Color.B = b;\n                drawableColors.at(drawableIndex).Color.A = a;\n            }\n        }\n    }\n    /**\n     * 乗算色をセットする\n     * @param partIndex partのインデックス\n     * @param color 設定する乗算色(CubismTextureColor)\n     */\n    setPartMultiplyColorByTextureColor(partIndex, color) {\n        this.setPartMultiplyColorByRGBA(partIndex, color.R, color.G, color.B, color.A);\n    }\n    /**\n     * 乗算色をセットする\n     * @param partIndex partのインデックス\n     * @param r 設定する乗算色のR値\n     * @param g 設定する乗算色のG値\n     * @param b 設定する乗算色のB値\n     * @param a 設定する乗算色のA値\n     */\n    setPartMultiplyColorByRGBA(partIndex, r, g, b, a) {\n        this.setPartColor(partIndex, r, g, b, a, this._userPartMultiplyColors, this._userMultiplyColors);\n    }\n    /**\n     * スクリーン色をセットする\n     * @param partIndex partのインデックス\n     * @param color 設定するスクリーン色(CubismTextureColor)\n     */\n    setPartScreenColorByTextureColor(partIndex, color) {\n        this.setPartScreenColorByRGBA(partIndex, color.R, color.G, color.B, color.A);\n    }\n    /**\n     * スクリーン色をセットする\n     * @param partIndex partのインデックス\n     * @param r 設定するスクリーン色のR値\n     * @param g 設定するスクリーン色のG値\n     * @param b 設定するスクリーン色のB値\n     * @param a 設定するスクリーン色のA値\n     */\n    setPartScreenColorByRGBA(partIndex, r, g, b, a) {\n        this.setPartColor(partIndex, r, g, b, a, this._userPartScreenColors, this._userScreenColors);\n    }\n    /**\n     * SDKから指定したモデルの乗算色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    getOverwriteFlagForModelMultiplyColors() {\n        return this._isOverwrittenModelMultiplyColors;\n    }\n    /**\n     * SDKから指定したモデルのスクリーン色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    getOverwriteFlagForModelScreenColors() {\n        return this._isOverwrittenModelScreenColors;\n    }\n    /**\n     * SDKから指定したモデルの乗算色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteFlagForModelMultiplyColors(value) {\n        this._isOverwrittenModelMultiplyColors = value;\n    }\n    /**\n     * SDKから指定したモデルのスクリーン色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteFlagForModelScreenColors(value) {\n        this._isOverwrittenModelScreenColors = value;\n    }\n    /**\n     * SDKから指定したDrawableIndexの乗算色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    getOverwriteFlagForDrawableMultiplyColors(drawableindex) {\n        return this._userMultiplyColors.at(drawableindex).isOverwritten;\n    }\n    /**\n     * SDKから指定したDrawableIndexのスクリーン色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    getOverwriteFlagForDrawableScreenColors(drawableindex) {\n        return this._userScreenColors.at(drawableindex).isOverwritten;\n    }\n    /**\n     * SDKから指定したDrawableIndexの乗算色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteFlagForDrawableMultiplyColors(drawableindex, value) {\n        this._userMultiplyColors.at(drawableindex).isOverwritten = value;\n    }\n    /**\n     * SDKから指定したDrawableIndexのスクリーン色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteFlagForDrawableScreenColors(drawableindex, value) {\n        this._userScreenColors.at(drawableindex).isOverwritten = value;\n    }\n    /**\n     * SDKからpartの乗算色を上書きするか\n     * @param partIndex partのインデックス\n     * @returns true    ->  SDKからの情報を優先する\n     *          false   ->  モデルに設定されている色情報を使用\n     */\n    getOverwriteColorForPartMultiplyColors(partIndex) {\n        return this._userPartMultiplyColors.at(partIndex).isOverwritten;\n    }\n    /**\n     * SDKからpartのスクリーン色を上書きするか\n     * @param partIndex partのインデックス\n     * @returns true    ->  SDKからの情報を優先する\n     *          false   ->  モデルに設定されている色情報を使用\n     */\n    getOverwriteColorForPartScreenColors(partIndex) {\n        return this._userPartScreenColors.at(partIndex).isOverwritten;\n    }\n    /**\n     * partのOverwriteFlag setter関数\n     * @param partIndex partのインデックス\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     * @param partColors 設定するpartのカラーデータ配列\n     * @param drawableColors partに関連するDrawableのカラーデータ配列\n     */\n    setOverwriteColorForPartColors(partIndex, value, partColors, drawableColors) {\n        partColors.at(partIndex).isOverwritten = value;\n        for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {\n            const drawableIndex = this._partChildDrawables.at(partIndex).at(i);\n            drawableColors.at(drawableIndex).isOverwritten = value;\n            if (value) {\n                drawableColors.at(drawableIndex).Color.R =\n                    partColors.at(partIndex).Color.R;\n                drawableColors.at(drawableIndex).Color.G =\n                    partColors.at(partIndex).Color.G;\n                drawableColors.at(drawableIndex).Color.B =\n                    partColors.at(partIndex).Color.B;\n                drawableColors.at(drawableIndex).Color.A =\n                    partColors.at(partIndex).Color.A;\n            }\n        }\n    }\n    /**\n     * SDKからpartのスクリーン色を上書きするかをセットする\n     * @param partIndex partのインデックス\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteColorForPartMultiplyColors(partIndex, value) {\n        this._userPartMultiplyColors.at(partIndex).isOverwritten = value;\n        this.setOverwriteColorForPartColors(partIndex, value, this._userPartMultiplyColors, this._userMultiplyColors);\n    }\n    /**\n     * SDKからpartのスクリーン色を上書きするかをセットする\n     * @param partIndex partのインデックス\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    setOverwriteColorForPartScreenColors(partIndex, value) {\n        this._userPartScreenColors.at(partIndex).isOverwritten = value;\n        this.setOverwriteColorForPartColors(partIndex, value, this._userPartScreenColors, this._userScreenColors);\n    }\n    /**\n     * Drawableのカリング情報を取得する。\n     *\n     * @param   drawableIndex   Drawableのインデックス\n     * @return  Drawableのカリング情報\n     */\n    getDrawableCulling(drawableIndex) {\n        if (this.getOverwriteFlagForModelCullings() ||\n            this.getOverwriteFlagForDrawableCullings(drawableIndex)) {\n            return this._userCullings.at(drawableIndex).isCulling;\n        }\n        const constantFlags = this._model.drawables.constantFlags;\n        return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);\n    }\n    /**\n     * Drawableのカリング情報を設定する。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @param isCulling カリング情報\n     */\n    setDrawableCulling(drawableIndex, isCulling) {\n        this._userCullings.at(drawableIndex).isCulling = isCulling;\n    }\n    /**\n     * SDKからモデル全体のカリング設定を上書きするか。\n     *\n     * @retval  true    ->  SDK上のカリング設定を使用\n     * @retval  false   ->  モデルのカリング設定を使用\n     */\n    getOverwriteFlagForModelCullings() {\n        return this._isOverwrittenCullings;\n    }\n    /**\n     * SDKからモデル全体のカリング設定を上書きするかを設定する。\n     *\n     * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse\n     */\n    setOverwriteFlagForModelCullings(isOverwrittenCullings) {\n        this._isOverwrittenCullings = isOverwrittenCullings;\n    }\n    /**\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @retval  true    ->  SDK上のカリング設定を使用\n     * @retval  false   ->  モデルのカリング設定を使用\n     */\n    getOverwriteFlagForDrawableCullings(drawableIndex) {\n        return this._userCullings.at(drawableIndex).isOverwritten;\n    }\n    /**\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse\n     */\n    setOverwriteFlagForDrawableCullings(drawableIndex, isOverwrittenCullings) {\n        this._userCullings.at(drawableIndex).isOverwritten = isOverwrittenCullings;\n    }\n    /**\n     * モデルの不透明度を取得する\n     *\n     * @returns 不透明度の値\n     */\n    getModelOapcity() {\n        return this._modelOpacity;\n    }\n    /**\n     * モデルの不透明度を設定する\n     *\n     * @param value 不透明度の値\n     */\n    setModelOapcity(value) {\n        this._modelOpacity = value;\n    }\n    /**\n     * モデルを取得\n     */\n    getModel() {\n        return this._model;\n    }\n    /**\n     * パーツのインデックスを取得\n     * @param partId パーツのID\n     * @return パーツのインデックス\n     */\n    getPartIndex(partId) {\n        let partIndex;\n        const partCount = this._model.parts.count;\n        for (partIndex = 0; partIndex < partCount; ++partIndex) {\n            if (partId == this._partIds.at(partIndex)) {\n                return partIndex;\n            }\n        }\n        // モデルに存在していない場合、非存在パーツIDリスト内にあるかを検索し、そのインデックスを返す\n        if (this._notExistPartId.isExist(partId)) {\n            return this._notExistPartId.getValue(partId);\n        }\n        // 非存在パーツIDリストにない場合、新しく要素を追加する\n        partIndex = partCount + this._notExistPartId.getSize();\n        this._notExistPartId.setValue(partId, partIndex);\n        this._notExistPartOpacities.appendKey(partIndex);\n        return partIndex;\n    }\n    /**\n     * パーツのIDを取得する。\n     *\n     * @param partIndex 取得するパーツのインデックス\n     * @return パーツのID\n     */\n    getPartId(partIndex) {\n        const partId = this._model.parts.ids[partIndex];\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(partId);\n    }\n    /**\n     * パーツの個数の取得\n     * @return パーツの個数\n     */\n    getPartCount() {\n        const partCount = this._model.parts.count;\n        return partCount;\n    }\n    /**\n     * パーツの不透明度の設定(Index)\n     * @param partIndex パーツのインデックス\n     * @param opacity 不透明度\n     */\n    setPartOpacityByIndex(partIndex, opacity) {\n        if (this._notExistPartOpacities.isExist(partIndex)) {\n            this._notExistPartOpacities.setValue(partIndex, opacity);\n            return;\n        }\n        // インデックスの範囲内検知\n        (0, cubismdebug_1.CSM_ASSERT)(0 <= partIndex && partIndex < this.getPartCount());\n        this._partOpacities[partIndex] = opacity;\n    }\n    /**\n     * パーツの不透明度の設定(Id)\n     * @param partId パーツのID\n     * @param opacity パーツの不透明度\n     */\n    setPartOpacityById(partId, opacity) {\n        // 高速化のためにPartIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        const index = this.getPartIndex(partId);\n        if (index < 0) {\n            return; // パーツがないのでスキップ\n        }\n        this.setPartOpacityByIndex(index, opacity);\n    }\n    /**\n     * パーツの不透明度の取得(index)\n     * @param partIndex パーツのインデックス\n     * @return パーツの不透明度\n     */\n    getPartOpacityByIndex(partIndex) {\n        if (this._notExistPartOpacities.isExist(partIndex)) {\n            // モデルに存在しないパーツIDの場合、非存在パーツリストから不透明度を返す。\n            return this._notExistPartOpacities.getValue(partIndex);\n        }\n        // インデックスの範囲内検知\n        (0, cubismdebug_1.CSM_ASSERT)(0 <= partIndex && partIndex < this.getPartCount());\n        return this._partOpacities[partIndex];\n    }\n    /**\n     * パーツの不透明度の取得(id)\n     * @param partId パーツのＩｄ\n     * @return パーツの不透明度\n     */\n    getPartOpacityById(partId) {\n        // 高速化のためにPartIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        const index = this.getPartIndex(partId);\n        if (index < 0) {\n            return 0; // パーツが無いのでスキップ\n        }\n        return this.getPartOpacityByIndex(index);\n    }\n    /**\n     * パラメータのインデックスの取得\n     * @param パラメータID\n     * @return パラメータのインデックス\n     */\n    getParameterIndex(parameterId) {\n        let parameterIndex;\n        const idCount = this._model.parameters.count;\n        for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {\n            if (parameterId != this._parameterIds.at(parameterIndex)) {\n                continue;\n            }\n            return parameterIndex;\n        }\n        // モデルに存在していない場合、非存在パラメータIDリスト内を検索し、そのインデックスを返す\n        if (this._notExistParameterId.isExist(parameterId)) {\n            return this._notExistParameterId.getValue(parameterId);\n        }\n        // 非存在パラメータIDリストにない場合新しく要素を追加する\n        parameterIndex =\n            this._model.parameters.count + this._notExistParameterId.getSize();\n        this._notExistParameterId.setValue(parameterId, parameterIndex);\n        this._notExistParameterValues.appendKey(parameterIndex);\n        return parameterIndex;\n    }\n    /**\n     * パラメータの個数の取得\n     * @return パラメータの個数\n     */\n    getParameterCount() {\n        return this._model.parameters.count;\n    }\n    /**\n     * パラメータの種類の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return csmParameterType_Normal -> 通常のパラメータ\n     *          csmParameterType_BlendShape -> ブレンドシェイプパラメータ\n     */\n    getParameterType(parameterIndex) {\n        return this._model.parameters.types[parameterIndex];\n    }\n    /**\n     * パラメータの最大値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータの最大値\n     */\n    getParameterMaximumValue(parameterIndex) {\n        return this._model.parameters.maximumValues[parameterIndex];\n    }\n    /**\n     * パラメータの最小値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータの最小値\n     */\n    getParameterMinimumValue(parameterIndex) {\n        return this._model.parameters.minimumValues[parameterIndex];\n    }\n    /**\n     * パラメータのデフォルト値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータのデフォルト値\n     */\n    getParameterDefaultValue(parameterIndex) {\n        return this._model.parameters.defaultValues[parameterIndex];\n    }\n    /**\n     * パラメータの値の取得\n     * @param parameterIndex    パラメータのインデックス\n     * @return パラメータの値\n     */\n    getParameterValueByIndex(parameterIndex) {\n        if (this._notExistParameterValues.isExist(parameterIndex)) {\n            return this._notExistParameterValues.getValue(parameterIndex);\n        }\n        // インデックスの範囲内検知\n        (0, cubismdebug_1.CSM_ASSERT)(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n        return this._parameterValues[parameterIndex];\n    }\n    /**\n     * パラメータの値の取得\n     * @param parameterId    パラメータのID\n     * @return パラメータの値\n     */\n    getParameterValueById(parameterId) {\n        // 高速化のためにparameterIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        const parameterIndex = this.getParameterIndex(parameterId);\n        return this.getParameterValueByIndex(parameterIndex);\n    }\n    /**\n     * パラメータの値の設定\n     * @param parameterIndex パラメータのインデックス\n     * @param value パラメータの値\n     * @param weight 重み\n     */\n    setParameterValueByIndex(parameterIndex, value, weight = 1.0) {\n        if (this._notExistParameterValues.isExist(parameterIndex)) {\n            this._notExistParameterValues.setValue(parameterIndex, weight == 1\n                ? value\n                : this._notExistParameterValues.getValue(parameterIndex) *\n                    (1 - weight) +\n                    value * weight);\n            return;\n        }\n        // インデックスの範囲内検知\n        (0, cubismdebug_1.CSM_ASSERT)(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n        if (this._model.parameters.maximumValues[parameterIndex] < value) {\n            value = this._model.parameters.maximumValues[parameterIndex];\n        }\n        if (this._model.parameters.minimumValues[parameterIndex] > value) {\n            value = this._model.parameters.minimumValues[parameterIndex];\n        }\n        this._parameterValues[parameterIndex] =\n            weight == 1\n                ? value\n                : (this._parameterValues[parameterIndex] =\n                    this._parameterValues[parameterIndex] * (1 - weight) +\n                        value * weight);\n    }\n    /**\n     * パラメータの値の設定\n     * @param parameterId パラメータのID\n     * @param value パラメータの値\n     * @param weight 重み\n     */\n    setParameterValueById(parameterId, value, weight = 1.0) {\n        const index = this.getParameterIndex(parameterId);\n        this.setParameterValueByIndex(index, value, weight);\n    }\n    /**\n     * パラメータの値の加算(index)\n     * @param parameterIndex パラメータインデックス\n     * @param value 加算する値\n     * @param weight 重み\n     */\n    addParameterValueByIndex(parameterIndex, value, weight = 1.0) {\n        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);\n    }\n    /**\n     * パラメータの値の加算(id)\n     * @param parameterId パラメータＩＤ\n     * @param value 加算する値\n     * @param weight 重み\n     */\n    addParameterValueById(parameterId, value, weight = 1.0) {\n        const index = this.getParameterIndex(parameterId);\n        this.addParameterValueByIndex(index, value, weight);\n    }\n    /**\n     * パラメータの値の乗算\n     * @param parameterId パラメータのID\n     * @param value 乗算する値\n     * @param weight 重み\n     */\n    multiplyParameterValueById(parameterId, value, weight = 1.0) {\n        const index = this.getParameterIndex(parameterId);\n        this.multiplyParameterValueByIndex(index, value, weight);\n    }\n    /**\n     * パラメータの値の乗算\n     * @param parameterIndex パラメータのインデックス\n     * @param value 乗算する値\n     * @param weight 重み\n     */\n    multiplyParameterValueByIndex(parameterIndex, value, weight = 1.0) {\n        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) *\n            (1.0 + (value - 1.0) * weight));\n    }\n    /**\n     * Drawableのインデックスの取得\n     * @param drawableId DrawableのID\n     * @return Drawableのインデックス\n     */\n    getDrawableIndex(drawableId) {\n        const drawableCount = this._model.drawables.count;\n        for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {\n            if (this._drawableIds.at(drawableIndex) == drawableId) {\n                return drawableIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Drawableの個数の取得\n     * @return drawableの個数\n     */\n    getDrawableCount() {\n        const drawableCount = this._model.drawables.count;\n        return drawableCount;\n    }\n    /**\n     * DrawableのIDを取得する\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのID\n     */\n    getDrawableId(drawableIndex) {\n        const parameterIds = this._model.drawables.ids;\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(parameterIds[drawableIndex]);\n    }\n    /**\n     * Drawableの描画順リストの取得\n     * @return Drawableの描画順リスト\n     */\n    getDrawableRenderOrders() {\n        const renderOrders = this._model.drawables.renderOrders;\n        return renderOrders;\n    }\n    /**\n     * @deprecated\n     * 関数名が誤っていたため、代替となる getDrawableTextureIndex を追加し、この関数は非推奨となりました。\n     *\n     * Drawableのテクスチャインデックスリストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのテクスチャインデックスリスト\n     */\n    getDrawableTextureIndices(drawableIndex) {\n        return this.getDrawableTextureIndex(drawableIndex);\n    }\n    /**\n     * Drawableのテクスチャインデックスの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのテクスチャインデックス\n     */\n    getDrawableTextureIndex(drawableIndex) {\n        const textureIndices = this._model.drawables.textureIndices;\n        return textureIndices[drawableIndex];\n    }\n    /**\n     * DrawableのVertexPositionsの変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。\n     *\n     * @param   drawableIndex   Drawableのインデックス\n     * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した\n     * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない\n     */\n    getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * Drawableの頂点インデックスの個数の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点インデックスの個数\n     */\n    getDrawableVertexIndexCount(drawableIndex) {\n        const indexCounts = this._model.drawables.indexCounts;\n        return indexCounts[drawableIndex];\n    }\n    /**\n     * Drawableの頂点の個数の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点の個数\n     */\n    getDrawableVertexCount(drawableIndex) {\n        const vertexCounts = this._model.drawables.vertexCounts;\n        return vertexCounts[drawableIndex];\n    }\n    /**\n     * Drawableの頂点リストの取得\n     * @param drawableIndex drawableのインデックス\n     * @return drawableの頂点リスト\n     */\n    getDrawableVertices(drawableIndex) {\n        return this.getDrawableVertexPositions(drawableIndex);\n    }\n    /**\n     * Drawableの頂点インデックスリストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点インデックスリスト\n     */\n    getDrawableVertexIndices(drawableIndex) {\n        const indicesArray = this._model.drawables.indices;\n        return indicesArray[drawableIndex];\n    }\n    /**\n     * Drawableの頂点リストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点リスト\n     */\n    getDrawableVertexPositions(drawableIndex) {\n        const verticesArray = this._model.drawables.vertexPositions;\n        return verticesArray[drawableIndex];\n    }\n    /**\n     * Drawableの頂点のUVリストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点UVリスト\n     */\n    getDrawableVertexUvs(drawableIndex) {\n        const uvsArray = this._model.drawables.vertexUvs;\n        return uvsArray[drawableIndex];\n    }\n    /**\n     * Drawableの不透明度の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの不透明度\n     */\n    getDrawableOpacity(drawableIndex) {\n        const opacities = this._model.drawables.opacities;\n        return opacities[drawableIndex];\n    }\n    /**\n     * Drawableの乗算色の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの乗算色(RGBA)\n     * スクリーン色はRGBAで取得されるが、Aは必ず0\n     */\n    getDrawableMultiplyColor(drawableIndex) {\n        const multiplyColors = this._model.drawables.multiplyColors;\n        const index = drawableIndex * 4;\n        const multiplyColor = new cubismrenderer_1.CubismTextureColor();\n        multiplyColor.R = multiplyColors[index];\n        multiplyColor.G = multiplyColors[index + 1];\n        multiplyColor.B = multiplyColors[index + 2];\n        multiplyColor.A = multiplyColors[index + 3];\n        return multiplyColor;\n    }\n    /**\n     * Drawableのスクリーン色の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのスクリーン色(RGBA)\n     * スクリーン色はRGBAで取得されるが、Aは必ず0\n     */\n    getDrawableScreenColor(drawableIndex) {\n        const screenColors = this._model.drawables.screenColors;\n        const index = drawableIndex * 4;\n        const screenColor = new cubismrenderer_1.CubismTextureColor();\n        screenColor.R = screenColors[index];\n        screenColor.G = screenColors[index + 1];\n        screenColor.B = screenColors[index + 2];\n        screenColor.A = screenColors[index + 3];\n        return screenColor;\n    }\n    /**\n     * Drawableの親パーツのインデックスの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの親パーツのインデックス\n     */\n    getDrawableParentPartIndex(drawableIndex) {\n        return this._model.drawables.parentPartIndices[drawableIndex];\n    }\n    /**\n     * Drawableのブレンドモードを取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのブレンドモード\n     */\n    getDrawableBlendMode(drawableIndex) {\n        const constantFlags = this._model.drawables.constantFlags;\n        return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex])\n            ? cubismrenderer_1.CubismBlendMode.CubismBlendMode_Additive\n            : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex])\n                ? cubismrenderer_1.CubismBlendMode.CubismBlendMode_Multiplicative\n                : cubismrenderer_1.CubismBlendMode.CubismBlendMode_Normal;\n    }\n    /**\n     * Drawableのマスクの反転使用の取得\n     *\n     * Drawableのマスク使用時の反転設定を取得する。\n     * マスクを使用しない場合は無視される。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return Drawableの反転設定\n     */\n    getDrawableInvertedMaskBit(drawableIndex) {\n        const constantFlags = this._model.drawables.constantFlags;\n        return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);\n    }\n    /**\n     * Drawableのクリッピングマスクリストの取得\n     * @return Drawableのクリッピングマスクリスト\n     */\n    getDrawableMasks() {\n        const masks = this._model.drawables.masks;\n        return masks;\n    }\n    /**\n     * Drawableのクリッピングマスクの個数リストの取得\n     * @return Drawableのクリッピングマスクの個数リスト\n     */\n    getDrawableMaskCounts() {\n        const maskCounts = this._model.drawables.maskCounts;\n        return maskCounts;\n    }\n    /**\n     * クリッピングマスクの使用状態\n     *\n     * @return true クリッピングマスクを使用している\n     * @return false クリッピングマスクを使用していない\n     */\n    isUsingMasking() {\n        for (let d = 0; d < this._model.drawables.count; ++d) {\n            if (this._model.drawables.maskCounts[d] <= 0) {\n                continue;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Drawableの表示情報を取得する\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableが表示\n     * @return false Drawableが非表示\n     */\n    getDrawableDynamicFlagIsVisible(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * DrawableのDrawOrderの変化情報の取得\n     *\n     * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。\n     * drawOrderはartMesh上で指定する0から1000の情報\n     * @param drawableIndex drawableのインデックス\n     * @return true drawableの不透明度が直近のCubismModel.update関数で変化した\n     * @return false drawableの不透明度が直近のCubismModel.update関数で変化している\n     */\n    getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * Drawableの不透明度の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。\n     *\n     * @param drawableIndex drawableのインデックス\n     * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した\n     * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない\n     */\n    getDrawableDynamicFlagOpacityDidChange(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * Drawableの描画順序の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した\n     * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない\n     */\n    getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * Drawableの乗算色・スクリーン色の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの乗算色・スクリーン色が変化したかを取得する。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化した\n     * @return false Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化してない\n     */\n    getDrawableDynamicFlagBlendColorDidChange(drawableIndex) {\n        const dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(dynamicFlags[drawableIndex]);\n    }\n    /**\n     * 保存されたパラメータの読み込み\n     */\n    loadParameters() {\n        let parameterCount = this._model.parameters.count;\n        const savedParameterCount = this._savedParameters.getSize();\n        if (parameterCount > savedParameterCount) {\n            parameterCount = savedParameterCount;\n        }\n        for (let i = 0; i < parameterCount; ++i) {\n            this._parameterValues[i] = this._savedParameters.at(i);\n        }\n    }\n    /**\n     * 初期化する\n     */\n    initialize() {\n        (0, cubismdebug_1.CSM_ASSERT)(this._model);\n        this._parameterValues = this._model.parameters.values;\n        this._partOpacities = this._model.parts.opacities;\n        this._parameterMaximumValues = this._model.parameters.maximumValues;\n        this._parameterMinimumValues = this._model.parameters.minimumValues;\n        {\n            const parameterIds = this._model.parameters.ids;\n            const parameterCount = this._model.parameters.count;\n            this._parameterIds.prepareCapacity(parameterCount);\n            for (let i = 0; i < parameterCount; ++i) {\n                this._parameterIds.pushBack(live2dcubismframework_1.CubismFramework.getIdManager().getId(parameterIds[i]));\n            }\n        }\n        const partCount = this._model.parts.count;\n        {\n            const partIds = this._model.parts.ids;\n            this._partIds.prepareCapacity(partCount);\n            for (let i = 0; i < partCount; ++i) {\n                this._partIds.pushBack(live2dcubismframework_1.CubismFramework.getIdManager().getId(partIds[i]));\n            }\n            this._userPartMultiplyColors.prepareCapacity(partCount);\n            this._userPartScreenColors.prepareCapacity(partCount);\n            this._partChildDrawables.prepareCapacity(partCount);\n        }\n        {\n            const drawableIds = this._model.drawables.ids;\n            const drawableCount = this._model.drawables.count;\n            this._userMultiplyColors.prepareCapacity(drawableCount);\n            this._userScreenColors.prepareCapacity(drawableCount);\n            // カリング設定\n            this._userCullings.prepareCapacity(drawableCount);\n            const userCulling = new DrawableCullingData(false, false);\n            // Part\n            {\n                for (let i = 0; i < partCount; ++i) {\n                    const multiplyColor = new cubismrenderer_1.CubismTextureColor(1.0, 1.0, 1.0, 1.0);\n                    const screenColor = new cubismrenderer_1.CubismTextureColor(0.0, 0.0, 0.0, 1.0);\n                    const userMultiplyColor = new PartColorData(false, multiplyColor);\n                    const userScreenColor = new PartColorData(false, screenColor);\n                    this._userPartMultiplyColors.pushBack(userMultiplyColor);\n                    this._userPartScreenColors.pushBack(userScreenColor);\n                    this._partChildDrawables.pushBack(new csmvector_1.csmVector());\n                    this._partChildDrawables.at(i).prepareCapacity(drawableCount);\n                }\n            }\n            // Drawables\n            {\n                for (let i = 0; i < drawableCount; ++i) {\n                    const multiplyColor = new cubismrenderer_1.CubismTextureColor(1.0, 1.0, 1.0, 1.0);\n                    const screenColor = new cubismrenderer_1.CubismTextureColor(0.0, 0.0, 0.0, 1.0);\n                    const userMultiplyColor = new DrawableColorData(false, multiplyColor);\n                    const userScreenColor = new DrawableColorData(false, screenColor);\n                    this._drawableIds.pushBack(live2dcubismframework_1.CubismFramework.getIdManager().getId(drawableIds[i]));\n                    this._userMultiplyColors.pushBack(userMultiplyColor);\n                    this._userScreenColors.pushBack(userScreenColor);\n                    this._userCullings.pushBack(userCulling);\n                    const parentIndex = this.getDrawableParentPartIndex(i);\n                    if (parentIndex >= 0) {\n                        this._partChildDrawables.at(parentIndex).pushBack(i);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * コンストラクタ\n     * @param model モデル\n     */\n    constructor(model) {\n        this._model = model;\n        this._parameterValues = null;\n        this._parameterMaximumValues = null;\n        this._parameterMinimumValues = null;\n        this._partOpacities = null;\n        this._savedParameters = new csmvector_1.csmVector();\n        this._parameterIds = new csmvector_1.csmVector();\n        this._drawableIds = new csmvector_1.csmVector();\n        this._partIds = new csmvector_1.csmVector();\n        this._isOverwrittenModelMultiplyColors = false;\n        this._isOverwrittenModelScreenColors = false;\n        this._isOverwrittenCullings = false;\n        this._modelOpacity = 1.0;\n        this._userMultiplyColors = new csmvector_1.csmVector();\n        this._userScreenColors = new csmvector_1.csmVector();\n        this._userCullings = new csmvector_1.csmVector();\n        this._userPartMultiplyColors = new csmvector_1.csmVector();\n        this._userPartScreenColors = new csmvector_1.csmVector();\n        this._partChildDrawables = new csmvector_1.csmVector();\n        this._notExistPartId = new csmmap_1.csmMap();\n        this._notExistParameterId = new csmmap_1.csmMap();\n        this._notExistParameterValues = new csmmap_1.csmMap();\n        this._notExistPartOpacities = new csmmap_1.csmMap();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        this._model.release();\n        this._model = null;\n    }\n}\nexports.CubismModel = CubismModel;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmodel */ \"./cubism/Framework/src/model/cubismmodel.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModel = $.CubismModel;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/model/cubismmodel.ts?");

/***/ }),

/***/ "./cubism/Framework/src/model/cubismmodeluserdata.ts":
/*!***********************************************************!*\
  !*** ./cubism/Framework/src/model/cubismmodeluserdata.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismModelUserData = exports.CubismModelUserDataNode = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmstring_1 = __webpack_require__(/*! ../type/csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismmodeluserdatajson_1 = __webpack_require__(/*! ./cubismmodeluserdatajson */ \"./cubism/Framework/src/model/cubismmodeluserdatajson.ts\");\nconst ArtMesh = 'ArtMesh';\n/**\n * ユーザーデータインターフェース\n *\n * Jsonから読み込んだユーザーデータを記録しておくための構造体\n */\nclass CubismModelUserDataNode {\n}\nexports.CubismModelUserDataNode = CubismModelUserDataNode;\n/**\n * ユーザデータの管理クラス\n *\n * ユーザデータをロード、管理、検索インターフェイス、解放までを行う。\n */\nclass CubismModelUserData {\n    /**\n     * インスタンスの作成\n     *\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    static create(buffer, size) {\n        const ret = new CubismModelUserData();\n        ret.parseUserData(buffer, size);\n        return ret;\n    }\n    /**\n     * インスタンスを破棄する\n     *\n     * @param modelUserData 破棄するインスタンス\n     */\n    static delete(modelUserData) {\n        if (modelUserData != null) {\n            modelUserData.release();\n            modelUserData = null;\n        }\n    }\n    /**\n     * ArtMeshのユーザーデータのリストの取得\n     *\n     * @return ユーザーデータリスト\n     */\n    getArtMeshUserDatas() {\n        return this._artMeshUserDataNode;\n    }\n    /**\n     * userdata3.jsonのパース\n     *\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     */\n    parseUserData(buffer, size) {\n        let json = new cubismmodeluserdatajson_1.CubismModelUserDataJson(buffer, size);\n        const typeOfArtMesh = live2dcubismframework_1.CubismFramework.getIdManager().getId(ArtMesh);\n        const nodeCount = json.getUserDataCount();\n        for (let i = 0; i < nodeCount; i++) {\n            const addNode = new CubismModelUserDataNode();\n            addNode.targetId = json.getUserDataId(i);\n            addNode.targetType = live2dcubismframework_1.CubismFramework.getIdManager().getId(json.getUserDataTargetType(i));\n            addNode.value = new csmstring_1.csmString(json.getUserDataValue(i));\n            this._userDataNodes.pushBack(addNode);\n            if (addNode.targetType == typeOfArtMesh) {\n                this._artMeshUserDataNode.pushBack(addNode);\n            }\n        }\n        json.release();\n        json = void 0;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._userDataNodes = new csmvector_1.csmVector();\n        this._artMeshUserDataNode = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     *\n     * ユーザーデータ構造体配列を解放する\n     */\n    release() {\n        for (let i = 0; i < this._userDataNodes.getSize(); ++i) {\n            this._userDataNodes.set(i, null);\n        }\n        this._userDataNodes = null;\n    }\n}\nexports.CubismModelUserData = CubismModelUserData;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmodeluserdata */ \"./cubism/Framework/src/model/cubismmodeluserdata.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelUserData = $.CubismModelUserData;\n    Live2DCubismFramework.CubismModelUserDataNode = $.CubismModelUserDataNode;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/model/cubismmodeluserdata.ts?");

/***/ }),

/***/ "./cubism/Framework/src/model/cubismmodeluserdatajson.ts":
/*!***************************************************************!*\
  !*** ./cubism/Framework/src/model/cubismmodeluserdatajson.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismModelUserDataJson = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ../utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\nconst Meta = 'Meta';\nconst UserDataCount = 'UserDataCount';\nconst TotalUserDataSize = 'TotalUserDataSize';\nconst UserData = 'UserData';\nconst Target = 'Target';\nconst Id = 'Id';\nconst Value = 'Value';\nclass CubismModelUserDataJson {\n    /**\n     * コンストラクタ\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     */\n    constructor(buffer, size) {\n        this._json = cubismjson_1.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        cubismjson_1.CubismJson.delete(this._json);\n    }\n    /**\n     * ユーザーデータ個数の取得\n     * @return ユーザーデータの個数\n     */\n    getUserDataCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(UserDataCount)\n            .toInt();\n    }\n    /**\n     * ユーザーデータ総文字列数の取得\n     *\n     * @return ユーザーデータ総文字列数\n     */\n    getTotalUserDataSize() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalUserDataSize)\n            .toInt();\n    }\n    /**\n     * ユーザーデータのタイプの取得\n     *\n     * @return ユーザーデータのタイプ\n     */\n    getUserDataTargetType(i) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Target)\n            .getRawString();\n    }\n    /**\n     * ユーザーデータのターゲットIDの取得\n     *\n     * @param i インデックス\n     * @return ユーザーデータターゲットID\n     */\n    getUserDataId(i) {\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Id)\n            .getRawString());\n    }\n    /**\n     * ユーザーデータの文字列の取得\n     *\n     * @param i インデックス\n     * @return ユーザーデータ\n     */\n    getUserDataValue(i) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Value)\n            .getRawString();\n    }\n}\nexports.CubismModelUserDataJson = CubismModelUserDataJson;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmodeluserdatajson */ \"./cubism/Framework/src/model/cubismmodeluserdatajson.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelUserDataJson = $.CubismModelUserDataJson;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/model/cubismmodeluserdatajson.ts?");

/***/ }),

/***/ "./cubism/Framework/src/model/cubismusermodel.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/model/cubismusermodel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismUserModel = void 0;\nconst cubismbreath_1 = __webpack_require__(/*! ../effect/cubismbreath */ \"./cubism/Framework/src/effect/cubismbreath.ts\");\nconst cubismeyeblink_1 = __webpack_require__(/*! ../effect/cubismeyeblink */ \"./cubism/Framework/src/effect/cubismeyeblink.ts\");\nconst cubismpose_1 = __webpack_require__(/*! ../effect/cubismpose */ \"./cubism/Framework/src/effect/cubismpose.ts\");\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismmodelmatrix_1 = __webpack_require__(/*! ../math/cubismmodelmatrix */ \"./cubism/Framework/src/math/cubismmodelmatrix.ts\");\nconst cubismtargetpoint_1 = __webpack_require__(/*! ../math/cubismtargetpoint */ \"./cubism/Framework/src/math/cubismtargetpoint.ts\");\nconst cubismexpressionmotion_1 = __webpack_require__(/*! ../motion/cubismexpressionmotion */ \"./cubism/Framework/src/motion/cubismexpressionmotion.ts\");\nconst cubismmotion_1 = __webpack_require__(/*! ../motion/cubismmotion */ \"./cubism/Framework/src/motion/cubismmotion.ts\");\nconst cubismmotionmanager_1 = __webpack_require__(/*! ../motion/cubismmotionmanager */ \"./cubism/Framework/src/motion/cubismmotionmanager.ts\");\nconst cubismphysics_1 = __webpack_require__(/*! ../physics/cubismphysics */ \"./cubism/Framework/src/physics/cubismphysics.ts\");\nconst cubismrenderer_webgl_1 = __webpack_require__(/*! ../rendering/cubismrenderer_webgl */ \"./cubism/Framework/src/rendering/cubismrenderer_webgl.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst cubismmoc_1 = __webpack_require__(/*! ./cubismmoc */ \"./cubism/Framework/src/model/cubismmoc.ts\");\nconst cubismmodeluserdata_1 = __webpack_require__(/*! ./cubismmodeluserdata */ \"./cubism/Framework/src/model/cubismmodeluserdata.ts\");\n/**\n * ユーザーが実際に使用するモデル\n *\n * ユーザーが実際に使用するモデルの基底クラス。これを継承してユーザーが実装する。\n */\nclass CubismUserModel {\n    /**\n     * 初期化状態の取得\n     *\n     * 初期化されている状態か？\n     *\n     * @return true     初期化されている\n     * @return false    初期化されていない\n     */\n    isInitialized() {\n        return this._initialized;\n    }\n    /**\n     * 初期化状態の設定\n     *\n     * 初期化状態を設定する。\n     *\n     * @param v 初期化状態\n     */\n    setInitialized(v) {\n        this._initialized = v;\n    }\n    /**\n     * 更新状態の取得\n     *\n     * 更新されている状態か？\n     *\n     * @return true     更新されている\n     * @return false    更新されていない\n     */\n    isUpdating() {\n        return this._updating;\n    }\n    /**\n     * 更新状態の設定\n     *\n     * 更新状態を設定する\n     *\n     * @param v 更新状態\n     */\n    setUpdating(v) {\n        this._updating = v;\n    }\n    /**\n     * マウスドラッグ情報の設定\n     * @param ドラッグしているカーソルのX位置\n     * @param ドラッグしているカーソルのY位置\n     */\n    setDragging(x, y) {\n        this._dragManager.set(x, y);\n    }\n    /**\n     * 加速度の情報を設定する\n     * @param x X軸方向の加速度\n     * @param y Y軸方向の加速度\n     * @param z Z軸方向の加速度\n     */\n    setAcceleration(x, y, z) {\n        this._accelerationX = x;\n        this._accelerationY = y;\n        this._accelerationZ = z;\n    }\n    /**\n     * モデル行列を取得する\n     * @return モデル行列\n     */\n    getModelMatrix() {\n        return this._modelMatrix;\n    }\n    /**\n     * 不透明度の設定\n     * @param a 不透明度\n     */\n    setOpacity(a) {\n        this._opacity = a;\n    }\n    /**\n     * 不透明度の取得\n     * @return 不透明度\n     */\n    getOpacity() {\n        return this._opacity;\n    }\n    /**\n     * モデルデータを読み込む\n     *\n     * @param buffer    moc3ファイルが読み込まれているバッファ\n     */\n    loadModel(buffer, shouldCheckMocConsistency = false) {\n        this._moc = cubismmoc_1.CubismMoc.create(buffer, shouldCheckMocConsistency);\n        if (this._moc == null) {\n            (0, cubismdebug_1.CubismLogError)('Failed to CubismMoc.create().');\n            return;\n        }\n        this._model = this._moc.createModel();\n        if (this._model == null) {\n            (0, cubismdebug_1.CubismLogError)('Failed to CreateModel().');\n            return;\n        }\n        this._model.saveParameters();\n        this._modelMatrix = new cubismmodelmatrix_1.CubismModelMatrix(this._model.getCanvasWidth(), this._model.getCanvasHeight());\n    }\n    /**\n     * 表情データの読み込み\n     * @param buffer expファイルが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @param name 表情の名前\n     */\n    loadExpression(buffer, size, name) {\n        return cubismexpressionmotion_1.CubismExpressionMotion.create(buffer, size);\n    }\n    /**\n     * ポーズデータの読み込み\n     * @param buffer pose3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    loadPose(buffer, size) {\n        this._pose = cubismpose_1.CubismPose.create(buffer, size);\n    }\n    /**\n     * モデルに付属するユーザーデータを読み込む\n     * @param buffer userdata3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    loadUserData(buffer, size) {\n        this._modelUserData = cubismmodeluserdata_1.CubismModelUserData.create(buffer, size);\n    }\n    /**\n     * 物理演算データの読み込み\n     * @param buffer  physics3.jsonが読み込まれているバッファ\n     * @param size    バッファのサイズ\n     */\n    loadPhysics(buffer, size) {\n        this._physics = cubismphysics_1.CubismPhysics.create(buffer, size);\n    }\n    /**\n     * 当たり判定の取得\n     * @param drawableId 検証したいDrawableのID\n     * @param pointX X位置\n     * @param pointY Y位置\n     * @return true ヒットしている\n     * @return false ヒットしていない\n     */\n    isHit(drawableId, pointX, pointY) {\n        const drawIndex = this._model.getDrawableIndex(drawableId);\n        if (drawIndex < 0) {\n            return false; // 存在しない場合はfalse\n        }\n        const count = this._model.getDrawableVertexCount(drawIndex);\n        const vertices = this._model.getDrawableVertices(drawIndex);\n        let left = vertices[0];\n        let right = vertices[0];\n        let top = vertices[1];\n        let bottom = vertices[1];\n        for (let j = 1; j < count; ++j) {\n            const x = vertices[live2dcubismframework_1.Constant.vertexOffset + j * live2dcubismframework_1.Constant.vertexStep];\n            const y = vertices[live2dcubismframework_1.Constant.vertexOffset + j * live2dcubismframework_1.Constant.vertexStep + 1];\n            if (x < left) {\n                left = x; // Min x\n            }\n            if (x > right) {\n                right = x; // Max x\n            }\n            if (y < top) {\n                top = y; // Min y\n            }\n            if (y > bottom) {\n                bottom = y; // Max y\n            }\n        }\n        const tx = this._modelMatrix.invertTransformX(pointX);\n        const ty = this._modelMatrix.invertTransformY(pointY);\n        return left <= tx && tx <= right && top <= ty && ty <= bottom;\n    }\n    /**\n     * モデルの取得\n     * @return モデル\n     */\n    getModel() {\n        return this._model;\n    }\n    /**\n     * レンダラの取得\n     * @return レンダラ\n     */\n    getRenderer() {\n        return this._renderer;\n    }\n    /**\n     * レンダラを作成して初期化を実行する\n     * @param maskBufferCount バッファの生成数\n     */\n    createRenderer(maskBufferCount = 1) {\n        if (this._renderer) {\n            this.deleteRenderer();\n        }\n        this._renderer = new cubismrenderer_webgl_1.CubismRenderer_WebGL();\n        this._renderer.initialize(this._model, maskBufferCount);\n    }\n    /**\n     * レンダラの解放\n     */\n    deleteRenderer() {\n        if (this._renderer != null) {\n            this._renderer.release();\n            this._renderer = null;\n        }\n    }\n    /**\n     * イベント発火時の標準処理\n     *\n     * Eventが再生処理時にあった場合の処理をする。\n     * 継承で上書きすることを想定している。\n     * 上書きしない場合はログ出力をする。\n     *\n     * @param eventValue 発火したイベントの文字列データ\n     */\n    motionEventFired(eventValue) {\n        (0, cubismdebug_1.CubismLogInfo)('{0}', eventValue.s);\n    }\n    /**\n     * イベント用のコールバック\n     *\n     * CubismMotionQueueManagerにイベント用に登録するためのCallback。\n     * CubismUserModelの継承先のEventFiredを呼ぶ。\n     *\n     * @param caller 発火したイベントを管理していたモーションマネージャー、比較用\n     * @param eventValue 発火したイベントの文字列データ\n     * @param customData CubismUserModelを継承したインスタンスを想定\n     */\n    static cubismDefaultMotionEventCallback(caller, eventValue, customData) {\n        const model = customData;\n        if (model != null) {\n            model.motionEventFired(eventValue);\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        /**\n         * モーションデータを読み込む\n         * @param buffer motion3.jsonファイルが読み込まれているバッファ\n         * @param size バッファのサイズ\n         * @param name モーションの名前\n         * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n         * @return モーションクラス\n         */\n        this.loadMotion = (buffer, size, name, onFinishedMotionHandler) => cubismmotion_1.CubismMotion.create(buffer, size, onFinishedMotionHandler);\n        // 各変数初期化\n        this._moc = null;\n        this._model = null;\n        this._motionManager = null;\n        this._expressionManager = null;\n        this._eyeBlink = null;\n        this._breath = null;\n        this._modelMatrix = null;\n        this._pose = null;\n        this._dragManager = null;\n        this._physics = null;\n        this._modelUserData = null;\n        this._initialized = false;\n        this._updating = false;\n        this._opacity = 1.0;\n        this._lipsync = true;\n        this._lastLipSyncValue = 0.0;\n        this._dragX = 0.0;\n        this._dragY = 0.0;\n        this._accelerationX = 0.0;\n        this._accelerationY = 0.0;\n        this._accelerationZ = 0.0;\n        this._mocConsistency = false;\n        this._debugMode = false;\n        this._renderer = null;\n        // モーションマネージャーを作成\n        this._motionManager = new cubismmotionmanager_1.CubismMotionManager();\n        this._motionManager.setEventCallback(CubismUserModel.cubismDefaultMotionEventCallback, this);\n        // 表情マネージャーを作成\n        this._expressionManager = new cubismmotionmanager_1.CubismMotionManager();\n        // ドラッグによるアニメーション\n        this._dragManager = new cubismtargetpoint_1.CubismTargetPoint();\n    }\n    /**\n     * デストラクタに相当する処理\n     */\n    release() {\n        if (this._motionManager != null) {\n            this._motionManager.release();\n            this._motionManager = null;\n        }\n        if (this._expressionManager != null) {\n            this._expressionManager.release();\n            this._expressionManager = null;\n        }\n        if (this._moc != null) {\n            this._moc.deleteModel(this._model);\n            this._moc.release();\n            this._moc = null;\n        }\n        this._modelMatrix = null;\n        cubismpose_1.CubismPose.delete(this._pose);\n        cubismeyeblink_1.CubismEyeBlink.delete(this._eyeBlink);\n        cubismbreath_1.CubismBreath.delete(this._breath);\n        this._dragManager = null;\n        cubismphysics_1.CubismPhysics.delete(this._physics);\n        cubismmodeluserdata_1.CubismModelUserData.delete(this._modelUserData);\n        this.deleteRenderer();\n    }\n}\nexports.CubismUserModel = CubismUserModel;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismusermodel */ \"./cubism/Framework/src/model/cubismusermodel.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismUserModel = $.CubismUserModel;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/model/cubismusermodel.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/acubismmotion.ts":
/*!******************************************************!*\
  !*** ./cubism/Framework/src/motion/acubismmotion.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.ACubismMotion = void 0;\nconst cubismmath_1 = __webpack_require__(/*! ../math/cubismmath */ \"./cubism/Framework/src/math/cubismmath.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\n/**\n * モーションの抽象基底クラス\n *\n * モーションの抽象基底クラス。MotionQueueManagerによってモーションの再生を管理する。\n */\nclass ACubismMotion {\n    /**\n     * インスタンスの破棄\n     */\n    static delete(motion) {\n        motion.release();\n        motion = null;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        /**\n         * モーション再生終了コールバックの登録\n         *\n         * モーション再生終了コールバックを登録する。\n         * isFinishedフラグを設定するタイミングで呼び出される。\n         * 以下の状態の際には呼び出されない:\n         *   1. 再生中のモーションが「ループ」として設定されているとき\n         *   2. コールバックが登録されていない時\n         *\n         * @param onFinishedMotionHandler モーション再生終了コールバック関数\n         */\n        this.setFinishedMotionHandler = (onFinishedMotionHandler) => (this._onFinishedMotion = onFinishedMotionHandler);\n        /**\n         * モーション再生終了コールバックの取得\n         *\n         * モーション再生終了コールバックを取得する。\n         *\n         * @return 登録されているモーション再生終了コールバック関数\n         */\n        this.getFinishedMotionHandler = () => this._onFinishedMotion;\n        this._fadeInSeconds = -1.0;\n        this._fadeOutSeconds = -1.0;\n        this._weight = 1.0;\n        this._offsetSeconds = 0.0; // 再生の開始時刻\n        this._firedEventValues = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        this._weight = 0.0;\n    }\n    /**\n     * モデルのパラメータ\n     * @param model 対象のモデル\n     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     */\n    updateParameters(model, motionQueueEntry, userTimeSeconds) {\n        if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {\n            return;\n        }\n        if (!motionQueueEntry.isStarted()) {\n            motionQueueEntry.setIsStarted(true);\n            motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds); // モーションの開始時刻を記録\n            motionQueueEntry.setFadeInStartTime(userTimeSeconds); // フェードインの開始時刻\n            const duration = this.getDuration();\n            if (motionQueueEntry.getEndTime() < 0) {\n                // 開始していないうちに終了設定している場合がある。\n                motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);\n                // duration == -1 の場合はループする\n            }\n        }\n        let fadeWeight = this._weight; // 現在の値と掛け合わせる割合\n        //---- フェードイン・アウトの処理 ----\n        // 単純なサイン関数でイージングする\n        const fadeIn = this._fadeInSeconds == 0.0\n            ? 1.0\n            : cubismmath_1.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                this._fadeInSeconds);\n        const fadeOut = this._fadeOutSeconds == 0.0 || motionQueueEntry.getEndTime() < 0.0\n            ? 1.0\n            : cubismmath_1.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                this._fadeOutSeconds);\n        fadeWeight = fadeWeight * fadeIn * fadeOut;\n        motionQueueEntry.setState(userTimeSeconds, fadeWeight);\n        (0, cubismdebug_1.CSM_ASSERT)(0.0 <= fadeWeight && fadeWeight <= 1.0);\n        //---- 全てのパラメータIDをループする ----\n        this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);\n        // 後処理\n        // 終了時刻を過ぎたら終了フラグを立てる(CubismMotionQueueManager)\n        if (motionQueueEntry.getEndTime() > 0 &&\n            motionQueueEntry.getEndTime() < userTimeSeconds) {\n            motionQueueEntry.setIsFinished(true); // 終了\n        }\n    }\n    /**\n     * フェードインの時間を設定する\n     * @param fadeInSeconds フェードインにかかる時間[秒]\n     */\n    setFadeInTime(fadeInSeconds) {\n        this._fadeInSeconds = fadeInSeconds;\n    }\n    /**\n     * フェードアウトの時間を設定する\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     */\n    setFadeOutTime(fadeOutSeconds) {\n        this._fadeOutSeconds = fadeOutSeconds;\n    }\n    /**\n     * フェードアウトにかかる時間の取得\n     * @return フェードアウトにかかる時間[秒]\n     */\n    getFadeOutTime() {\n        return this._fadeOutSeconds;\n    }\n    /**\n     * フェードインにかかる時間の取得\n     * @return フェードインにかかる時間[秒]\n     */\n    getFadeInTime() {\n        return this._fadeInSeconds;\n    }\n    /**\n     * モーション適用の重みの設定\n     * @param weight 重み（0.0 - 1.0）\n     */\n    setWeight(weight) {\n        this._weight = weight;\n    }\n    /**\n     * モーション適用の重みの取得\n     * @return 重み（0.0 - 1.0）\n     */\n    getWeight() {\n        return this._weight;\n    }\n    /**\n     * モーションの長さの取得\n     * @return モーションの長さ[秒]\n     *\n     * @note ループの時は「-1」。\n     *       ループでない場合は、オーバーライドする。\n     *       正の値の時は取得される時間で終了する。\n     *       「-1」の時は外部から停止命令がない限り終わらない処理となる。\n     */\n    getDuration() {\n        return -1.0;\n    }\n    /**\n     * モーションのループ1回分の長さの取得\n     * @return モーションのループ一回分の長さ[秒]\n     *\n     * @note ループしない場合は、getDuration()と同じ値を返す\n     *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す\n     */\n    getLoopDuration() {\n        return -1.0;\n    }\n    /**\n     * モーション再生の開始時刻の設定\n     * @param offsetSeconds モーション再生の開始時刻[秒]\n     */\n    setOffsetTime(offsetSeconds) {\n        this._offsetSeconds = offsetSeconds;\n    }\n    /**\n     * モデルのパラメータ更新\n     *\n     * イベント発火のチェック。\n     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n     *\n     * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]\n     * @param motionTimeSeconds 今回の再生時間[秒]\n     */\n    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {\n        return this._firedEventValues;\n    }\n    /**\n     * 透明度のカーブが存在するかどうかを確認する\n     *\n     * @returns true  -> キーが存在する\n     *          false -> キーが存在しない\n     */\n    isExistModelOpacity() {\n        return false;\n    }\n    /**\n     * 透明度のカーブのインデックスを返す\n     *\n     * @returns success:透明度のカーブのインデックス\n     */\n    getModelOpacityIndex() {\n        return -1;\n    }\n    /**\n     * 透明度のIdを返す\n     *\n     * @param index モーションカーブのインデックス\n     * @returns success:透明度のId\n     */\n    getModelOpacityId(index) {\n        return null;\n    }\n    /**\n     * 指定時間の透明度の値を返す\n     *\n     * @returns success:モーションの現在時間におけるOpacityの値\n     *\n     * @note  更新後の値を取るにはUpdateParameters() の後に呼び出す。\n     */\n    getModelOpacityValue() {\n        return 1.0;\n    }\n}\nexports.ACubismMotion = ACubismMotion;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./acubismmotion */ \"./cubism/Framework/src/motion/acubismmotion.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.ACubismMotion = $.ACubismMotion;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/acubismmotion.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismexpressionmotion.ts":
/*!***************************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismexpressionmotion.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.ExpressionParameter = exports.ExpressionBlendType = exports.CubismExpressionMotion = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ../utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\nconst acubismmotion_1 = __webpack_require__(/*! ./acubismmotion */ \"./cubism/Framework/src/motion/acubismmotion.ts\");\n// exp3.jsonのキーとデフォルト\nconst ExpressionKeyFadeIn = 'FadeInTime';\nconst ExpressionKeyFadeOut = 'FadeOutTime';\nconst ExpressionKeyParameters = 'Parameters';\nconst ExpressionKeyId = 'Id';\nconst ExpressionKeyValue = 'Value';\nconst ExpressionKeyBlend = 'Blend';\nconst BlendValueAdd = 'Add';\nconst BlendValueMultiply = 'Multiply';\nconst BlendValueOverwrite = 'Overwrite';\nconst DefaultFadeTime = 1.0;\n/**\n * 表情のモーション\n *\n * 表情のモーションクラス。\n */\nclass CubismExpressionMotion extends acubismmotion_1.ACubismMotion {\n    /**\n     * インスタンスを作成する。\n     * @param buffer expファイルが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    static create(buffer, size) {\n        const expression = new CubismExpressionMotion();\n        expression.parse(buffer, size);\n        return expression;\n    }\n    /**\n     * モデルのパラメータの更新の実行\n     * @param model 対象のモデル\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     * @param weight モーションの重み\n     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション\n     */\n    doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {\n        for (let i = 0; i < this._parameters.getSize(); ++i) {\n            const parameter = this._parameters.at(i);\n            switch (parameter.blendType) {\n                case ExpressionBlendType.ExpressionBlendType_Add: {\n                    model.addParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                case ExpressionBlendType.ExpressionBlendType_Multiply: {\n                    model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                case ExpressionBlendType.ExpressionBlendType_Overwrite: {\n                    model.setParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                default:\n                    // 仕様にない値を設定した時はすでに加算モードになっている\n                    break;\n            }\n        }\n    }\n    parse(buffer, size) {\n        const json = cubismjson_1.CubismJson.create(buffer, size);\n        const root = json.getRoot();\n        this.setFadeInTime(root.getValueByString(ExpressionKeyFadeIn).toFloat(DefaultFadeTime)); // フェードイン\n        this.setFadeOutTime(root.getValueByString(ExpressionKeyFadeOut).toFloat(DefaultFadeTime)); // フェードアウト\n        // 各パラメータについて\n        const parameterCount = root\n            .getValueByString(ExpressionKeyParameters)\n            .getSize();\n        this._parameters.prepareCapacity(parameterCount);\n        for (let i = 0; i < parameterCount; ++i) {\n            const param = root\n                .getValueByString(ExpressionKeyParameters)\n                .getValueByIndex(i);\n            const parameterId = live2dcubismframework_1.CubismFramework.getIdManager().getId(param.getValueByString(ExpressionKeyId).getRawString()); // パラメータID\n            const value = param\n                .getValueByString(ExpressionKeyValue)\n                .toFloat(); // 値\n            // 計算方法の設定\n            let blendType;\n            if (param.getValueByString(ExpressionKeyBlend).isNull() ||\n                param.getValueByString(ExpressionKeyBlend).getString() == BlendValueAdd) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Add;\n            }\n            else if (param.getValueByString(ExpressionKeyBlend).getString() ==\n                BlendValueMultiply) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Multiply;\n            }\n            else if (param.getValueByString(ExpressionKeyBlend).getString() ==\n                BlendValueOverwrite) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Overwrite;\n            }\n            else {\n                // その他 仕様にない値を設定した時は加算モードにすることで復旧\n                blendType = ExpressionBlendType.ExpressionBlendType_Add;\n            }\n            // 設定オブジェクトを作成してリストに追加する\n            const item = new ExpressionParameter();\n            item.parameterId = parameterId;\n            item.blendType = blendType;\n            item.value = value;\n            this._parameters.pushBack(item);\n        }\n        cubismjson_1.CubismJson.delete(json); // JSONデータは不要になったら削除する\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._parameters = new csmvector_1.csmVector();\n    }\n}\nexports.CubismExpressionMotion = CubismExpressionMotion;\n/**\n * 表情パラメータ値の計算方式\n */\nvar ExpressionBlendType;\n(function (ExpressionBlendType) {\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Add\"] = 0] = \"ExpressionBlendType_Add\";\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Multiply\"] = 1] = \"ExpressionBlendType_Multiply\";\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Overwrite\"] = 2] = \"ExpressionBlendType_Overwrite\";\n})(ExpressionBlendType || (exports.ExpressionBlendType = ExpressionBlendType = {}));\n/**\n * 表情のパラメータ情報\n */\nclass ExpressionParameter {\n}\nexports.ExpressionParameter = ExpressionParameter;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismexpressionmotion */ \"./cubism/Framework/src/motion/cubismexpressionmotion.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismExpressionMotion = $.CubismExpressionMotion;\n    Live2DCubismFramework.ExpressionBlendType = $.ExpressionBlendType;\n    Live2DCubismFramework.ExpressionParameter = $.ExpressionParameter;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismexpressionmotion.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotion.ts":
/*!*****************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotion.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMotion = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismmath_1 = __webpack_require__(/*! ../math/cubismmath */ \"./cubism/Framework/src/math/cubismmath.ts\");\nconst csmstring_1 = __webpack_require__(/*! ../type/csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst acubismmotion_1 = __webpack_require__(/*! ./acubismmotion */ \"./cubism/Framework/src/motion/acubismmotion.ts\");\nconst cubismmotioninternal_1 = __webpack_require__(/*! ./cubismmotioninternal */ \"./cubism/Framework/src/motion/cubismmotioninternal.ts\");\nconst cubismmotionjson_1 = __webpack_require__(/*! ./cubismmotionjson */ \"./cubism/Framework/src/motion/cubismmotionjson.ts\");\nconst EffectNameEyeBlink = 'EyeBlink';\nconst EffectNameLipSync = 'LipSync';\nconst TargetNameModel = 'Model';\nconst TargetNameParameter = 'Parameter';\nconst TargetNamePartOpacity = 'PartOpacity';\n// Id\nconst IdNameOpacity = 'Opacity';\n/**\n * Cubism SDK R2 以前のモーションを再現させるなら true 、アニメータのモーションを正しく再現するなら false 。\n */\nconst UseOldBeziersCurveMotion = false;\nfunction lerpPoints(a, b, t) {\n    const result = new cubismmotioninternal_1.CubismMotionPoint();\n    result.time = a.time + (b.time - a.time) * t;\n    result.value = a.value + (b.value - a.value) * t;\n    return result;\n}\nfunction linearEvaluate(points, time) {\n    let t = (time - points[0].time) / (points[1].time - points[0].time);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    return points[0].value + (points[1].value - points[0].value) * t;\n}\nfunction bezierEvaluate(points, time) {\n    let t = (time - points[0].time) / (points[3].time - points[0].time);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    const p01 = lerpPoints(points[0], points[1], t);\n    const p12 = lerpPoints(points[1], points[2], t);\n    const p23 = lerpPoints(points[2], points[3], t);\n    const p012 = lerpPoints(p01, p12, t);\n    const p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateBinarySearch(points, time) {\n    const x_error = 0.01;\n    const x = time;\n    let x1 = points[0].time;\n    let x2 = points[3].time;\n    let cx1 = points[1].time;\n    let cx2 = points[2].time;\n    let ta = 0.0;\n    let tb = 1.0;\n    let t = 0.0;\n    let i = 0;\n    for (let var33 = true; i < 20; ++i) {\n        if (x < x1 + x_error) {\n            t = ta;\n            break;\n        }\n        if (x2 - x_error < x) {\n            t = tb;\n            break;\n        }\n        let centerx = (cx1 + cx2) * 0.5;\n        cx1 = (x1 + cx1) * 0.5;\n        cx2 = (x2 + cx2) * 0.5;\n        const ctrlx12 = (cx1 + centerx) * 0.5;\n        const ctrlx21 = (cx2 + centerx) * 0.5;\n        centerx = (ctrlx12 + ctrlx21) * 0.5;\n        if (x < centerx) {\n            tb = (ta + tb) * 0.5;\n            if (centerx - x_error < x) {\n                t = tb;\n                break;\n            }\n            x2 = centerx;\n            cx2 = ctrlx12;\n        }\n        else {\n            ta = (ta + tb) * 0.5;\n            if (x < centerx + x_error) {\n                t = ta;\n                break;\n            }\n            x1 = centerx;\n            cx1 = ctrlx21;\n        }\n    }\n    if (i == 20) {\n        t = (ta + tb) * 0.5;\n    }\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    if (t > 1.0) {\n        t = 1.0;\n    }\n    const p01 = lerpPoints(points[0], points[1], t);\n    const p12 = lerpPoints(points[1], points[2], t);\n    const p23 = lerpPoints(points[2], points[3], t);\n    const p012 = lerpPoints(p01, p12, t);\n    const p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateCardanoInterpretation(points, time) {\n    const x = time;\n    const x1 = points[0].time;\n    const x2 = points[3].time;\n    const cx1 = points[1].time;\n    const cx2 = points[2].time;\n    const a = x2 - 3.0 * cx2 + 3.0 * cx1 - x1;\n    const b = 3.0 * cx2 - 6.0 * cx1 + 3.0 * x1;\n    const c = 3.0 * cx1 - 3.0 * x1;\n    const d = x1 - x;\n    const t = cubismmath_1.CubismMath.cardanoAlgorithmForBezier(a, b, c, d);\n    const p01 = lerpPoints(points[0], points[1], t);\n    const p12 = lerpPoints(points[1], points[2], t);\n    const p23 = lerpPoints(points[2], points[3], t);\n    const p012 = lerpPoints(p01, p12, t);\n    const p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction steppedEvaluate(points, time) {\n    return points[0].value;\n}\nfunction inverseSteppedEvaluate(points, time) {\n    return points[1].value;\n}\nfunction evaluateCurve(motionData, index, time) {\n    // Find segment to evaluate.\n    const curve = motionData.curves.at(index);\n    let target = -1;\n    const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;\n    let pointPosition = 0;\n    for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {\n        // Get first point of next segment.\n        pointPosition =\n            motionData.segments.at(i).basePointIndex +\n                (motionData.segments.at(i).segmentType ==\n                    cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Bezier\n                    ? 3\n                    : 1);\n        // Break if time lies within current segment.\n        if (motionData.points.at(pointPosition).time > time) {\n            target = i;\n            break;\n        }\n    }\n    if (target == -1) {\n        return motionData.points.at(pointPosition).value;\n    }\n    const segment = motionData.segments.at(target);\n    return segment.evaluate(motionData.points.get(segment.basePointIndex), time);\n}\n/**\n * モーションクラス\n *\n * モーションのクラス。\n */\nclass CubismMotion extends acubismmotion_1.ACubismMotion {\n    /**\n     * インスタンスを作成する\n     *\n     * @param buffer motion3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n     * @return 作成されたインスタンス\n     */\n    static create(buffer, size, onFinishedMotionHandler) {\n        const ret = new CubismMotion();\n        ret.parse(buffer, size);\n        ret._sourceFrameRate = ret._motionData.fps;\n        ret._loopDurationSeconds = ret._motionData.duration;\n        ret._onFinishedMotion = onFinishedMotionHandler;\n        // NOTE: Editorではループありのモーション書き出しは非対応\n        // ret->_loop = (ret->_motionData->Loop > 0);\n        return ret;\n    }\n    /**\n     * モデルのパラメータの更新の実行\n     * @param model             対象のモデル\n     * @param userTimeSeconds   現在の時刻[秒]\n     * @param fadeWeight        モーションの重み\n     * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション\n     */\n    doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {\n        if (this._modelCurveIdEyeBlink == null) {\n            this._modelCurveIdEyeBlink =\n                live2dcubismframework_1.CubismFramework.getIdManager().getId(EffectNameEyeBlink);\n        }\n        if (this._modelCurveIdLipSync == null) {\n            this._modelCurveIdLipSync =\n                live2dcubismframework_1.CubismFramework.getIdManager().getId(EffectNameLipSync);\n        }\n        if (this._modelCurveIdOpacity == null) {\n            this._modelCurveIdOpacity =\n                live2dcubismframework_1.CubismFramework.getIdManager().getId(IdNameOpacity);\n        }\n        let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();\n        if (timeOffsetSeconds < 0.0) {\n            timeOffsetSeconds = 0.0; // エラー回避\n        }\n        let lipSyncValue = Number.MAX_VALUE;\n        let eyeBlinkValue = Number.MAX_VALUE;\n        //まばたき、リップシンクのうちモーションの適用を検出するためのビット（maxFlagCount個まで\n        const MaxTargetSize = 64;\n        let lipSyncFlags = 0;\n        let eyeBlinkFlags = 0;\n        //瞬き、リップシンクのターゲット数が上限を超えている場合\n        if (this._eyeBlinkParameterIds.getSize() > MaxTargetSize) {\n            (0, cubismdebug_1.CubismLogDebug)('too many eye blink targets : {0}', this._eyeBlinkParameterIds.getSize());\n        }\n        if (this._lipSyncParameterIds.getSize() > MaxTargetSize) {\n            (0, cubismdebug_1.CubismLogDebug)('too many lip sync targets : {0}', this._lipSyncParameterIds.getSize());\n        }\n        const tmpFadeIn = this._fadeInSeconds <= 0.0\n            ? 1.0\n            : cubismmath_1.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                this._fadeInSeconds);\n        const tmpFadeOut = this._fadeOutSeconds <= 0.0 || motionQueueEntry.getEndTime() < 0.0\n            ? 1.0\n            : cubismmath_1.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                this._fadeOutSeconds);\n        let value;\n        let c, parameterIndex;\n        // 'Repeat' time as necessary.\n        let time = timeOffsetSeconds;\n        if (this._isLoop) {\n            while (time > this._motionData.duration) {\n                time -= this._motionData.duration;\n            }\n        }\n        const curves = this._motionData.curves;\n        // Evaluate model curves.\n        for (c = 0; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {\n            // Evaluate curve and call handler.\n            value = evaluateCurve(this._motionData, c, time);\n            if (curves.at(c).id == this._modelCurveIdEyeBlink) {\n                eyeBlinkValue = value;\n            }\n            else if (curves.at(c).id == this._modelCurveIdLipSync) {\n                lipSyncValue = value;\n            }\n            else if (curves.at(c).id == this._modelCurveIdOpacity) {\n                this._modelOpacity = value;\n                model.setModelOapcity(this.getModelOpacityValue());\n            }\n        }\n        let parameterMotionCurveCount = 0;\n        for (; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {\n            parameterMotionCurveCount++;\n            // Find parameter index.\n            parameterIndex = model.getParameterIndex(curves.at(c).id);\n            // Skip curve evaluation if no value in sink.\n            if (parameterIndex == -1) {\n                continue;\n            }\n            const sourceValue = model.getParameterValueByIndex(parameterIndex);\n            // Evaluate curve and apply value.\n            value = evaluateCurve(this._motionData, c, time);\n            if (eyeBlinkValue != Number.MAX_VALUE) {\n                for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {\n                        value *= eyeBlinkValue;\n                        eyeBlinkFlags |= 1 << i;\n                        break;\n                    }\n                }\n            }\n            if (lipSyncValue != Number.MAX_VALUE) {\n                for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {\n                        value += lipSyncValue;\n                        lipSyncFlags |= 1 << i;\n                        break;\n                    }\n                }\n            }\n            let v;\n            // パラメータごとのフェード\n            if (curves.at(c).fadeInTime < 0.0 && curves.at(c).fadeOutTime < 0.0) {\n                // モーションのフェードを適用\n                v = sourceValue + (value - sourceValue) * fadeWeight;\n            }\n            else {\n                // パラメータに対してフェードインかフェードアウトが設定してある場合はそちらを適用\n                let fin;\n                let fout;\n                if (curves.at(c).fadeInTime < 0.0) {\n                    fin = tmpFadeIn;\n                }\n                else {\n                    fin =\n                        curves.at(c).fadeInTime == 0.0\n                            ? 1.0\n                            : cubismmath_1.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                                curves.at(c).fadeInTime);\n                }\n                if (curves.at(c).fadeOutTime < 0.0) {\n                    fout = tmpFadeOut;\n                }\n                else {\n                    fout =\n                        curves.at(c).fadeOutTime == 0.0 ||\n                            motionQueueEntry.getEndTime() < 0.0\n                            ? 1.0\n                            : cubismmath_1.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                                curves.at(c).fadeOutTime);\n                }\n                const paramWeight = this._weight * fin * fout;\n                // パラメータごとのフェードを適用\n                v = sourceValue + (value - sourceValue) * paramWeight;\n            }\n            model.setParameterValueByIndex(parameterIndex, v, 1.0);\n        }\n        {\n            if (eyeBlinkValue != Number.MAX_VALUE) {\n                for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds.at(i));\n                    // モーションでの上書きがあった時にはまばたきは適用しない\n                    if ((eyeBlinkFlags >> i) & 0x01) {\n                        continue;\n                    }\n                    const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;\n                    model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);\n                }\n            }\n            if (lipSyncValue != Number.MAX_VALUE) {\n                for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    const sourceValue = model.getParameterValueById(this._lipSyncParameterIds.at(i));\n                    // モーションでの上書きがあった時にはリップシンクは適用しない\n                    if ((lipSyncFlags >> i) & 0x01) {\n                        continue;\n                    }\n                    const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;\n                    model.setParameterValueById(this._lipSyncParameterIds.at(i), v);\n                }\n            }\n        }\n        for (; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {\n            // Find parameter index.\n            parameterIndex = model.getParameterIndex(curves.at(c).id);\n            // Skip curve evaluation if no value in sink.\n            if (parameterIndex == -1) {\n                continue;\n            }\n            // Evaluate curve and apply value.\n            value = evaluateCurve(this._motionData, c, time);\n            model.setParameterValueByIndex(parameterIndex, value);\n        }\n        if (timeOffsetSeconds >= this._motionData.duration) {\n            if (this._isLoop) {\n                motionQueueEntry.setStartTime(userTimeSeconds); // 最初の状態へ\n                if (this._isLoopFadeIn) {\n                    // ループ内でループ用フェードインが有効の時は、フェードイン設定し直し\n                    motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n                }\n            }\n            else {\n                if (this._onFinishedMotion) {\n                    this._onFinishedMotion(this);\n                }\n                motionQueueEntry.setIsFinished(true);\n            }\n        }\n        this._lastWeight = fadeWeight;\n    }\n    /**\n     * ループ情報の設定\n     * @param loop ループ情報\n     */\n    setIsLoop(loop) {\n        this._isLoop = loop;\n    }\n    /**\n     * ループ情報の取得\n     * @return true ループする\n     * @return false ループしない\n     */\n    isLoop() {\n        return this._isLoop;\n    }\n    /**\n     * ループ時のフェードイン情報の設定\n     * @param loopFadeIn  ループ時のフェードイン情報\n     */\n    setIsLoopFadeIn(loopFadeIn) {\n        this._isLoopFadeIn = loopFadeIn;\n    }\n    /**\n     * ループ時のフェードイン情報の取得\n     *\n     * @return  true    する\n     * @return  false   しない\n     */\n    isLoopFadeIn() {\n        return this._isLoopFadeIn;\n    }\n    /**\n     * モーションの長さを取得する。\n     *\n     * @return  モーションの長さ[秒]\n     */\n    getDuration() {\n        return this._isLoop ? -1.0 : this._loopDurationSeconds;\n    }\n    /**\n     * モーションのループ時の長さを取得する。\n     *\n     * @return  モーションのループ時の長さ[秒]\n     */\n    getLoopDuration() {\n        return this._loopDurationSeconds;\n    }\n    /**\n     * パラメータに対するフェードインの時間を設定する。\n     *\n     * @param parameterId     パラメータID\n     * @param value           フェードインにかかる時間[秒]\n     */\n    setParameterFadeInTime(parameterId, value) {\n        const curves = this._motionData.curves;\n        for (let i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                curves.at(i).fadeInTime = value;\n                return;\n            }\n        }\n    }\n    /**\n     * パラメータに対するフェードアウトの時間の設定\n     * @param parameterId     パラメータID\n     * @param value           フェードアウトにかかる時間[秒]\n     */\n    setParameterFadeOutTime(parameterId, value) {\n        const curves = this._motionData.curves;\n        for (let i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                curves.at(i).fadeOutTime = value;\n                return;\n            }\n        }\n    }\n    /**\n     * パラメータに対するフェードインの時間の取得\n     * @param    parameterId     パラメータID\n     * @return   フェードインにかかる時間[秒]\n     */\n    getParameterFadeInTime(parameterId) {\n        const curves = this._motionData.curves;\n        for (let i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                return curves.at(i).fadeInTime;\n            }\n        }\n        return -1;\n    }\n    /**\n     * パラメータに対するフェードアウトの時間を取得\n     *\n     * @param   parameterId     パラメータID\n     * @return   フェードアウトにかかる時間[秒]\n     */\n    getParameterFadeOutTime(parameterId) {\n        const curves = this._motionData.curves;\n        for (let i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                return curves.at(i).fadeOutTime;\n            }\n        }\n        return -1;\n    }\n    /**\n     * 自動エフェクトがかかっているパラメータIDリストの設定\n     * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト\n     * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト\n     */\n    setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {\n        this._eyeBlinkParameterIds = eyeBlinkParameterIds;\n        this._lipSyncParameterIds = lipSyncParameterIds;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._sourceFrameRate = 30.0;\n        this._loopDurationSeconds = -1.0;\n        this._isLoop = false; // trueから false へデフォルトを変更\n        this._isLoopFadeIn = true; // ループ時にフェードインが有効かどうかのフラグ\n        this._lastWeight = 0.0;\n        this._motionData = null;\n        this._modelCurveIdEyeBlink = null;\n        this._modelCurveIdLipSync = null;\n        this._modelCurveIdOpacity = null;\n        this._eyeBlinkParameterIds = null;\n        this._lipSyncParameterIds = null;\n        this._modelOpacity = 1.0;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        this._motionData = void 0;\n        this._motionData = null;\n    }\n    /**\n     * motion3.jsonをパースする。\n     *\n     * @param motionJson  motion3.jsonが読み込まれているバッファ\n     * @param size        バッファのサイズ\n     */\n    parse(motionJson, size) {\n        this._motionData = new cubismmotioninternal_1.CubismMotionData();\n        let json = new cubismmotionjson_1.CubismMotionJson(motionJson, size);\n        this._motionData.duration = json.getMotionDuration();\n        this._motionData.loop = json.isMotionLoop();\n        this._motionData.curveCount = json.getMotionCurveCount();\n        this._motionData.fps = json.getMotionFps();\n        this._motionData.eventCount = json.getEventCount();\n        const areBeziersRestructed = json.getEvaluationOptionFlag(cubismmotionjson_1.EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);\n        if (json.isExistMotionFadeInTime()) {\n            this._fadeInSeconds =\n                json.getMotionFadeInTime() < 0.0 ? 1.0 : json.getMotionFadeInTime();\n        }\n        else {\n            this._fadeInSeconds = 1.0;\n        }\n        if (json.isExistMotionFadeOutTime()) {\n            this._fadeOutSeconds =\n                json.getMotionFadeOutTime() < 0.0 ? 1.0 : json.getMotionFadeOutTime();\n        }\n        else {\n            this._fadeOutSeconds = 1.0;\n        }\n        this._motionData.curves.updateSize(this._motionData.curveCount, cubismmotioninternal_1.CubismMotionCurve, true);\n        this._motionData.segments.updateSize(json.getMotionTotalSegmentCount(), cubismmotioninternal_1.CubismMotionSegment, true);\n        this._motionData.points.updateSize(json.getMotionTotalPointCount(), cubismmotioninternal_1.CubismMotionPoint, true);\n        this._motionData.events.updateSize(this._motionData.eventCount, cubismmotioninternal_1.CubismMotionEvent, true);\n        let totalPointCount = 0;\n        let totalSegmentCount = 0;\n        // Curves\n        for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {\n            if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {\n                this._motionData.curves.at(curveCount).type =\n                    cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n            }\n            else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {\n                this._motionData.curves.at(curveCount).type =\n                    cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n            }\n            else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {\n                this._motionData.curves.at(curveCount).type =\n                    cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n            }\n            else {\n                (0, cubismdebug_1.CubismLogWarning)('Warning : Unable to get segment type from Curve! The number of \"CurveCount\" may be incorrect!');\n            }\n            this._motionData.curves.at(curveCount).id =\n                json.getMotionCurveId(curveCount);\n            this._motionData.curves.at(curveCount).baseSegmentIndex =\n                totalSegmentCount;\n            this._motionData.curves.at(curveCount).fadeInTime =\n                json.isExistMotionCurveFadeInTime(curveCount)\n                    ? json.getMotionCurveFadeInTime(curveCount)\n                    : -1.0;\n            this._motionData.curves.at(curveCount).fadeOutTime =\n                json.isExistMotionCurveFadeOutTime(curveCount)\n                    ? json.getMotionCurveFadeOutTime(curveCount)\n                    : -1.0;\n            // Segments\n            for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount);) {\n                if (segmentPosition == 0) {\n                    this._motionData.segments.at(totalSegmentCount).basePointIndex =\n                        totalPointCount;\n                    this._motionData.points.at(totalPointCount).time =\n                        json.getMotionCurveSegment(curveCount, segmentPosition);\n                    this._motionData.points.at(totalPointCount).value =\n                        json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                    totalPointCount += 1;\n                    segmentPosition += 2;\n                }\n                else {\n                    this._motionData.segments.at(totalSegmentCount).basePointIndex =\n                        totalPointCount - 1;\n                }\n                const segment = json.getMotionCurveSegment(curveCount, segmentPosition);\n                switch (segment) {\n                    case cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Linear: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Linear;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            linearEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    case cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Bezier;\n                        if (areBeziersRestructed || UseOldBeziersCurveMotion) {\n                            this._motionData.segments.at(totalSegmentCount).evaluate =\n                                bezierEvaluate;\n                        }\n                        else {\n                            this._motionData.segments.at(totalSegmentCount).evaluate =\n                                bezierEvaluateCardanoInterpretation;\n                        }\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        this._motionData.points.at(totalPointCount + 1).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 3);\n                        this._motionData.points.at(totalPointCount + 1).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 4);\n                        this._motionData.points.at(totalPointCount + 2).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 5);\n                        this._motionData.points.at(totalPointCount + 2).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 6);\n                        totalPointCount += 3;\n                        segmentPosition += 7;\n                        break;\n                    }\n                    case cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_Stepped;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            steppedEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    case cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            cubismmotioninternal_1.CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            inverseSteppedEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    default: {\n                        (0, cubismdebug_1.CSM_ASSERT)(0);\n                        break;\n                    }\n                }\n                ++this._motionData.curves.at(curveCount).segmentCount;\n                ++totalSegmentCount;\n            }\n        }\n        for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {\n            this._motionData.events.at(userdatacount).fireTime =\n                json.getEventTime(userdatacount);\n            this._motionData.events.at(userdatacount).value =\n                json.getEventValue(userdatacount);\n        }\n        json.release();\n        json = void 0;\n        json = null;\n    }\n    /**\n     * モデルのパラメータ更新\n     *\n     * イベント発火のチェック。\n     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n     *\n     * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]\n     * @param motionTimeSeconds        今回の再生時間[秒]\n     */\n    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {\n        this._firedEventValues.updateSize(0);\n        // イベントの発火チェック\n        for (let u = 0; u < this._motionData.eventCount; ++u) {\n            if (this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds &&\n                this._motionData.events.at(u).fireTime <= motionTimeSeconds) {\n                this._firedEventValues.pushBack(new csmstring_1.csmString(this._motionData.events.at(u).value.s));\n            }\n        }\n        return this._firedEventValues;\n    }\n    /**\n     * 透明度のカーブが存在するかどうかを確認する\n     *\n     * @returns true  -> キーが存在する\n     *          false -> キーが存在しない\n     */\n    isExistModelOpacity() {\n        for (let i = 0; i < this._motionData.curveCount; i++) {\n            const curve = this._motionData.curves.at(i);\n            if (curve.type != cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n                continue;\n            }\n            if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * 透明度のカーブのインデックスを返す\n     *\n     * @returns success:透明度のカーブのインデックス\n     */\n    getModelOpacityIndex() {\n        if (this.isExistModelOpacity()) {\n            for (let i = 0; i < this._motionData.curveCount; i++) {\n                const curve = this._motionData.curves.at(i);\n                if (curve.type != cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n                    continue;\n                }\n                if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * 透明度のIdを返す\n     *\n     * @param index モーションカーブのインデックス\n     * @returns success:透明度のカーブのインデックス\n     */\n    getModelOpacityId(index) {\n        if (index != -1) {\n            const curve = this._motionData.curves.at(index);\n            if (curve.type == cubismmotioninternal_1.CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n                if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n                    return live2dcubismframework_1.CubismFramework.getIdManager().getId(curve.id.getString().s);\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * 現在時間の透明度の値を返す\n     *\n     * @returns success:モーションの当該時間におけるOpacityの値\n     */\n    getModelOpacityValue() {\n        return this._modelOpacity;\n    }\n}\nexports.CubismMotion = CubismMotion;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotion */ \"./cubism/Framework/src/motion/cubismmotion.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotion = $.CubismMotion;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotion.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotioninternal.ts":
/*!*************************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotioninternal.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMotionData = exports.CubismMotionEvent = exports.CubismMotionCurve = exports.CubismMotionSegment = exports.CubismMotionPoint = exports.CubismMotionSegmentType = exports.CubismMotionCurveTarget = void 0;\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\n/**\n * @brief モーションカーブの種類\n *\n * モーションカーブの種類。\n */\nvar CubismMotionCurveTarget;\n(function (CubismMotionCurveTarget) {\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_Model\"] = 0] = \"CubismMotionCurveTarget_Model\";\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_Parameter\"] = 1] = \"CubismMotionCurveTarget_Parameter\";\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_PartOpacity\"] = 2] = \"CubismMotionCurveTarget_PartOpacity\";\n})(CubismMotionCurveTarget || (exports.CubismMotionCurveTarget = CubismMotionCurveTarget = {}));\n/**\n * @brief モーションカーブのセグメントの種類\n *\n * モーションカーブのセグメントの種類。\n */\nvar CubismMotionSegmentType;\n(function (CubismMotionSegmentType) {\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Linear\"] = 0] = \"CubismMotionSegmentType_Linear\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Bezier\"] = 1] = \"CubismMotionSegmentType_Bezier\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Stepped\"] = 2] = \"CubismMotionSegmentType_Stepped\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_InverseStepped\"] = 3] = \"CubismMotionSegmentType_InverseStepped\";\n})(CubismMotionSegmentType || (exports.CubismMotionSegmentType = CubismMotionSegmentType = {}));\n/**\n * @brief モーションカーブの制御点\n *\n * モーションカーブの制御点。\n */\nclass CubismMotionPoint {\n    constructor() {\n        this.time = 0.0; // 時間[秒]\n        this.value = 0.0; // 値\n    }\n}\nexports.CubismMotionPoint = CubismMotionPoint;\n/**\n * @brief モーションカーブのセグメント\n *\n * モーションカーブのセグメント。\n */\nclass CubismMotionSegment {\n    /**\n     * @brief コンストラクタ\n     *\n     * コンストラクタ。\n     */\n    constructor() {\n        this.evaluate = null;\n        this.basePointIndex = 0;\n        this.segmentType = 0;\n    }\n}\nexports.CubismMotionSegment = CubismMotionSegment;\n/**\n * @brief モーションカーブ\n *\n * モーションカーブ。\n */\nclass CubismMotionCurve {\n    constructor() {\n        this.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n        this.segmentCount = 0;\n        this.baseSegmentIndex = 0;\n        this.fadeInTime = 0.0;\n        this.fadeOutTime = 0.0;\n    }\n}\nexports.CubismMotionCurve = CubismMotionCurve;\n/**\n * イベント。\n */\nclass CubismMotionEvent {\n    constructor() {\n        this.fireTime = 0.0;\n    }\n}\nexports.CubismMotionEvent = CubismMotionEvent;\n/**\n * @brief モーションデータ\n *\n * モーションデータ。\n */\nclass CubismMotionData {\n    constructor() {\n        this.duration = 0.0;\n        this.loop = false;\n        this.curveCount = 0;\n        this.eventCount = 0;\n        this.fps = 0.0;\n        this.curves = new csmvector_1.csmVector();\n        this.segments = new csmvector_1.csmVector();\n        this.points = new csmvector_1.csmVector();\n        this.events = new csmvector_1.csmVector();\n    }\n}\nexports.CubismMotionData = CubismMotionData;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotioninternal */ \"./cubism/Framework/src/motion/cubismmotioninternal.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionCurve = $.CubismMotionCurve;\n    Live2DCubismFramework.CubismMotionCurveTarget = $.CubismMotionCurveTarget;\n    Live2DCubismFramework.CubismMotionData = $.CubismMotionData;\n    Live2DCubismFramework.CubismMotionEvent = $.CubismMotionEvent;\n    Live2DCubismFramework.CubismMotionPoint = $.CubismMotionPoint;\n    Live2DCubismFramework.CubismMotionSegment = $.CubismMotionSegment;\n    Live2DCubismFramework.CubismMotionSegmentType = $.CubismMotionSegmentType;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotioninternal.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotionjson.ts":
/*!*********************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotionjson.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.EvaluationOptionFlag = exports.CubismMotionJson = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmstring_1 = __webpack_require__(/*! ../type/csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ../utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\n// JSON keys\nconst Meta = 'Meta';\nconst Duration = 'Duration';\nconst Loop = 'Loop';\nconst AreBeziersRestricted = 'AreBeziersRestricted';\nconst CurveCount = 'CurveCount';\nconst Fps = 'Fps';\nconst TotalSegmentCount = 'TotalSegmentCount';\nconst TotalPointCount = 'TotalPointCount';\nconst Curves = 'Curves';\nconst Target = 'Target';\nconst Id = 'Id';\nconst FadeInTime = 'FadeInTime';\nconst FadeOutTime = 'FadeOutTime';\nconst Segments = 'Segments';\nconst UserData = 'UserData';\nconst UserDataCount = 'UserDataCount';\nconst TotalUserDataSize = 'TotalUserDataSize';\nconst Time = 'Time';\nconst Value = 'Value';\n/**\n * motion3.jsonのコンテナ。\n */\nclass CubismMotionJson {\n    /**\n     * コンストラクタ\n     * @param buffer motion3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    constructor(buffer, size) {\n        this._json = cubismjson_1.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        cubismjson_1.CubismJson.delete(this._json);\n    }\n    /**\n     * モーションの長さを取得する\n     * @return モーションの長さ[秒]\n     */\n    getMotionDuration() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Duration)\n            .toFloat();\n    }\n    /**\n     * モーションのループ情報の取得\n     * @return true ループする\n     * @return false ループしない\n     */\n    isMotionLoop() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Loop)\n            .toBoolean();\n    }\n    getEvaluationOptionFlag(flagType) {\n        if (EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted == flagType) {\n            return this._json\n                .getRoot()\n                .getValueByString(Meta)\n                .getValueByString(AreBeziersRestricted)\n                .toBoolean();\n        }\n        return false;\n    }\n    /**\n     * モーションカーブの個数の取得\n     * @return モーションカーブの個数\n     */\n    getMotionCurveCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(CurveCount)\n            .toInt();\n    }\n    /**\n     * モーションのフレームレートの取得\n     * @return フレームレート[FPS]\n     */\n    getMotionFps() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Fps)\n            .toFloat();\n    }\n    /**\n     * モーションのセグメントの総合計の取得\n     * @return モーションのセグメントの取得\n     */\n    getMotionTotalSegmentCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalSegmentCount)\n            .toInt();\n    }\n    /**\n     * モーションのカーブの制御店の総合計の取得\n     * @return モーションのカーブの制御点の総合計\n     */\n    getMotionTotalPointCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalPointCount)\n            .toInt();\n    }\n    /**\n     * モーションのフェードイン時間の存在\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    isExistMotionFadeInTime() {\n        return !this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeInTime)\n            .isNull();\n    }\n    /**\n     * モーションのフェードアウト時間の存在\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    isExistMotionFadeOutTime() {\n        return !this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeOutTime)\n            .isNull();\n    }\n    /**\n     * モーションのフェードイン時間の取得\n     * @return フェードイン時間[秒]\n     */\n    getMotionFadeInTime() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    }\n    /**\n     * モーションのフェードアウト時間の取得\n     * @return フェードアウト時間[秒]\n     */\n    getMotionFadeOutTime() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    }\n    /**\n     * モーションのカーブの種類の取得\n     * @param curveIndex カーブのインデックス\n     * @return カーブの種類\n     */\n    getMotionCurveTarget(curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Target)\n            .getRawString();\n    }\n    /**\n     * モーションのカーブのIDの取得\n     * @param curveIndex カーブのインデックス\n     * @return カーブのID\n     */\n    getMotionCurveId(curveIndex) {\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Id)\n            .getRawString());\n    }\n    /**\n     * モーションのカーブのフェードイン時間の存在\n     * @param curveIndex カーブのインデックス\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    isExistMotionCurveFadeInTime(curveIndex) {\n        return !this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeInTime)\n            .isNull();\n    }\n    /**\n     * モーションのカーブのフェードアウト時間の存在\n     * @param curveIndex カーブのインデックス\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    isExistMotionCurveFadeOutTime(curveIndex) {\n        return !this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeOutTime)\n            .isNull();\n    }\n    /**\n     * モーションのカーブのフェードイン時間の取得\n     * @param curveIndex カーブのインデックス\n     * @return フェードイン時間[秒]\n     */\n    getMotionCurveFadeInTime(curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    }\n    /**\n     * モーションのカーブのフェードアウト時間の取得\n     * @param curveIndex カーブのインデックス\n     * @return フェードアウト時間[秒]\n     */\n    getMotionCurveFadeOutTime(curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    }\n    /**\n     * モーションのカーブのセグメントの個数を取得する\n     * @param curveIndex カーブのインデックス\n     * @return モーションのカーブのセグメントの個数\n     */\n    getMotionCurveSegmentCount(curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Segments)\n            .getVector()\n            .getSize();\n    }\n    /**\n     * モーションのカーブのセグメントの値の取得\n     * @param curveIndex カーブのインデックス\n     * @param segmentIndex セグメントのインデックス\n     * @return セグメントの値\n     */\n    getMotionCurveSegment(curveIndex, segmentIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Segments)\n            .getValueByIndex(segmentIndex)\n            .toFloat();\n    }\n    /**\n     * イベントの個数の取得\n     * @return イベントの個数\n     */\n    getEventCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(UserDataCount)\n            .toInt();\n    }\n    /**\n     *  イベントの総文字数の取得\n     * @return イベントの総文字数\n     */\n    getTotalEventValueSize() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalUserDataSize)\n            .toInt();\n    }\n    /**\n     * イベントの時間の取得\n     * @param userDataIndex イベントのインデックス\n     * @return イベントの時間[秒]\n     */\n    getEventTime(userDataIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(userDataIndex)\n            .getValueByString(Time)\n            .toFloat();\n    }\n    /**\n     * イベントの取得\n     * @param userDataIndex イベントのインデックス\n     * @return イベントの文字列\n     */\n    getEventValue(userDataIndex) {\n        return new csmstring_1.csmString(this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(userDataIndex)\n            .getValueByString(Value)\n            .getRawString());\n    }\n}\nexports.CubismMotionJson = CubismMotionJson;\n/**\n * @brief ベジェカーブの解釈方法のフラグタイプ\n */\nvar EvaluationOptionFlag;\n(function (EvaluationOptionFlag) {\n    EvaluationOptionFlag[EvaluationOptionFlag[\"EvaluationOptionFlag_AreBeziersRistricted\"] = 0] = \"EvaluationOptionFlag_AreBeziersRistricted\";\n})(EvaluationOptionFlag || (exports.EvaluationOptionFlag = EvaluationOptionFlag = {}));\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotionjson */ \"./cubism/Framework/src/motion/cubismmotionjson.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionJson = $.CubismMotionJson;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotionjson.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotionmanager.ts":
/*!************************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotionmanager.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMotionManager = void 0;\nconst cubismmotionqueuemanager_1 = __webpack_require__(/*! ./cubismmotionqueuemanager */ \"./cubism/Framework/src/motion/cubismmotionqueuemanager.ts\");\n/**\n * モーションの管理\n *\n * モーションの管理を行うクラス\n */\nclass CubismMotionManager extends cubismmotionqueuemanager_1.CubismMotionQueueManager {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._currentPriority = 0;\n        this._reservePriority = 0;\n    }\n    /**\n     * 再生中のモーションの優先度の取得\n     * @return  モーションの優先度\n     */\n    getCurrentPriority() {\n        return this._currentPriority;\n    }\n    /**\n     * 予約中のモーションの優先度を取得する。\n     * @return  モーションの優先度\n     */\n    getReservePriority() {\n        return this._reservePriority;\n    }\n    /**\n     * 予約中のモーションの優先度を設定する。\n     * @param   val     優先度\n     */\n    setReservePriority(val) {\n        this._reservePriority = val;\n    }\n    /**\n     * 優先度を設定してモーションを開始する。\n     *\n     * @param motion          モーション\n     * @param autoDelete      再生が狩猟したモーションのインスタンスを削除するならtrue\n     * @param priority        優先度\n     * @return                開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n     */\n    startMotionPriority(motion, autoDelete, priority) {\n        if (priority == this._reservePriority) {\n            this._reservePriority = 0; // 予約を解除\n        }\n        this._currentPriority = priority; // 再生中モーションの優先度を設定\n        return super.startMotion(motion, autoDelete, this._userTimeSeconds);\n    }\n    /**\n     * モーションを更新して、モデルにパラメータ値を反映する。\n     *\n     * @param model   対象のモデル\n     * @param deltaTimeSeconds    デルタ時間[秒]\n     * @return  true    更新されている\n     * @return  false   更新されていない\n     */\n    updateMotion(model, deltaTimeSeconds) {\n        this._userTimeSeconds += deltaTimeSeconds;\n        const updated = super.doUpdateMotion(model, this._userTimeSeconds);\n        if (this.isFinished()) {\n            this._currentPriority = 0; // 再生中のモーションの優先度を解除\n        }\n        return updated;\n    }\n    /**\n     * モーションを予約する。\n     *\n     * @param   priority    優先度\n     * @return  true    予約できた\n     * @return  false   予約できなかった\n     */\n    reserveMotion(priority) {\n        if (priority <= this._reservePriority ||\n            priority <= this._currentPriority) {\n            return false;\n        }\n        this._reservePriority = priority;\n        return true;\n    }\n}\nexports.CubismMotionManager = CubismMotionManager;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotionmanager */ \"./cubism/Framework/src/motion/cubismmotionmanager.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionManager = $.CubismMotionManager;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotionmanager.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotionqueueentry.ts":
/*!***************************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotionqueueentry.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismMotionQueueEntry = void 0;\nconst acubismmotion_1 = __webpack_require__(/*! ./acubismmotion */ \"./cubism/Framework/src/motion/acubismmotion.ts\");\n/**\n * CubismMotionQueueManagerで再生している各モーションの管理クラス。\n */\nclass CubismMotionQueueEntry {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._autoDelete = false;\n        this._motion = null;\n        this._available = true;\n        this._finished = false;\n        this._started = false;\n        this._startTimeSeconds = -1.0;\n        this._fadeInStartTimeSeconds = 0.0;\n        this._endTimeSeconds = -1.0;\n        this._stateTimeSeconds = 0.0;\n        this._stateWeight = 0.0;\n        this._lastEventCheckSeconds = 0.0;\n        this._motionQueueEntryHandle = this;\n        this._fadeOutSeconds = 0.0;\n        this._isTriggeredFadeOut = false;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        if (this._autoDelete && this._motion) {\n            acubismmotion_1.ACubismMotion.delete(this._motion); //\n        }\n    }\n    /**\n     * フェードアウト時間と開始判定の設定\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     */\n    setFadeOut(fadeOutSeconds) {\n        this._fadeOutSeconds = fadeOutSeconds;\n        this._isTriggeredFadeOut = true;\n    }\n    /**\n     * フェードアウトの開始\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     */\n    startFadeOut(fadeOutSeconds, userTimeSeconds) {\n        const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;\n        this._isTriggeredFadeOut = true;\n        if (this._endTimeSeconds < 0.0 ||\n            newEndTimeSeconds < this._endTimeSeconds) {\n            this._endTimeSeconds = newEndTimeSeconds;\n        }\n    }\n    /**\n     * モーションの終了の確認\n     *\n     * @return true モーションが終了した\n     * @return false 終了していない\n     */\n    isFinished() {\n        return this._finished;\n    }\n    /**\n     * モーションの開始の確認\n     * @return true モーションが開始した\n     * @return false 開始していない\n     */\n    isStarted() {\n        return this._started;\n    }\n    /**\n     * モーションの開始時刻の取得\n     * @return モーションの開始時刻[秒]\n     */\n    getStartTime() {\n        return this._startTimeSeconds;\n    }\n    /**\n     * フェードインの開始時刻の取得\n     * @return フェードインの開始時刻[秒]\n     */\n    getFadeInStartTime() {\n        return this._fadeInStartTimeSeconds;\n    }\n    /**\n     * フェードインの終了時刻の取得\n     * @return フェードインの終了時刻の取得\n     */\n    getEndTime() {\n        return this._endTimeSeconds;\n    }\n    /**\n     * モーションの開始時刻の設定\n     * @param startTime モーションの開始時刻\n     */\n    setStartTime(startTime) {\n        this._startTimeSeconds = startTime;\n    }\n    /**\n     * フェードインの開始時刻の設定\n     * @param startTime フェードインの開始時刻[秒]\n     */\n    setFadeInStartTime(startTime) {\n        this._fadeInStartTimeSeconds = startTime;\n    }\n    /**\n     * フェードインの終了時刻の設定\n     * @param endTime フェードインの終了時刻[秒]\n     */\n    setEndTime(endTime) {\n        this._endTimeSeconds = endTime;\n    }\n    /**\n     * モーションの終了の設定\n     * @param f trueならモーションの終了\n     */\n    setIsFinished(f) {\n        this._finished = f;\n    }\n    /**\n     * モーション開始の設定\n     * @param f trueならモーションの開始\n     */\n    setIsStarted(f) {\n        this._started = f;\n    }\n    /**\n     * モーションの有効性の確認\n     * @return true モーションは有効\n     * @return false モーションは無効\n     */\n    isAvailable() {\n        return this._available;\n    }\n    /**\n     * モーションの有効性の設定\n     * @param v trueならモーションは有効\n     */\n    setIsAvailable(v) {\n        this._available = v;\n    }\n    /**\n     * モーションの状態の設定\n     * @param timeSeconds 現在時刻[秒]\n     * @param weight モーション尾重み\n     */\n    setState(timeSeconds, weight) {\n        this._stateTimeSeconds = timeSeconds;\n        this._stateWeight = weight;\n    }\n    /**\n     * モーションの現在時刻の取得\n     * @return モーションの現在時刻[秒]\n     */\n    getStateTime() {\n        return this._stateTimeSeconds;\n    }\n    /**\n     * モーションの重みの取得\n     * @return モーションの重み\n     */\n    getStateWeight() {\n        return this._stateWeight;\n    }\n    /**\n     * 最後にイベントの発火をチェックした時間を取得\n     *\n     * @return 最後にイベントの発火をチェックした時間[秒]\n     */\n    getLastCheckEventSeconds() {\n        return this._lastEventCheckSeconds;\n    }\n    /**\n     * 最後にイベントをチェックした時間を設定\n     * @param checkSeconds 最後にイベントをチェックした時間[秒]\n     */\n    setLastCheckEventSeconds(checkSeconds) {\n        this._lastEventCheckSeconds = checkSeconds;\n    }\n    /**\n     * フェードアウト開始判定の取得\n     * @return フェードアウト開始するかどうか\n     */\n    isTriggeredFadeOut() {\n        return this._isTriggeredFadeOut;\n    }\n    /**\n     * フェードアウト時間の取得\n     * @return フェードアウト時間[秒]\n     */\n    getFadeOutSeconds() {\n        return this._fadeOutSeconds;\n    }\n}\nexports.CubismMotionQueueEntry = CubismMotionQueueEntry;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotionqueueentry */ \"./cubism/Framework/src/motion/cubismmotionqueueentry.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionQueueEntry = $.CubismMotionQueueEntry;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotionqueueentry.ts?");

/***/ }),

/***/ "./cubism/Framework/src/motion/cubismmotionqueuemanager.ts":
/*!*****************************************************************!*\
  !*** ./cubism/Framework/src/motion/cubismmotionqueuemanager.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.InvalidMotionQueueEntryHandleValue = exports.CubismMotionQueueManager = void 0;\nconst cubismmotionqueueentry_1 = __webpack_require__(/*! ./cubismmotionqueueentry */ \"./cubism/Framework/src/motion/cubismmotionqueueentry.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\n/**\n * モーション再生の管理\n *\n * モーション再生の管理用クラス。CubismMotionモーションなどACubismMotionのサブクラスを再生するために使用する。\n *\n * @note 再生中に別のモーションが StartMotion()された場合は、新しいモーションに滑らかに変化し旧モーションは中断する。\n *       表情用モーション、体用モーションなどを分けてモーション化した場合など、\n *       複数のモーションを同時に再生させる場合は、複数のCubismMotionQueueManagerインスタンスを使用する。\n */\nclass CubismMotionQueueManager {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._userTimeSeconds = 0.0;\n        this._eventCallBack = null;\n        this._eventCustomData = null;\n        this._motions = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ\n     */\n    release() {\n        for (let i = 0; i < this._motions.getSize(); ++i) {\n            if (this._motions.at(i)) {\n                this._motions.at(i).release();\n                this._motions.set(i, null);\n            }\n        }\n        this._motions = null;\n    }\n    /**\n     * 指定したモーションの開始\n     *\n     * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。\n     *\n     * @param   motion          開始するモーション\n     * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true\n     * @param   userTimeSeconds デルタ時間の積算値[秒]\n     * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n     */\n    startMotion(motion, autoDelete, userTimeSeconds) {\n        if (motion == null) {\n            return exports.InvalidMotionQueueEntryHandleValue;\n        }\n        let motionQueueEntry = null;\n        // 既にモーションがあれば終了フラグを立てる\n        for (let i = 0; i < this._motions.getSize(); ++i) {\n            motionQueueEntry = this._motions.at(i);\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime()); // フェードアウト設定\n        }\n        motionQueueEntry = new cubismmotionqueueentry_1.CubismMotionQueueEntry(); // 終了時に破棄する\n        motionQueueEntry._autoDelete = autoDelete;\n        motionQueueEntry._motion = motion;\n        this._motions.pushBack(motionQueueEntry);\n        return motionQueueEntry._motionQueueEntryHandle;\n    }\n    /**\n     * 全てのモーションの終了の確認\n     * @return true 全て終了している\n     * @return false 終了していない\n     */\n    isFinished() {\n        // ------- 処理を行う -------\n        // 既にモーションがあれば終了フラグを立てる\n        for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            let motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            const motion = motionQueueEntry._motion;\n            if (motion == null) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            // ----- 終了済みの処理があれば削除する ------\n            if (!motionQueueEntry.isFinished()) {\n                return false;\n            }\n            else {\n                ite.preIncrement();\n            }\n        }\n        return true;\n    }\n    /**\n     * 指定したモーションの終了の確認\n     * @param motionQueueEntryNumber モーションの識別番号\n     * @return true 全て終了している\n     * @return false 終了していない\n     */\n    isFinishedByHandle(motionQueueEntryNumber) {\n        for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {\n            const motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber &&\n                !motionQueueEntry.isFinished()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * 全てのモーションを停止する\n     */\n    stopAllMotions() {\n        // ------- 処理を行う -------\n        // 既にモーションがあれば終了フラグを立てる\n        for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            let motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite);\n                continue;\n            }\n            // ----- 終了済みの処理があれば削除する ------\n            motionQueueEntry.release();\n            motionQueueEntry = null;\n            ite = this._motions.erase(ite); // 削除\n        }\n    }\n    /**\n         * 指定したCubismMotionQueueEntryの取得\n  \n          * @param   motionQueueEntryNumber  モーションの識別番号\n          * @return  指定したCubismMotionQueueEntry\n          * @return  null   見つからなかった\n          */\n    getCubismMotionQueueEntry(motionQueueEntryNumber) {\n        //------- 処理を行う -------\n        for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {\n            const motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {\n                return motionQueueEntry;\n            }\n        }\n        return null;\n    }\n    /**\n     * イベントを受け取るCallbackの登録\n     *\n     * @param callback コールバック関数\n     * @param customData コールバックに返されるデータ\n     */\n    setEventCallback(callback, customData = null) {\n        this._eventCallBack = callback;\n        this._eventCustomData = customData;\n    }\n    /**\n     * モーションを更新して、モデルにパラメータ値を反映する。\n     *\n     * @param   model   対象のモデル\n     * @param   userTimeSeconds   デルタ時間の積算値[秒]\n     * @return  true    モデルへパラメータ値の反映あり\n     * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)\n     */\n    doUpdateMotion(model, userTimeSeconds) {\n        let updated = false;\n        // ------- 処理を行う --------\n        // 既にモーションがあれば終了フラグを立てる\n        for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            let motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            const motion = motionQueueEntry._motion;\n            if (motion == null) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            // ------ 値を反映する ------\n            motion.updateParameters(model, motionQueueEntry, userTimeSeconds);\n            updated = true;\n            // ------ ユーザトリガーイベントを検査する ----\n            const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() -\n                motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());\n            for (let i = 0; i < firedList.getSize(); ++i) {\n                this._eventCallBack(this, firedList.at(i), this._eventCustomData);\n            }\n            motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);\n            // ------ 終了済みの処理があれば削除する ------\n            if (motionQueueEntry.isFinished()) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n            }\n            else {\n                if (motionQueueEntry.isTriggeredFadeOut()) {\n                    motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);\n                }\n                ite.preIncrement();\n            }\n        }\n        return updated;\n    }\n}\nexports.CubismMotionQueueManager = CubismMotionQueueManager;\nexports.InvalidMotionQueueEntryHandleValue = -1;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismmotionqueuemanager */ \"./cubism/Framework/src/motion/cubismmotionqueuemanager.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionQueueManager = $.CubismMotionQueueManager;\n    Live2DCubismFramework.InvalidMotionQueueEntryHandleValue = $.InvalidMotionQueueEntryHandleValue;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/motion/cubismmotionqueuemanager.ts?");

/***/ }),

/***/ "./cubism/Framework/src/physics/cubismphysics.ts":
/*!*******************************************************!*\
  !*** ./cubism/Framework/src/physics/cubismphysics.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.PhysicsOutput = exports.Options = exports.CubismPhysics = void 0;\nconst cubismmath_1 = __webpack_require__(/*! ../math/cubismmath */ \"./cubism/Framework/src/math/cubismmath.ts\");\nconst cubismvector2_1 = __webpack_require__(/*! ../math/cubismvector2 */ \"./cubism/Framework/src/math/cubismvector2.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismphysicsinternal_1 = __webpack_require__(/*! ./cubismphysicsinternal */ \"./cubism/Framework/src/physics/cubismphysicsinternal.ts\");\nconst cubismphysicsjson_1 = __webpack_require__(/*! ./cubismphysicsjson */ \"./cubism/Framework/src/physics/cubismphysicsjson.ts\");\n// physics types tags.\nconst PhysicsTypeTagX = 'X';\nconst PhysicsTypeTagY = 'Y';\nconst PhysicsTypeTagAngle = 'Angle';\n// Constant of air resistance.\nconst AirResistance = 5.0;\n// Constant of maximum weight of input and output ratio.\nconst MaximumWeight = 100.0;\n// Constant of threshold of movement.\nconst MovementThreshold = 0.001;\n// Constant of maximum allowed delta time\nconst MaxDeltaTime = 5.0;\n/**\n * 物理演算クラス\n */\nclass CubismPhysics {\n    /**\n     * インスタンスの作成\n     * @param buffer    physics3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    static create(buffer, size) {\n        const ret = new CubismPhysics();\n        ret.parse(buffer, size);\n        ret._physicsRig.gravity.y = 0;\n        return ret;\n    }\n    /**\n     * インスタンスを破棄する\n     * @param physics 破棄するインスタンス\n     */\n    static delete(physics) {\n        if (physics != null) {\n            physics.release();\n            physics = null;\n        }\n    }\n    /**\n     * physics3.jsonをパースする。\n     * @param physicsJson physics3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    parse(physicsJson, size) {\n        this._physicsRig = new cubismphysicsinternal_1.CubismPhysicsRig();\n        let json = new cubismphysicsjson_1.CubismPhysicsJson(physicsJson, size);\n        this._physicsRig.gravity = json.getGravity();\n        this._physicsRig.wind = json.getWind();\n        this._physicsRig.subRigCount = json.getSubRigCount();\n        this._physicsRig.fps = json.getFps();\n        this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, cubismphysicsinternal_1.CubismPhysicsSubRig, true);\n        this._physicsRig.inputs.updateSize(json.getTotalInputCount(), cubismphysicsinternal_1.CubismPhysicsInput, true);\n        this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), cubismphysicsinternal_1.CubismPhysicsOutput, true);\n        this._physicsRig.particles.updateSize(json.getVertexCount(), cubismphysicsinternal_1.CubismPhysicsParticle, true);\n        this._currentRigOutputs.clear();\n        this._previousRigOutputs.clear();\n        let inputIndex = 0, outputIndex = 0, particleIndex = 0;\n        for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {\n            this._physicsRig.settings.at(i).normalizationPosition.minimum =\n                json.getNormalizationPositionMinimumValue(i);\n            this._physicsRig.settings.at(i).normalizationPosition.maximum =\n                json.getNormalizationPositionMaximumValue(i);\n            this._physicsRig.settings.at(i).normalizationPosition.defalut =\n                json.getNormalizationPositionDefaultValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.minimum =\n                json.getNormalizationAngleMinimumValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.maximum =\n                json.getNormalizationAngleMaximumValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.defalut =\n                json.getNormalizationAngleDefaultValue(i);\n            // Input\n            this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\n            this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\n            for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\n                this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\n                this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);\n                this._physicsRig.inputs.at(inputIndex + j).reflect =\n                    json.getInputReflect(i, j);\n                if (json.getInputType(i, j) == PhysicsTypeTagX) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_X;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue =\n                        getInputTranslationXFromNormalizedParameterValue;\n                }\n                else if (json.getInputType(i, j) == PhysicsTypeTagY) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_Y;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue =\n                        getInputTranslationYFromNormalizedParamterValue;\n                }\n                else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_Angle;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue =\n                        getInputAngleFromNormalizedParameterValue;\n                }\n                this._physicsRig.inputs.at(inputIndex + j).source.targetType =\n                    cubismphysicsinternal_1.CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n                this._physicsRig.inputs.at(inputIndex + j).source.id =\n                    json.getInputSourceId(i, j);\n            }\n            inputIndex += this._physicsRig.settings.at(i).inputCount;\n            // Output\n            this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\n            this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\n            const currentRigOutput = new PhysicsOutput();\n            currentRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n            const previousRigOutput = new PhysicsOutput();\n            previousRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n            for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\n                // initialize\n                currentRigOutput.outputs.set(j, 0.0);\n                previousRigOutput.outputs.set(j, 0.0);\n                this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex =\n                    -1;\n                this._physicsRig.outputs.at(outputIndex + j).vertexIndex =\n                    json.getOutputVertexIndex(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).angleScale =\n                    json.getOutputAngleScale(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).weight =\n                    json.getOutputWeight(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).destination.targetType =\n                    cubismphysicsinternal_1.CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n                this._physicsRig.outputs.at(outputIndex + j).destination.id =\n                    json.getOutputDestinationId(i, j);\n                if (json.getOutputType(i, j) == PhysicsTypeTagX) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_X;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputTranslationX;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleTranslationX;\n                }\n                else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_Y;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputTranslationY;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleTranslationY;\n                }\n                else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        cubismphysicsinternal_1.CubismPhysicsSource.CubismPhysicsSource_Angle;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputAngle;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleAngle;\n                }\n                this._physicsRig.outputs.at(outputIndex + j).reflect =\n                    json.getOutputReflect(i, j);\n            }\n            this._currentRigOutputs.pushBack(currentRigOutput);\n            this._previousRigOutputs.pushBack(previousRigOutput);\n            outputIndex += this._physicsRig.settings.at(i).outputCount;\n            // Particle\n            this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);\n            this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\n            for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {\n                this._physicsRig.particles.at(particleIndex + j).mobility =\n                    json.getParticleMobility(i, j);\n                this._physicsRig.particles.at(particleIndex + j).delay =\n                    json.getParticleDelay(i, j);\n                this._physicsRig.particles.at(particleIndex + j).acceleration =\n                    json.getParticleAcceleration(i, j);\n                this._physicsRig.particles.at(particleIndex + j).radius =\n                    json.getParticleRadius(i, j);\n                this._physicsRig.particles.at(particleIndex + j).position =\n                    json.getParticlePosition(i, j);\n            }\n            particleIndex += this._physicsRig.settings.at(i).particleCount;\n        }\n        this.initialize();\n        json.release();\n        json = void 0;\n        json = null;\n    }\n    /**\n     * 現在のパラメータ値で物理演算が安定化する状態を演算する。\n     * @param model 物理演算の結果を適用するモデル\n     */\n    stabilization(model) {\n        var _a, _b, _c, _d;\n        let totalAngle;\n        let weight;\n        let radAngle;\n        let outputValue;\n        const totalTranslation = new cubismvector2_1.CubismVector2();\n        let currentSetting;\n        let currentInputs;\n        let currentOutputs;\n        let currentParticles;\n        let parameterValues;\n        let parameterMaximumValues;\n        let parameterMinimumValues;\n        let parameterDefaultValues;\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        parameterDefaultValues = model.getModel().parameters.defaultValues;\n        if (((_b = (_a = this._parameterCaches) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) < model.getParameterCount()) {\n            this._parameterCaches = new Float32Array(model.getParameterCount());\n        }\n        if (((_d = (_c = this._parameterInputCaches) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < model.getParameterCount()) {\n            this._parameterInputCaches = new Float32Array(model.getParameterCount());\n        }\n        for (let j = 0; j < model.getParameterCount(); ++j) {\n            this._parameterCaches[j] = parameterValues[j];\n            this._parameterInputCaches[j] = parameterValues[j];\n        }\n        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            totalAngle = { angle: 0.0 };\n            totalTranslation.x = 0.0;\n            totalTranslation.y = 0.0;\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n            currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n            currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n            // Load input parameters\n            for (let i = 0; i < currentSetting.inputCount; ++i) {\n                weight = currentInputs[i].weight / MaximumWeight;\n                if (currentInputs[i].sourceParameterIndex == -1) {\n                    currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n                }\n                currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValues[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n                this._parameterCaches[currentInputs[i].sourceParameterIndex] =\n                    parameterValues[currentInputs[i].sourceParameterIndex];\n            }\n            radAngle = cubismmath_1.CubismMath.degreesToRadian(-totalAngle.angle);\n            totalTranslation.x =\n                totalTranslation.x * cubismmath_1.CubismMath.cos(radAngle) -\n                    totalTranslation.y * cubismmath_1.CubismMath.sin(radAngle);\n            totalTranslation.y =\n                totalTranslation.x * cubismmath_1.CubismMath.sin(radAngle) +\n                    totalTranslation.y * cubismmath_1.CubismMath.cos(radAngle);\n            // Calculate particles position.\n            updateParticlesForStabilization(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum);\n            // Update output parameters.\n            for (let i = 0; i < currentSetting.outputCount; ++i) {\n                const particleIndex = currentOutputs[i].vertexIndex;\n                if (currentOutputs[i].destinationParameterIndex == -1) {\n                    currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);\n                }\n                if (particleIndex < 1 ||\n                    particleIndex >= currentSetting.particleCount) {\n                    continue;\n                }\n                let translation = new cubismvector2_1.CubismVector2();\n                translation = currentParticles[particleIndex].position.substract(currentParticles[particleIndex - 1].position);\n                outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n                this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n                this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n                const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                const outParameterCaches = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n                    ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                    : parameterValues.slice(destinationParameterIndex);\n                updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n                // 値を反映\n                for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n                    parameterValues[offset] = this._parameterCaches[offset] =\n                        outParameterCaches[outParamIndex];\n                }\n            }\n        }\n    }\n    /**\n     * 物理演算の評価\n     *\n     * Pendulum interpolation weights\n     *\n     * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。\n     * The result of the pendulum calculation is saved and\n     * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.\n     *\n     * 図で示すと[1]と[2]で補間されます。\n     * The figure shows the interpolation between [1] and [2].\n     *\n     * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。\n     * The weight of the interpolation are determined by the current time seen between\n     * the latest pendulum calculation timing and the next timing.\n     *\n     * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。\n     * Figure shows the weight of position (3) as seen between [2] and [4].\n     *\n     * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。\n     * As an interpretation, the pendulum calculation and weights are misaligned.\n     *\n     * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。\n     * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.\n     *\n     * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。\n     * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.\n     *\n     * ------------ time -------------->\n     *\n     *                 |+++++|------| <- weight\n     * ==[1]====#=====[2]---(3)----(4)\n     *          ^ output contents\n     *\n     * 1:_previousRigOutputs\n     * 2:_currentRigOutputs\n     * 3:_currentRemainTime (now rendering)\n     * 4:next particles timing\n     * @param model 物理演算の結果を適用するモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    evaluate(model, deltaTimeSeconds) {\n        var _a, _b, _c, _d;\n        let totalAngle;\n        let weight;\n        let radAngle;\n        let outputValue;\n        const totalTranslation = new cubismvector2_1.CubismVector2();\n        let currentSetting;\n        let currentInputs;\n        let currentOutputs;\n        let currentParticles;\n        if (0.0 >= deltaTimeSeconds) {\n            return;\n        }\n        let parameterValues;\n        let parameterMaximumValues;\n        let parameterMinimumValues;\n        let parameterDefaultValues;\n        let physicsDeltaTime;\n        this._currentRemainTime += deltaTimeSeconds;\n        if (this._currentRemainTime > MaxDeltaTime) {\n            this._currentRemainTime = 0.0;\n        }\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        parameterDefaultValues = model.getModel().parameters.defaultValues;\n        if (((_b = (_a = this._parameterCaches) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) < model.getParameterCount()) {\n            this._parameterCaches = new Float32Array(model.getParameterCount());\n        }\n        if (((_d = (_c = this._parameterInputCaches) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < model.getParameterCount()) {\n            this._parameterInputCaches = new Float32Array(model.getParameterCount());\n            for (let j = 0; j < model.getParameterCount(); ++j) {\n                this._parameterInputCaches[j] = parameterValues[j];\n            }\n        }\n        if (this._physicsRig.fps > 0.0) {\n            physicsDeltaTime = 1.0 / this._physicsRig.fps;\n        }\n        else {\n            physicsDeltaTime = deltaTimeSeconds;\n        }\n        while (this._currentRemainTime >= physicsDeltaTime) {\n            // copyRigOutputs _currentRigOutputs to _previousRigOutputs\n            for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n                currentSetting = this._physicsRig.settings.at(settingIndex);\n                currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n                for (let i = 0; i < currentSetting.outputCount; ++i) {\n                    this._previousRigOutputs\n                        .at(settingIndex)\n                        .outputs.set(i, this._currentRigOutputs.at(settingIndex).outputs.at(i));\n                }\n            }\n            // 入力キャッシュとパラメータで線形補間してUpdateParticlesするタイミングでの入力を計算する。\n            // Calculate the input at the timing to UpdateParticles by linear interpolation with the _parameterInputCache and parameterValue.\n            // _parameterCacheはグループ間での値の伝搬の役割があるので_parameterInputCacheとの分離が必要。\n            // _parameterCache needs to be separated from _parameterInputCache because of its role in propagating values between groups.\n            const inputWeight = physicsDeltaTime / this._currentRemainTime;\n            for (let j = 0; j < model.getParameterCount(); ++j) {\n                this._parameterCaches[j] =\n                    this._parameterInputCaches[j] * (1.0 - inputWeight) +\n                        parameterValues[j] * inputWeight;\n                this._parameterInputCaches[j] = this._parameterCaches[j];\n            }\n            for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n                totalAngle = { angle: 0.0 };\n                totalTranslation.x = 0.0;\n                totalTranslation.y = 0.0;\n                currentSetting = this._physicsRig.settings.at(settingIndex);\n                currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n                currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n                currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n                // Load input parameters\n                for (let i = 0; i < currentSetting.inputCount; ++i) {\n                    weight = currentInputs[i].weight / MaximumWeight;\n                    if (currentInputs[i].sourceParameterIndex == -1) {\n                        currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n                    }\n                    currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, this._parameterCaches[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n                }\n                radAngle = cubismmath_1.CubismMath.degreesToRadian(-totalAngle.angle);\n                totalTranslation.x =\n                    totalTranslation.x * cubismmath_1.CubismMath.cos(radAngle) -\n                        totalTranslation.y * cubismmath_1.CubismMath.sin(radAngle);\n                totalTranslation.y =\n                    totalTranslation.x * cubismmath_1.CubismMath.sin(radAngle) +\n                        totalTranslation.y * cubismmath_1.CubismMath.cos(radAngle);\n                // Calculate particles position.\n                updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, physicsDeltaTime, AirResistance);\n                // Update output parameters.\n                for (let i = 0; i < currentSetting.outputCount; ++i) {\n                    const particleIndex = currentOutputs[i].vertexIndex;\n                    if (currentOutputs[i].destinationParameterIndex == -1) {\n                        currentOutputs[i].destinationParameterIndex =\n                            model.getParameterIndex(currentOutputs[i].destination.id);\n                    }\n                    if (particleIndex < 1 ||\n                        particleIndex >= currentSetting.particleCount) {\n                        continue;\n                    }\n                    const translation = new cubismvector2_1.CubismVector2();\n                    translation.x =\n                        currentParticles[particleIndex].position.x -\n                            currentParticles[particleIndex - 1].position.x;\n                    translation.y =\n                        currentParticles[particleIndex].position.y -\n                            currentParticles[particleIndex - 1].position.y;\n                    outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n                    this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n                    const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                    const outParameterCaches = !Float32Array.prototype.slice &&\n                        'subarray' in Float32Array.prototype\n                        ? JSON.parse(JSON.stringify(this._parameterCaches.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                        : this._parameterCaches.slice(destinationParameterIndex);\n                    updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n                    // 値を反映\n                    for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n                        this._parameterCaches[offset] = outParameterCaches[outParamIndex];\n                    }\n                }\n            }\n            this._currentRemainTime -= physicsDeltaTime;\n        }\n        const alpha = this._currentRemainTime / physicsDeltaTime;\n        this.interpolate(model, alpha);\n    }\n    /**\n     * 物理演算結果の適用\n     * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。\n     * @param model 物理演算の結果を適用するモデル\n     * @param weight 最新結果の重み\n     */\n    interpolate(model, weight) {\n        let currentOutputs;\n        let currentSetting;\n        let parameterValues;\n        let parameterMaximumValues;\n        let parameterMinimumValues;\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n            // Load input parameters.\n            for (let i = 0; i < currentSetting.outputCount; ++i) {\n                if (currentOutputs[i].destinationParameterIndex == -1) {\n                    continue;\n                }\n                const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                const outParameterValues = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n                    ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                    : parameterValues.slice(destinationParameterIndex);\n                updateOutputParameterValue(outParameterValues, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], this._previousRigOutputs.at(settingIndex).outputs.at(i) *\n                    (1 - weight) +\n                    this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight, currentOutputs[i]);\n                // 値を反映\n                for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValues.length; offset++, outParamIndex++) {\n                    parameterValues[offset] = outParameterValues[outParamIndex];\n                }\n            }\n        }\n    }\n    /**\n     * オプションの設定\n     * @param options オプション\n     */\n    setOptions(options) {\n        this._options = options;\n    }\n    /**\n     * オプションの取得\n     * @return オプション\n     */\n    getOption() {\n        return this._options;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._physicsRig = null;\n        // set default options\n        this._options = new Options();\n        this._options.gravity.y = -1.0;\n        this._options.gravity.x = 0.0;\n        this._options.wind.x = 0.0;\n        this._options.wind.y = 0.0;\n        this._currentRigOutputs = new csmvector_1.csmVector();\n        this._previousRigOutputs = new csmvector_1.csmVector();\n        this._currentRemainTime = 0.0;\n        this._parameterCaches = null;\n        this._parameterInputCaches = null;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        this._physicsRig = void 0;\n        this._physicsRig = null;\n    }\n    /**\n     * 初期化する\n     */\n    initialize() {\n        let strand;\n        let currentSetting;\n        let radius;\n        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n            // Initialize the top of particle.\n            strand[0].initialPosition = new cubismvector2_1.CubismVector2(0.0, 0.0);\n            strand[0].lastPosition = new cubismvector2_1.CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);\n            strand[0].lastGravity = new cubismvector2_1.CubismVector2(0.0, -1.0);\n            strand[0].lastGravity.y *= -1.0;\n            strand[0].velocity = new cubismvector2_1.CubismVector2(0.0, 0.0);\n            strand[0].force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n            // Initialize particles.\n            for (let i = 1; i < currentSetting.particleCount; ++i) {\n                radius = new cubismvector2_1.CubismVector2(0.0, 0.0);\n                radius.y = strand[i].radius;\n                strand[i].initialPosition = new cubismvector2_1.CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);\n                strand[i].position = new cubismvector2_1.CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n                strand[i].lastPosition = new cubismvector2_1.CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n                strand[i].lastGravity = new cubismvector2_1.CubismVector2(0.0, -1.0);\n                strand[i].lastGravity.y *= -1.0;\n                strand[i].velocity = new cubismvector2_1.CubismVector2(0.0, 0.0);\n                strand[i].force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n            }\n        }\n    }\n}\nexports.CubismPhysics = CubismPhysics;\n/**\n * 物理演算のオプション\n */\nclass Options {\n    constructor() {\n        this.gravity = new cubismvector2_1.CubismVector2(0, 0);\n        this.wind = new cubismvector2_1.CubismVector2(0, 0);\n    }\n}\nexports.Options = Options;\n/**\n * パラメータに適用する前の物理演算の出力結果\n */\nclass PhysicsOutput {\n    constructor() {\n        this.outputs = new csmvector_1.csmVector(0);\n    }\n}\nexports.PhysicsOutput = PhysicsOutput;\n/**\n * Gets sign.\n *\n * @param value Evaluation target value.\n *\n * @return Sign of value.\n */\nfunction sign(value) {\n    let ret = 0;\n    if (value > 0.0) {\n        ret = 1;\n    }\n    else if (value < 0.0) {\n        ret = -1;\n    }\n    return ret;\n}\nfunction getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.x +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.y +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {\n    targetAngle.angle +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;\n}\nfunction getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue = translation.x;\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue = translation.y;\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue;\n    if (particleIndex >= 2) {\n        parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);\n    }\n    else {\n        parentGravity = parentGravity.multiplyByScaler(-1.0);\n    }\n    outputValue = cubismmath_1.CubismMath.directionToRadian(parentGravity, translation);\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getRangeValue(min, max) {\n    const maxValue = cubismmath_1.CubismMath.max(min, max);\n    const minValue = cubismmath_1.CubismMath.min(min, max);\n    return cubismmath_1.CubismMath.abs(maxValue - minValue);\n}\nfunction getDefaultValue(min, max) {\n    const minValue = cubismmath_1.CubismMath.min(min, max);\n    return minValue + getRangeValue(min, max) / 2.0;\n}\nfunction getOutputScaleTranslationX(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.x));\n}\nfunction getOutputScaleTranslationY(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.y));\n}\nfunction getOutputScaleAngle(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(angleScale));\n}\n/**\n * Updates particles.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n * @param deltaTimeSeconds      Delta time.\n * @param airResistance         Air resistance.\n */\nfunction updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {\n    let totalRadian;\n    let delay;\n    let radian;\n    let currentGravity;\n    let direction = new cubismvector2_1.CubismVector2(0.0, 0.0);\n    let velocity = new cubismvector2_1.CubismVector2(0.0, 0.0);\n    let force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n    let newDirection = new cubismvector2_1.CubismVector2(0.0, 0.0);\n    strand[0].position = new cubismvector2_1.CubismVector2(totalTranslation.x, totalTranslation.y);\n    totalRadian = cubismmath_1.CubismMath.degreesToRadian(totalAngle);\n    currentGravity = cubismmath_1.CubismMath.radianToDirection(totalRadian);\n    currentGravity.normalize();\n    for (let i = 1; i < strandCount; ++i) {\n        strand[i].force = currentGravity\n            .multiplyByScaler(strand[i].acceleration)\n            .add(windDirection);\n        strand[i].lastPosition = new cubismvector2_1.CubismVector2(strand[i].position.x, strand[i].position.y);\n        delay = strand[i].delay * deltaTimeSeconds * 30.0;\n        direction = strand[i].position.substract(strand[i - 1].position);\n        radian =\n            cubismmath_1.CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) /\n                airResistance;\n        direction.x =\n            cubismmath_1.CubismMath.cos(radian) * direction.x -\n                direction.y * cubismmath_1.CubismMath.sin(radian);\n        direction.y =\n            cubismmath_1.CubismMath.sin(radian) * direction.x +\n                direction.y * cubismmath_1.CubismMath.cos(radian);\n        strand[i].position = strand[i - 1].position.add(direction);\n        velocity = strand[i].velocity.multiplyByScaler(delay);\n        force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n        strand[i].position = strand[i].position.add(velocity).add(force);\n        newDirection = strand[i].position.substract(strand[i - 1].position);\n        newDirection.normalize();\n        strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));\n        if (cubismmath_1.CubismMath.abs(strand[i].position.x) < thresholdValue) {\n            strand[i].position.x = 0.0;\n        }\n        if (delay != 0.0) {\n            strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n            strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n            strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);\n        }\n        strand[i].force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n        strand[i].lastGravity = new cubismvector2_1.CubismVector2(currentGravity.x, currentGravity.y);\n    }\n}\n/**\n * Updates particles for stabilization.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n */\nfunction updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {\n    let totalRadian;\n    let currentGravity;\n    let force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n    strand[0].position = new cubismvector2_1.CubismVector2(totalTranslation.x, totalTranslation.y);\n    totalRadian = cubismmath_1.CubismMath.degreesToRadian(totalAngle);\n    currentGravity = cubismmath_1.CubismMath.radianToDirection(totalRadian);\n    currentGravity.normalize();\n    for (let i = 1; i < strandCount; ++i) {\n        strand[i].force = currentGravity\n            .multiplyByScaler(strand[i].acceleration)\n            .add(windDirection);\n        strand[i].lastPosition = new cubismvector2_1.CubismVector2(strand[i].position.x, strand[i].position.y);\n        strand[i].velocity = new cubismvector2_1.CubismVector2(0.0, 0.0);\n        force = strand[i].force;\n        force.normalize();\n        force = force.multiplyByScaler(strand[i].radius);\n        strand[i].position = strand[i - 1].position.add(force);\n        if (cubismmath_1.CubismMath.abs(strand[i].position.x) < thresholdValue) {\n            strand[i].position.x = 0.0;\n        }\n        strand[i].force = new cubismvector2_1.CubismVector2(0.0, 0.0);\n        strand[i].lastGravity = new cubismvector2_1.CubismVector2(currentGravity.x, currentGravity.y);\n    }\n}\n/**\n * Updates output parameter value.\n * @param parameterValue            Target parameter value.\n * @param parameterValueMinimum     Minimum of parameter value.\n * @param parameterValueMaximum     Maximum of parameter value.\n * @param translation               Translation value.\n */\nfunction updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {\n    let outputScale;\n    let value;\n    let weight;\n    outputScale = output.getScale(output.translationScale, output.angleScale);\n    value = translation * outputScale;\n    if (value < parameterValueMinimum) {\n        if (value < output.valueBelowMinimum) {\n            output.valueBelowMinimum = value;\n        }\n        value = parameterValueMinimum;\n    }\n    else if (value > parameterValueMaximum) {\n        if (value > output.valueExceededMaximum) {\n            output.valueExceededMaximum = value;\n        }\n        value = parameterValueMaximum;\n    }\n    weight = output.weight / MaximumWeight;\n    if (weight >= 1.0) {\n        parameterValue[0] = value;\n    }\n    else {\n        value = parameterValue[0] * (1.0 - weight) + value * weight;\n        parameterValue[0] = value;\n    }\n}\nfunction normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {\n    let result = 0.0;\n    const maxValue = cubismmath_1.CubismMath.max(parameterMaximum, parameterMinimum);\n    if (maxValue < value) {\n        value = maxValue;\n    }\n    const minValue = cubismmath_1.CubismMath.min(parameterMaximum, parameterMinimum);\n    if (minValue > value) {\n        value = minValue;\n    }\n    const minNormValue = cubismmath_1.CubismMath.min(normalizedMinimum, normalizedMaximum);\n    const maxNormValue = cubismmath_1.CubismMath.max(normalizedMinimum, normalizedMaximum);\n    const middleNormValue = normalizedDefault;\n    const middleValue = getDefaultValue(minValue, maxValue);\n    const paramValue = value - middleValue;\n    switch (sign(paramValue)) {\n        case 1: {\n            const nLength = maxNormValue - middleNormValue;\n            const pLength = maxValue - middleValue;\n            if (pLength != 0.0) {\n                result = paramValue * (nLength / pLength);\n                result += middleNormValue;\n            }\n            break;\n        }\n        case -1: {\n            const nLength = minNormValue - middleNormValue;\n            const pLength = minValue - middleValue;\n            if (pLength != 0.0) {\n                result = paramValue * (nLength / pLength);\n                result += middleNormValue;\n            }\n            break;\n        }\n        case 0: {\n            result = middleNormValue;\n            break;\n        }\n        default: {\n            break;\n        }\n    }\n    return isInverted ? result : result * -1.0;\n}\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismphysics */ \"./cubism/Framework/src/physics/cubismphysics.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysics = $.CubismPhysics;\n    Live2DCubismFramework.Options = $.Options;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/physics/cubismphysics.ts?");

/***/ }),

/***/ "./cubism/Framework/src/physics/cubismphysicsinternal.ts":
/*!***************************************************************!*\
  !*** ./cubism/Framework/src/physics/cubismphysicsinternal.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismPhysicsRig = exports.CubismPhysicsOutput = exports.CubismPhysicsInput = exports.CubismPhysicsSubRig = exports.CubismPhysicsParticle = exports.CubismPhysicsNormalization = exports.CubismPhysicsParameter = exports.PhysicsJsonEffectiveForces = exports.CubismPhysicsSource = exports.CubismPhysicsTargetType = void 0;\nconst cubismvector2_1 = __webpack_require__(/*! ../math/cubismvector2 */ \"./cubism/Framework/src/math/cubismvector2.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\n/**\n * 物理演算の適用先の種類\n */\nvar CubismPhysicsTargetType;\n(function (CubismPhysicsTargetType) {\n    CubismPhysicsTargetType[CubismPhysicsTargetType[\"CubismPhysicsTargetType_Parameter\"] = 0] = \"CubismPhysicsTargetType_Parameter\";\n})(CubismPhysicsTargetType || (exports.CubismPhysicsTargetType = CubismPhysicsTargetType = {}));\n/**\n * 物理演算の入力の種類\n */\nvar CubismPhysicsSource;\n(function (CubismPhysicsSource) {\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_X\"] = 0] = \"CubismPhysicsSource_X\";\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_Y\"] = 1] = \"CubismPhysicsSource_Y\";\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_Angle\"] = 2] = \"CubismPhysicsSource_Angle\";\n})(CubismPhysicsSource || (exports.CubismPhysicsSource = CubismPhysicsSource = {}));\n/**\n * @brief 物理演算で使用する外部の力\n *\n * 物理演算で使用する外部の力。\n */\nclass PhysicsJsonEffectiveForces {\n    constructor() {\n        this.gravity = new cubismvector2_1.CubismVector2(0, 0);\n        this.wind = new cubismvector2_1.CubismVector2(0, 0);\n    }\n}\nexports.PhysicsJsonEffectiveForces = PhysicsJsonEffectiveForces;\n/**\n * 物理演算のパラメータ情報\n */\nclass CubismPhysicsParameter {\n}\nexports.CubismPhysicsParameter = CubismPhysicsParameter;\n/**\n * 物理演算の正規化情報\n */\nclass CubismPhysicsNormalization {\n}\nexports.CubismPhysicsNormalization = CubismPhysicsNormalization;\n/**\n * 物理演算の演算委使用する物理点の情報\n */\nclass CubismPhysicsParticle {\n    constructor() {\n        this.initialPosition = new cubismvector2_1.CubismVector2(0, 0);\n        this.position = new cubismvector2_1.CubismVector2(0, 0);\n        this.lastPosition = new cubismvector2_1.CubismVector2(0, 0);\n        this.lastGravity = new cubismvector2_1.CubismVector2(0, 0);\n        this.force = new cubismvector2_1.CubismVector2(0, 0);\n        this.velocity = new cubismvector2_1.CubismVector2(0, 0);\n    }\n}\nexports.CubismPhysicsParticle = CubismPhysicsParticle;\n/**\n * 物理演算の物理点の管理\n */\nclass CubismPhysicsSubRig {\n    constructor() {\n        this.normalizationPosition = new CubismPhysicsNormalization();\n        this.normalizationAngle = new CubismPhysicsNormalization();\n    }\n}\nexports.CubismPhysicsSubRig = CubismPhysicsSubRig;\n/**\n * 物理演算の入力情報\n */\nclass CubismPhysicsInput {\n    constructor() {\n        this.source = new CubismPhysicsParameter();\n    }\n}\nexports.CubismPhysicsInput = CubismPhysicsInput;\n/**\n * @brief 物理演算の出力情報\n *\n * 物理演算の出力情報。\n */\nclass CubismPhysicsOutput {\n    constructor() {\n        this.destination = new CubismPhysicsParameter();\n        this.translationScale = new cubismvector2_1.CubismVector2(0, 0);\n    }\n}\nexports.CubismPhysicsOutput = CubismPhysicsOutput;\n/**\n * @brief 物理演算のデータ\n *\n * 物理演算のデータ。\n */\nclass CubismPhysicsRig {\n    constructor() {\n        this.settings = new csmvector_1.csmVector();\n        this.inputs = new csmvector_1.csmVector();\n        this.outputs = new csmvector_1.csmVector();\n        this.particles = new csmvector_1.csmVector();\n        this.gravity = new cubismvector2_1.CubismVector2(0, 0);\n        this.wind = new cubismvector2_1.CubismVector2(0, 0);\n        this.fps = 0.0;\n    }\n}\nexports.CubismPhysicsRig = CubismPhysicsRig;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismphysicsinternal */ \"./cubism/Framework/src/physics/cubismphysicsinternal.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysicsInput = $.CubismPhysicsInput;\n    Live2DCubismFramework.CubismPhysicsNormalization = $.CubismPhysicsNormalization;\n    Live2DCubismFramework.CubismPhysicsOutput = $.CubismPhysicsOutput;\n    Live2DCubismFramework.CubismPhysicsParameter = $.CubismPhysicsParameter;\n    Live2DCubismFramework.CubismPhysicsParticle = $.CubismPhysicsParticle;\n    Live2DCubismFramework.CubismPhysicsRig = $.CubismPhysicsRig;\n    Live2DCubismFramework.CubismPhysicsSource = $.CubismPhysicsSource;\n    Live2DCubismFramework.CubismPhysicsSubRig = $.CubismPhysicsSubRig;\n    Live2DCubismFramework.CubismPhysicsTargetType = $.CubismPhysicsTargetType;\n    Live2DCubismFramework.PhysicsJsonEffectiveForces = $.PhysicsJsonEffectiveForces;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/physics/cubismphysicsinternal.ts?");

/***/ }),

/***/ "./cubism/Framework/src/physics/cubismphysicsjson.ts":
/*!***********************************************************!*\
  !*** ./cubism/Framework/src/physics/cubismphysicsjson.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismPhysicsJson = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismvector2_1 = __webpack_require__(/*! ../math/cubismvector2 */ \"./cubism/Framework/src/math/cubismvector2.ts\");\nconst cubismjson_1 = __webpack_require__(/*! ../utils/cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\n// JSON keys\nconst Position = 'Position';\nconst X = 'X';\nconst Y = 'Y';\nconst Angle = 'Angle';\nconst Type = 'Type';\nconst Id = 'Id';\n// Meta\nconst Meta = 'Meta';\nconst EffectiveForces = 'EffectiveForces';\nconst TotalInputCount = 'TotalInputCount';\nconst TotalOutputCount = 'TotalOutputCount';\nconst PhysicsSettingCount = 'PhysicsSettingCount';\nconst Gravity = 'Gravity';\nconst Wind = 'Wind';\nconst VertexCount = 'VertexCount';\nconst Fps = 'Fps';\n// PhysicsSettings\nconst PhysicsSettings = 'PhysicsSettings';\nconst Normalization = 'Normalization';\nconst Minimum = 'Minimum';\nconst Maximum = 'Maximum';\nconst Default = 'Default';\nconst Reflect = 'Reflect';\nconst Weight = 'Weight';\n// Input\nconst Input = 'Input';\nconst Source = 'Source';\n// Output\nconst Output = 'Output';\nconst Scale = 'Scale';\nconst VertexIndex = 'VertexIndex';\nconst Destination = 'Destination';\n// Particle\nconst Vertices = 'Vertices';\nconst Mobility = 'Mobility';\nconst Delay = 'Delay';\nconst Radius = 'Radius';\nconst Acceleration = 'Acceleration';\n/**\n * physics3.jsonのコンテナ。\n */\nclass CubismPhysicsJson {\n    /**\n     * コンストラクタ\n     * @param buffer physics3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    constructor(buffer, size) {\n        this._json = cubismjson_1.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        cubismjson_1.CubismJson.delete(this._json);\n    }\n    /**\n     * 重力の取得\n     * @return 重力\n     */\n    getGravity() {\n        const ret = new cubismvector2_1.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Gravity)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Gravity)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    }\n    /**\n     * 風の取得\n     * @return 風\n     */\n    getWind() {\n        const ret = new cubismvector2_1.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Wind)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Wind)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    }\n    /**\n     * 物理演算設定FPSの取得\n     * @return 物理演算設定FPS\n     */\n    getFps() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Fps)\n            .toFloat(0.0);\n    }\n    /**\n     * 物理店の管理の個数の取得\n     * @return 物理店の管理の個数\n     */\n    getSubRigCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(PhysicsSettingCount)\n            .toInt();\n    }\n    /**\n     * 入力の総合計の取得\n     * @return 入力の総合計\n     */\n    getTotalInputCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalInputCount)\n            .toInt();\n    }\n    /**\n     * 出力の総合計の取得\n     * @return 出力の総合計\n     */\n    getTotalOutputCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalOutputCount)\n            .toInt();\n    }\n    /**\n     * 物理点の個数の取得\n     * @return 物理点の個数\n     */\n    getVertexCount() {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(VertexCount)\n            .toInt();\n    }\n    /**\n     * 正規化された位置の最小値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置の最小値\n     */\n    getNormalizationPositionMinimumValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Minimum)\n            .toFloat();\n    }\n    /**\n     * 正規化された位置の最大値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置の最大値\n     */\n    getNormalizationPositionMaximumValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Maximum)\n            .toFloat();\n    }\n    /**\n     * 正規化された位置のデフォルト値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置のデフォルト値\n     */\n    getNormalizationPositionDefaultValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Default)\n            .toFloat();\n    }\n    /**\n     * 正規化された角度の最小値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された角度の最小値\n     */\n    getNormalizationAngleMinimumValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Minimum)\n            .toFloat();\n    }\n    /**\n     * 正規化された角度の最大値の取得\n     * @param physicsSettingIndex\n     * @return 正規化された角度の最大値\n     */\n    getNormalizationAngleMaximumValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Maximum)\n            .toFloat();\n    }\n    /**\n     * 正規化された角度のデフォルト値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された角度のデフォルト値\n     */\n    getNormalizationAngleDefaultValue(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Default)\n            .toFloat();\n    }\n    /**\n     * 入力の個数の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 入力の個数\n     */\n    getInputCount(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getVector()\n            .getSize();\n    }\n    /**\n     * 入力の重みの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の重み\n     */\n    getInputWeight(physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Weight)\n            .toFloat();\n    }\n    /**\n     * 入力の反転の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の反転\n     */\n    getInputReflect(physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Reflect)\n            .toBoolean();\n    }\n    /**\n     * 入力の種類の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の種類\n     */\n    getInputType(physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Type)\n            .getRawString();\n    }\n    /**\n     * 入力元のIDの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力元のID\n     */\n    getInputSourceId(physicsSettingIndex, inputIndex) {\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Source)\n            .getValueByString(Id)\n            .getRawString());\n    }\n    /**\n     * 出力の個数の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 出力の個数\n     */\n    getOutputCount(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getVector()\n            .getSize();\n    }\n    /**\n     * 出力の物理点のインデックスの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の物理点のインデックス\n     */\n    getOutputVertexIndex(physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(VertexIndex)\n            .toInt();\n    }\n    /**\n     * 出力の角度のスケールを取得する\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の角度のスケール\n     */\n    getOutputAngleScale(physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Scale)\n            .toFloat();\n    }\n    /**\n     * 出力の重みの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の重み\n     */\n    getOutputWeight(physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Weight)\n            .toFloat();\n    }\n    /**\n     * 出力先のIDの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力先のID\n     */\n    getOutputDestinationId(physicsSettingIndex, outputIndex) {\n        return live2dcubismframework_1.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Destination)\n            .getValueByString(Id)\n            .getRawString());\n    }\n    /**\n     * 出力の種類の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の種類\n     */\n    getOutputType(physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Type)\n            .getRawString();\n    }\n    /**\n     * 出力の反転の取得\n     * @param physicsSettingIndex 物理演算のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の反転\n     */\n    getOutputReflect(physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Reflect)\n            .toBoolean();\n    }\n    /**\n     * 物理点の個数の取得\n     * @param physicsSettingIndex 物理演算男設定のインデックス\n     * @return 物理点の個数\n     */\n    getParticleCount(physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getVector()\n            .getSize();\n    }\n    /**\n     * 物理点の動きやすさの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の動きやすさ\n     */\n    getParticleMobility(physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Mobility)\n            .toFloat();\n    }\n    /**\n     * 物理点の遅れの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の遅れ\n     */\n    getParticleDelay(physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Delay)\n            .toFloat();\n    }\n    /**\n     * 物理点の加速度の取得\n     * @param physicsSettingIndex 物理演算の設定\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の加速度\n     */\n    getParticleAcceleration(physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Acceleration)\n            .toFloat();\n    }\n    /**\n     * 物理点の距離の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の距離\n     */\n    getParticleRadius(physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Radius)\n            .toFloat();\n    }\n    /**\n     * 物理点の位置の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexInde 物理点のインデックス\n     * @return 物理点の位置\n     */\n    getParticlePosition(physicsSettingIndex, vertexIndex) {\n        const ret = new cubismvector2_1.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Position)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Position)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    }\n}\nexports.CubismPhysicsJson = CubismPhysicsJson;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismphysicsjson */ \"./cubism/Framework/src/physics/cubismphysicsjson.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysicsJson = $.CubismPhysicsJson;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/physics/cubismphysicsjson.ts?");

/***/ }),

/***/ "./cubism/Framework/src/rendering/cubismrenderer.ts":
/*!**********************************************************!*\
  !*** ./cubism/Framework/src/rendering/cubismrenderer.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismTextureColor = exports.CubismBlendMode = exports.CubismRenderer = void 0;\nconst cubismmatrix44_1 = __webpack_require__(/*! ../math/cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\n/**\n * モデル描画を処理するレンダラ\n *\n * サブクラスに環境依存の描画命令を記述する。\n */\nclass CubismRenderer {\n    /**\n     * レンダラのインスタンスを生成して取得する\n     *\n     * @return レンダラのインスタンス\n     */\n    static create() {\n        return null;\n    }\n    /**\n     * レンダラのインスタンスを解放する\n     */\n    static delete(renderer) {\n        renderer = null;\n    }\n    /**\n     * レンダラの初期化処理を実行する\n     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n     * @param model モデルのインスタンス\n     */\n    initialize(model) {\n        this._model = model;\n    }\n    /**\n     * モデルを描画する\n     */\n    drawModel() {\n        if (this.getModel() == null)\n            return;\n        this.saveProfile();\n        this.doDrawModel();\n        this.restoreProfile();\n    }\n    /**\n     * Model-View-Projection 行列をセットする\n     * 配列は複製されるので、元の配列は外で破棄して良い\n     * @param matrix44 Model-View-Projection 行列\n     */\n    setMvpMatrix(matrix44) {\n        this._mvpMatrix4x4.setMatrix(matrix44.getArray());\n    }\n    /**\n     * Model-View-Projection 行列を取得する\n     * @return Model-View-Projection 行列\n     */\n    getMvpMatrix() {\n        return this._mvpMatrix4x4;\n    }\n    /**\n     * モデルの色をセットする\n     * 各色0.0~1.0の間で指定する（1.0が標準の状態）\n     * @param red 赤チャンネルの値\n     * @param green 緑チャンネルの値\n     * @param blue 青チャンネルの値\n     * @param alpha αチャンネルの値\n     */\n    setModelColor(red, green, blue, alpha) {\n        if (red < 0.0) {\n            red = 0.0;\n        }\n        else if (red > 1.0) {\n            red = 1.0;\n        }\n        if (green < 0.0) {\n            green = 0.0;\n        }\n        else if (green > 1.0) {\n            green = 1.0;\n        }\n        if (blue < 0.0) {\n            blue = 0.0;\n        }\n        else if (blue > 1.0) {\n            blue = 1.0;\n        }\n        if (alpha < 0.0) {\n            alpha = 0.0;\n        }\n        else if (alpha > 1.0) {\n            alpha = 1.0;\n        }\n        this._modelColor.R = red;\n        this._modelColor.G = green;\n        this._modelColor.B = blue;\n        this._modelColor.A = alpha;\n    }\n    /**\n     * モデルの色を取得する\n     * 各色0.0~1.0の間で指定する(1.0が標準の状態)\n     *\n     * @return RGBAのカラー情報\n     */\n    getModelColor() {\n        return JSON.parse(JSON.stringify(this._modelColor));\n    }\n    /**\n     * 乗算済みαの有効・無効をセットする\n     * 有効にするならtrue、無効にするならfalseをセットする\n     */\n    setIsPremultipliedAlpha(enable) {\n        this._isPremultipliedAlpha = enable;\n    }\n    /**\n     * 乗算済みαの有効・無効を取得する\n     * @return true 乗算済みのα有効\n     * @return false 乗算済みのα無効\n     */\n    isPremultipliedAlpha() {\n        return this._isPremultipliedAlpha;\n    }\n    /**\n     * カリング（片面描画）の有効・無効をセットする。\n     * 有効にするならtrue、無効にするならfalseをセットする\n     */\n    setIsCulling(culling) {\n        this._isCulling = culling;\n    }\n    /**\n     * カリング（片面描画）の有効・無効を取得する。\n     * @return true カリング有効\n     * @return false カリング無効\n     */\n    isCulling() {\n        return this._isCulling;\n    }\n    /**\n     * テクスチャの異方性フィルタリングのパラメータをセットする\n     * パラメータ値の影響度はレンダラの実装に依存する\n     * @param n パラメータの値\n     */\n    setAnisotropy(n) {\n        this._anisotropy = n;\n    }\n    /**\n     * テクスチャの異方性フィルタリングのパラメータをセットする\n     * @return 異方性フィルタリングのパラメータ\n     */\n    getAnisotropy() {\n        return this._anisotropy;\n    }\n    /**\n     * レンダリングするモデルを取得する\n     * @return レンダリングするモデル\n     */\n    getModel() {\n        return this._model;\n    }\n    /**\n     * マスク描画の方式を変更する。\n     * falseの場合、マスクを1枚のテクスチャに分割してレンダリングする（デフォルト）\n     * 高速だが、マスク個数の上限が36に限定され、質も荒くなる\n     * trueの場合、パーツ描画の前にその都度必要なマスクを描き直す\n     * レンダリング品質は高いが描画処理負荷は増す\n     * @param high 高精細マスクに切り替えるか？\n     */\n    useHighPrecisionMask(high) {\n        this._useHighPrecisionMask = high;\n    }\n    /**\n     * マスクの描画方式を取得する\n     * @return true 高精細方式\n     * @return false デフォルト\n     */\n    isUsingHighPrecisionMask() {\n        return this._useHighPrecisionMask;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._isCulling = false;\n        this._isPremultipliedAlpha = false;\n        this._anisotropy = 0.0;\n        this._model = null;\n        this._modelColor = new CubismTextureColor();\n        this._useHighPrecisionMask = false;\n        // 単位行列に初期化\n        this._mvpMatrix4x4 = new cubismmatrix44_1.CubismMatrix44();\n        this._mvpMatrix4x4.loadIdentity();\n    }\n}\nexports.CubismRenderer = CubismRenderer;\nvar CubismBlendMode;\n(function (CubismBlendMode) {\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Normal\"] = 0] = \"CubismBlendMode_Normal\";\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Additive\"] = 1] = \"CubismBlendMode_Additive\";\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Multiplicative\"] = 2] = \"CubismBlendMode_Multiplicative\";\n})(CubismBlendMode || (exports.CubismBlendMode = CubismBlendMode = {}));\n/**\n * テクスチャの色をRGBAで扱うためのクラス\n */\nclass CubismTextureColor {\n    /**\n     * コンストラクタ\n     */\n    constructor(r = 1.0, g = 1.0, b = 1.0, a = 1.0) {\n        this.R = r;\n        this.G = g;\n        this.B = b;\n        this.A = a;\n    }\n}\nexports.CubismTextureColor = CubismTextureColor;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismrenderer */ \"./cubism/Framework/src/rendering/cubismrenderer.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismBlendMode = $.CubismBlendMode;\n    Live2DCubismFramework.CubismRenderer = $.CubismRenderer;\n    Live2DCubismFramework.CubismTextureColor = $.CubismTextureColor;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/rendering/cubismrenderer.ts?");

/***/ }),

/***/ "./cubism/Framework/src/rendering/cubismrenderer_webgl.ts":
/*!****************************************************************!*\
  !*** ./cubism/Framework/src/rendering/cubismrenderer_webgl.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismRenderer_WebGL = exports.fragmentShaderSrcMaskInvertedPremultipliedAlpha = exports.fragmentShaderSrcMaskPremultipliedAlpha = exports.fragmentShaderSrcPremultipliedAlpha = exports.vertexShaderSrcMasked = exports.vertexShaderSrc = exports.fragmentShaderSrcsetupMask = exports.vertexShaderSrcSetupMask = exports.ShaderNames = exports.CubismShaderSet = exports.CubismShader_WebGL = exports.CubismRendererProfile_WebGL = exports.CubismClippingContext = exports.CubismRenderTextureResource = exports.CubismClippingManager_WebGL = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismmatrix44_1 = __webpack_require__(/*! ../math/cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\nconst csmmap_1 = __webpack_require__(/*! ../type/csmmap */ \"./cubism/Framework/src/type/csmmap.ts\");\nconst csmrectf_1 = __webpack_require__(/*! ../type/csmrectf */ \"./cubism/Framework/src/type/csmrectf.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst cubismrenderer_1 = __webpack_require__(/*! ./cubismrenderer */ \"./cubism/Framework/src/rendering/cubismrenderer.ts\");\nconst ColorChannelCount = 4; // 実験時に1チャンネルの場合は1、RGBだけの場合は3、アルファも含める場合は4\nconst ClippingMaskMaxCountOnDefault = 36; // 通常のフレームバッファ一枚あたりのマスク最大数\nconst ClippingMaskMaxCountOnMultiRenderTexture = 32; // フレームバッファが2枚以上ある場合のフレームバッファ一枚あたりのマスク最大数\nconst ShaderCount = 10; // シェーダーの数 = マスク生成用 + (通常用 + 加算 + 乗算) * (マスク無の乗算済アルファ対応版 + マスク有の乗算済アルファ対応版 + マスク有反転の乗算済アルファ対応版)\nlet s_instance;\nlet s_viewport;\nlet s_fbo;\n/**\n * クリッピングマスクの処理を実行するクラス\n */\nclass CubismClippingManager_WebGL {\n    /**\n     * カラーチャンネル（RGBA）のフラグを取得する\n     * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）\n     */\n    getChannelFlagAsColor(channelNo) {\n        return this._channelColors.at(channelNo);\n    }\n    /**\n     * テンポラリのレンダーテクスチャのアドレスを取得する\n     * FrameBufferObjectが存在しない場合、新しく生成する\n     *\n     * @return レンダーテクスチャの配列\n     */\n    getMaskRenderTexture() {\n        // テンポラリのRenderTextureを取得する\n        if (this._maskTexture && this._maskTexture.textures != null) {\n            // 前回使ったものを返す\n            this._maskTexture.frameNo = this._currentFrameNo;\n        }\n        else {\n            // FrameBufferObjectが存在しない場合、新しく生成する\n            if (this._maskRenderTextures != null) {\n                this._maskRenderTextures.clear();\n            }\n            this._maskRenderTextures = new csmvector_1.csmVector();\n            // ColorBufferObjectが存在しない場合、新しく生成する\n            if (this._maskColorBuffers != null) {\n                this._maskColorBuffers.clear();\n            }\n            this._maskColorBuffers = new csmvector_1.csmVector();\n            // クリッピングバッファサイズを取得\n            const size = this._clippingMaskBufferSize;\n            for (let index = 0; index < this._renderTextureCount; index++) {\n                this._maskColorBuffers.pushBack(this.gl.createTexture()); // 直接代入\n                this.gl.bindTexture(this.gl.TEXTURE_2D, this._maskColorBuffers.at(index));\n                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n                this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n                this._maskRenderTextures.pushBack(this.gl.createFramebuffer());\n                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTextures.at(index));\n                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._maskColorBuffers.at(index), 0);\n            }\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n            this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, this._maskRenderTextures);\n        }\n        return this._maskTexture.textures;\n    }\n    /**\n     * WebGLレンダリングコンテキストを設定する\n     * @param gl WebGLレンダリングコンテキスト\n     */\n    setGL(gl) {\n        this.gl = gl;\n    }\n    /**\n     * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する\n     * @param model モデルのインスタンス\n     * @param clippingContext クリッピングマスクのコンテキスト\n     */\n    calcClippedDrawTotalBounds(model, clippingContext) {\n        // 被クリッピングマスク（マスクされる描画オブジェクト）の全体の矩形\n        let clippedDrawTotalMinX = Number.MAX_VALUE;\n        let clippedDrawTotalMinY = Number.MAX_VALUE;\n        let clippedDrawTotalMaxX = Number.MIN_VALUE;\n        let clippedDrawTotalMaxY = Number.MIN_VALUE;\n        // このマスクが実際に必要か判定する\n        // このクリッピングを利用する「描画オブジェクト」がひとつでも使用可能であればマスクを生成する必要がある\n        const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;\n        for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {\n            // マスクを使用する描画オブジェクトの描画される矩形を求める\n            const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];\n            const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);\n            const drawableVertexes = model.getDrawableVertices(drawableIndex);\n            let minX = Number.MAX_VALUE;\n            let minY = Number.MAX_VALUE;\n            let maxX = -Number.MAX_VALUE;\n            let maxY = -Number.MAX_VALUE;\n            const loop = drawableVertexCount * live2dcubismframework_1.Constant.vertexStep;\n            for (let pi = live2dcubismframework_1.Constant.vertexOffset; pi < loop; pi += live2dcubismframework_1.Constant.vertexStep) {\n                const x = drawableVertexes[pi];\n                const y = drawableVertexes[pi + 1];\n                if (x < minX) {\n                    minX = x;\n                }\n                if (x > maxX) {\n                    maxX = x;\n                }\n                if (y < minY) {\n                    minY = y;\n                }\n                if (y > maxY) {\n                    maxY = y;\n                }\n            }\n            // 有効な点が一つも取れなかったのでスキップ\n            if (minX == Number.MAX_VALUE) {\n                continue;\n            }\n            // 全体の矩形に反映\n            if (minX < clippedDrawTotalMinX) {\n                clippedDrawTotalMinX = minX;\n            }\n            if (minY < clippedDrawTotalMinY) {\n                clippedDrawTotalMinY = minY;\n            }\n            if (maxX > clippedDrawTotalMaxX) {\n                clippedDrawTotalMaxX = maxX;\n            }\n            if (maxY > clippedDrawTotalMaxY) {\n                clippedDrawTotalMaxY = maxY;\n            }\n            if (clippedDrawTotalMinX == Number.MAX_VALUE) {\n                clippingContext._allClippedDrawRect.x = 0.0;\n                clippingContext._allClippedDrawRect.y = 0.0;\n                clippingContext._allClippedDrawRect.width = 0.0;\n                clippingContext._allClippedDrawRect.height = 0.0;\n                clippingContext._isUsing = false;\n            }\n            else {\n                clippingContext._isUsing = true;\n                const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;\n                const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;\n                clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;\n                clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;\n                clippingContext._allClippedDrawRect.width = w;\n                clippingContext._allClippedDrawRect.height = h;\n            }\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._currentMaskRenderTexture = null;\n        this._maskColorBuffers = null;\n        this._currentFrameNo = 0;\n        this._renderTextureCount = 0;\n        this._clippingMaskBufferSize = 256;\n        this._clippingContextListForMask = new csmvector_1.csmVector();\n        this._clippingContextListForDraw = new csmvector_1.csmVector();\n        this._channelColors = new csmvector_1.csmVector();\n        this._tmpBoundsOnModel = new csmrectf_1.csmRect();\n        this._tmpMatrix = new cubismmatrix44_1.CubismMatrix44();\n        this._tmpMatrixForMask = new cubismmatrix44_1.CubismMatrix44();\n        this._tmpMatrixForDraw = new cubismmatrix44_1.CubismMatrix44();\n        this._maskTexture = null;\n        let tmp = new cubismrenderer_1.CubismTextureColor();\n        tmp.R = 1.0;\n        tmp.G = 0.0;\n        tmp.B = 0.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new cubismrenderer_1.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 1.0;\n        tmp.B = 0.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new cubismrenderer_1.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 0.0;\n        tmp.B = 1.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new cubismrenderer_1.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 0.0;\n        tmp.B = 0.0;\n        tmp.A = 1.0;\n        this._channelColors.pushBack(tmp);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n            if (this._clippingContextListForMask.at(i)) {\n                this._clippingContextListForMask.at(i).release();\n                this._clippingContextListForMask.set(i, void 0);\n            }\n            this._clippingContextListForMask.set(i, null);\n        }\n        this._clippingContextListForMask = null;\n        // _clippingContextListForDrawは_clippingContextListForMaskにあるインスタンスを指している。上記の処理により要素ごとのDELETEは不要。\n        for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {\n            this._clippingContextListForDraw.set(i, null);\n        }\n        this._clippingContextListForDraw = null;\n        if (this._maskTexture) {\n            for (let i = 0; i < this._maskTexture.textures.getSize(); i++) {\n                this.gl.deleteFramebuffer(this._maskTexture.textures.at(i));\n            }\n            this._maskTexture.textures.clear();\n            this._maskTexture.textures = null;\n            this._maskTexture = null;\n        }\n        for (let i = 0; i < this._channelColors.getSize(); i++) {\n            this._channelColors.set(i, null);\n        }\n        this._channelColors = null;\n        // テクスチャ解放\n        if (this._maskColorBuffers != null) {\n            for (let index = 0; index < this._maskColorBuffers.getSize(); index++) {\n                this.gl.deleteTexture(this._maskColorBuffers.at(index));\n            }\n            this._maskColorBuffers.clear();\n        }\n        this._maskColorBuffers = null;\n        if (this._maskRenderTextures != null) {\n            this._maskRenderTextures.clear();\n        }\n        this._maskRenderTextures = null;\n        if (this._clearedFrameBufferflags != null) {\n            this._clearedFrameBufferflags.clear();\n        }\n        this._clearedFrameBufferflags = null;\n    }\n    /**\n     * マネージャの初期化処理\n     * クリッピングマスクを使う描画オブジェクトの登録を行う\n     * @param model モデルのインスタンス\n     * @param drawableCount 描画オブジェクトの数\n     * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト\n     * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n     * @param renderTextureCount バッファの生成数\n     */\n    initialize(model, drawableCount, drawableMasks, drawableMaskCounts, renderTextureCount) {\n        // レンダーテクスチャの合計枚数の設定\n        // 1以上の整数でない場合はそれぞれ警告を出す\n        if (renderTextureCount % 1 != 0) {\n            (0, cubismdebug_1.CubismLogWarning)('The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer.');\n            // 小数点以下を除去\n            renderTextureCount = ~~renderTextureCount;\n        }\n        if (renderTextureCount < 1) {\n            (0, cubismdebug_1.CubismLogWarning)('The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1.');\n        }\n        // 負の値が使われている場合は強制的に1枚と設定する\n        this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;\n        this._clearedFrameBufferflags = new csmvector_1.csmVector(this._renderTextureCount);\n        // クリッピングマスクを使う描画オブジェクトをすべて登録する\n        // クリッピングマスクは、通常数個程度に限定して使うものとする\n        for (let i = 0; i < drawableCount; i++) {\n            if (drawableMaskCounts[i] <= 0) {\n                // クリッピングマスクが使用されていないアートメッシュ（多くの場合使用しない）\n                this._clippingContextListForDraw.pushBack(null);\n                continue;\n            }\n            // 既にあるClipContextと同じかチェックする\n            let clippingContext = this.findSameClip(drawableMasks[i], drawableMaskCounts[i]);\n            if (clippingContext == null) {\n                // 同一のマスクが存在していない場合は生成する\n                clippingContext = new CubismClippingContext(this, drawableMasks[i], drawableMaskCounts[i]);\n                this._clippingContextListForMask.pushBack(clippingContext);\n            }\n            clippingContext.addClippedDrawable(i);\n            this._clippingContextListForDraw.pushBack(clippingContext);\n        }\n    }\n    /**\n     * クリッピングコンテキストを作成する。モデル描画時に実行する。\n     * @param model モデルのインスタンス\n     * @param renderer レンダラのインスタンス\n     */\n    setupClippingContext(model, renderer) {\n        this._currentFrameNo++;\n        // 全てのクリッピングを用意する\n        // 同じクリップ（複数の場合はまとめて一つのクリップ）を使う場合は1度だけ設定する\n        let usingClipCount = 0;\n        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n            // 1つのクリッピングマスクに関して\n            const cc = this._clippingContextListForMask.at(clipIndex);\n            // このクリップを利用する描画オブジェクト群全体を囲む矩形を計算\n            this.calcClippedDrawTotalBounds(model, cc);\n            if (cc._isUsing) {\n                usingClipCount++; // 使用中としてカウント\n            }\n        }\n        // マスク作成処理\n        if (usingClipCount > 0) {\n            // 各マスクのレイアウトを決定していく\n            this.setupLayoutBounds(renderer.isUsingHighPrecisionMask() ? 0 : usingClipCount);\n            if (!renderer.isUsingHighPrecisionMask()) {\n                // 生成したFrameBufferと同じサイズでビューポートを設定\n                this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);\n                // 後の計算のためにインデックスの最初をセット\n                this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);\n                renderer.preDraw(); // バッファをクリアする\n                // ---------- マスク描画処理 ----------\n                // マスク用RenderTextureをactiveにセット\n                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);\n            }\n            // サイズがレンダーテクスチャの枚数と合わない場合は合わせる\n            if (this._clearedFrameBufferflags.getSize() != this._renderTextureCount) {\n                this._clearedFrameBufferflags.clear();\n                this._clearedFrameBufferflags = new csmvector_1.csmVector(this._renderTextureCount);\n            }\n            // マスクのクリアフラグを毎フレーム開始時に初期化\n            for (let index = 0; index < this._clearedFrameBufferflags.getSize(); index++) {\n                this._clearedFrameBufferflags.set(index, false);\n            }\n            // 実際にマスクを生成する\n            // 全てのマスクをどのようにレイアウトして描くかを決定し、ClipContext, ClippedDrawContextに記憶する\n            for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n                // --- 実際に1つのマスクを描く ---\n                const clipContext = this._clippingContextListForMask.at(clipIndex);\n                const allClipedDrawRect = clipContext._allClippedDrawRect; // このマスクを使う、すべての描画オブジェクトの論理座標上の囲み矩形\n                const layoutBoundsOnTex01 = clipContext._layoutBounds; // この中にマスクを収める\n                const MARGIN = 0.05; // モデル座標上の矩形を、適宜マージンを付けて使う\n                let scaleX = 0;\n                let scaleY = 0;\n                // clipContextに設定したレンダーテクスチャをインデックスで取得\n                const clipContextRenderTexture = this.getMaskRenderTexture().at(clipContext._bufferIndex);\n                // 現在のレンダーテクスチャがclipContextのものと異なる場合\n                if (this._currentMaskRenderTexture != clipContextRenderTexture &&\n                    !renderer.isUsingHighPrecisionMask()) {\n                    this._currentMaskRenderTexture = clipContextRenderTexture;\n                    renderer.preDraw(); // バッファをクリアする\n                    // マスク用RenderTextureをactiveにセット\n                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);\n                }\n                if (renderer.isUsingHighPrecisionMask()) {\n                    const ppu = model.getPixelsPerUnit();\n                    const maskPixelSize = clipContext.getClippingManager()._clippingMaskBufferSize;\n                    const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;\n                    const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;\n                    this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n                    if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {\n                        this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, 0.0);\n                        scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n                    }\n                    else {\n                        scaleX = ppu / physicalMaskWidth;\n                    }\n                    if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {\n                        this._tmpBoundsOnModel.expand(0.0, allClipedDrawRect.height * MARGIN);\n                        scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n                    }\n                    else {\n                        scaleY = ppu / physicalMaskHeight;\n                    }\n                }\n                else {\n                    this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n                    this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, allClipedDrawRect.height * MARGIN);\n                    //########## 本来は割り当てられた領域の全体を使わず必要最低限のサイズがよい\n                    // シェーダ用の計算式を求める。回転を考慮しない場合は以下のとおり\n                    // movePeriod' = movePeriod * scaleX + offX\t\t  [[ movePeriod' = (movePeriod - tmpBoundsOnModel.movePeriod)*scale + layoutBoundsOnTex01.movePeriod ]]\n                    scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n                    scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n                }\n                // マスク生成時に使う行列を求める\n                {\n                    // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n                    this._tmpMatrix.loadIdentity();\n                    {\n                        // layout0..1 を -1..1に変換\n                        this._tmpMatrix.translateRelative(-1.0, -1.0);\n                        this._tmpMatrix.scaleRelative(2.0, 2.0);\n                    }\n                    {\n                        // view to layout0..1\n                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n                        // new = [translate][scale][translate]\n                    }\n                    // tmpMatrixForMaskが計算結果\n                    this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());\n                }\n                //--------- draw時の mask 参照用行列を計算\n                {\n                    // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n                    this._tmpMatrix.loadIdentity();\n                    {\n                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n                        // new = [translate][scale][translate]\n                    }\n                    this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());\n                }\n                clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());\n                clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());\n                if (!renderer.isUsingHighPrecisionMask()) {\n                    const clipDrawCount = clipContext._clippingIdCount;\n                    for (let i = 0; i < clipDrawCount; i++) {\n                        const clipDrawIndex = clipContext._clippingIdList[i];\n                        // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n                        if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n                            continue;\n                        }\n                        renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);\n                        // マスクがクリアされていないなら処理する\n                        if (!this._clearedFrameBufferflags.at(clipContext._bufferIndex)) {\n                            // マスクをクリアする\n                            // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n                            this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n                            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n                            this._clearedFrameBufferflags.set(clipContext._bufferIndex, true);\n                        }\n                        // 今回専用の変換を適用して描く\n                        // チャンネルも切り替える必要がある(A,R,G,B)\n                        renderer.setClippingContextBufferForMask(clipContext);\n                        renderer.drawMesh(model.getDrawableTextureIndex(clipDrawIndex), model.getDrawableVertexIndexCount(clipDrawIndex), model.getDrawableVertexCount(clipDrawIndex), model.getDrawableVertexIndices(clipDrawIndex), model.getDrawableVertices(clipDrawIndex), model.getDrawableVertexUvs(clipDrawIndex), model.getMultiplyColor(clipDrawIndex), model.getScreenColor(clipDrawIndex), model.getDrawableOpacity(clipDrawIndex), cubismrenderer_1.CubismBlendMode.CubismBlendMode_Normal, // クリッピングは通常描画を強制\n                        false // マスク生成時はクリッピングの反転使用は全く関係がない\n                        );\n                    }\n                }\n            }\n            if (!renderer.isUsingHighPrecisionMask()) {\n                // --- 後処理 ---\n                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n                renderer.setClippingContextBufferForMask(null);\n                this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n            }\n        }\n    }\n    /**\n     * 既にマスクを作っているかを確認\n     * 作っている様であれば該当するクリッピングマスクのインスタンスを返す\n     * 作っていなければNULLを返す\n     * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト\n     * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n     * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す\n     */\n    findSameClip(drawableMasks, drawableMaskCounts) {\n        // 作成済みClippingContextと一致するか確認\n        for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n            const clippingContext = this._clippingContextListForMask.at(i);\n            const count = clippingContext._clippingIdCount;\n            // 個数が違う場合は別物\n            if (count != drawableMaskCounts) {\n                continue;\n            }\n            let sameCount = 0;\n            // 同じIDを持つか確認。配列の数が同じなので、一致した個数が同じなら同じ物を持つとする\n            for (let j = 0; j < count; j++) {\n                const clipId = clippingContext._clippingIdList[j];\n                for (let k = 0; k < count; k++) {\n                    if (drawableMasks[k] == clipId) {\n                        sameCount++;\n                        break;\n                    }\n                }\n            }\n            if (sameCount == count) {\n                return clippingContext;\n            }\n        }\n        return null; // 見つからなかった\n    }\n    /**\n     * クリッピングコンテキストを配置するレイアウト\n     * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする\n     * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。\n     *\n     * @param usingClipCount 配置するクリッピングコンテキストの数\n     */\n    setupLayoutBounds(usingClipCount) {\n        const useClippingMaskMaxCount = this._renderTextureCount <= 1\n            ? ClippingMaskMaxCountOnDefault\n            : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;\n        if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {\n            if (usingClipCount > useClippingMaskMaxCount) {\n                // マスクの制限数の警告を出す\n                (0, cubismdebug_1.CubismLogError)('not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}', usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);\n            }\n            // この場合は一つのマスクターゲットを毎回クリアして使用する\n            for (let index = 0; index < this._clippingContextListForMask.getSize(); index++) {\n                const clipContext = this._clippingContextListForMask.at(index);\n                clipContext._layoutChannelNo = 0; // どうせ毎回消すので固定\n                clipContext._layoutBounds.x = 0.0;\n                clipContext._layoutBounds.y = 0.0;\n                clipContext._layoutBounds.width = 1.0;\n                clipContext._layoutBounds.height = 1.0;\n                clipContext._bufferIndex = 0;\n            }\n            return;\n        }\n        // レンダーテクスチャが1枚なら9分割する（最大36枚）\n        const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;\n        // 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする（デフォルトなら1）\n        // マスクグループの数が4以下ならRGBA各チャンネルに1つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する\n        let countPerSheetDiv = usingClipCount / this._renderTextureCount; // レンダーテクスチャ1枚あたり何枚割り当てるか\n        let countPerSheetMod = usingClipCount % this._renderTextureCount; // この番号のレンダーテクスチャまでに一つずつ配分する\n        // 小数点は切り捨てる\n        countPerSheetDiv = ~~countPerSheetDiv;\n        countPerSheetMod = ~~countPerSheetMod;\n        // RGBAを順番に使っていく\n        let div = countPerSheetDiv / ColorChannelCount; // 1チャンネルに配置する基本のマスク\n        let mod = countPerSheetDiv % ColorChannelCount; // 余り、この番号のチャンネルまでに一つずつ配分する\n        // 小数点は切り捨てる\n        div = ~~div;\n        mod = ~~mod;\n        // RGBAそれぞれのチャンネルを用意していく（0:R, 1:G, 2:B, 3:A）\n        let curClipIndex = 0; // 順番に設定していく\n        for (let renderTextureNo = 0; renderTextureNo < this._renderTextureCount; renderTextureNo++) {\n            for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {\n                // このチャンネルにレイアウトする数\n                let layoutCount = div + (channelNo < mod ? 1 : 0);\n                // このレンダーテクスチャにまだ割り当てられていなければ追加する\n                const checkChannelNo = mod + 1 >= ColorChannelCount ? 0 : mod + 1;\n                if (layoutCount < layoutCountMaxValue && channelNo == checkChannelNo) {\n                    layoutCount += renderTextureNo < countPerSheetMod ? 1 : 0;\n                }\n                // 分割方法を決定する\n                if (layoutCount == 0) {\n                    // 何もしない\n                }\n                else if (layoutCount == 1) {\n                    // 全てをそのまま使う\n                    const clipContext = this._clippingContextListForMask.at(curClipIndex++);\n                    clipContext._layoutChannelNo = channelNo;\n                    clipContext._layoutBounds.x = 0.0;\n                    clipContext._layoutBounds.y = 0.0;\n                    clipContext._layoutBounds.width = 1.0;\n                    clipContext._layoutBounds.height = 1.0;\n                    clipContext._bufferIndex = renderTextureNo;\n                }\n                else if (layoutCount == 2) {\n                    for (let i = 0; i < layoutCount; i++) {\n                        let xpos = i % 2;\n                        // 小数点は切り捨てる\n                        xpos = ~~xpos;\n                        const cc = this._clippingContextListForMask.at(curClipIndex++);\n                        cc._layoutChannelNo = channelNo;\n                        // UVを2つに分解して使う\n                        cc._layoutBounds.x = xpos * 0.5;\n                        cc._layoutBounds.y = 0.0;\n                        cc._layoutBounds.width = 0.5;\n                        cc._layoutBounds.height = 1.0;\n                        cc._bufferIndex = renderTextureNo;\n                    }\n                }\n                else if (layoutCount <= 4) {\n                    // 4分割して使う\n                    for (let i = 0; i < layoutCount; i++) {\n                        let xpos = i % 2;\n                        let ypos = i / 2;\n                        // 小数点は切り捨てる\n                        xpos = ~~xpos;\n                        ypos = ~~ypos;\n                        const cc = this._clippingContextListForMask.at(curClipIndex++);\n                        cc._layoutChannelNo = channelNo;\n                        cc._layoutBounds.x = xpos * 0.5;\n                        cc._layoutBounds.y = ypos * 0.5;\n                        cc._layoutBounds.width = 0.5;\n                        cc._layoutBounds.height = 0.5;\n                        cc._bufferIndex = renderTextureNo;\n                    }\n                }\n                else if (layoutCount <= layoutCountMaxValue) {\n                    // 9分割して使う\n                    for (let i = 0; i < layoutCount; i++) {\n                        let xpos = i % 3;\n                        let ypos = i / 3;\n                        // 小数点は切り捨てる\n                        xpos = ~~xpos;\n                        ypos = ~~ypos;\n                        const cc = this._clippingContextListForMask.at(curClipIndex++);\n                        cc._layoutChannelNo = channelNo;\n                        cc._layoutBounds.x = xpos / 3.0;\n                        cc._layoutBounds.y = ypos / 3.0;\n                        cc._layoutBounds.width = 1.0 / 3.0;\n                        cc._layoutBounds.height = 1.0 / 3.0;\n                        cc._bufferIndex = renderTextureNo;\n                    }\n                }\n                else {\n                    // マスクの制限枚数を超えた場合の処理\n                    (0, cubismdebug_1.CubismLogError)('not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}', usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);\n                    // SetupShaderProgramでオーバーアクセスが発生するので仮で数値を入れる\n                    // もちろん描画結果は正しいものではなくなる\n                    for (let index = 0; index < layoutCount; index++) {\n                        const cc = this._clippingContextListForMask.at(curClipIndex++);\n                        cc._layoutChannelNo = 0;\n                        cc._layoutBounds.x = 0.0;\n                        cc._layoutBounds.y = 0.0;\n                        cc._layoutBounds.width = 1.0;\n                        cc._layoutBounds.height = 1.0;\n                        cc._bufferIndex = 0;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * カラーバッファを取得する\n     * @return カラーバッファ\n     */\n    getColorBuffer() {\n        return this._maskColorBuffers;\n    }\n    /**\n     * 画面描画に使用するクリッピングマスクのリストを取得する\n     * @return 画面描画に使用するクリッピングマスクのリスト\n     */\n    getClippingContextListForDraw() {\n        return this._clippingContextListForDraw;\n    }\n    /**\n     * マスクの合計数をカウント\n     * @returns\n     */\n    getClippingMaskCount() {\n        return this._clippingContextListForMask.getSize();\n    }\n    /**\n     * クリッピングマスクバッファのサイズを設定する\n     * @param size クリッピングマスクバッファのサイズ\n     */\n    setClippingMaskBufferSize(size) {\n        this._clippingMaskBufferSize = size;\n    }\n    /**\n     * クリッピングマスクバッファのサイズを取得する\n     * @return クリッピングマスクバッファのサイズ\n     */\n    getClippingMaskBufferSize() {\n        return this._clippingMaskBufferSize;\n    }\n    /**\n     * このバッファのレンダーテクスチャの枚数を取得する\n     * @return このバッファのレンダーテクスチャの枚数\n     */\n    getRenderTextureCount() {\n        return this._renderTextureCount;\n    }\n}\nexports.CubismClippingManager_WebGL = CubismClippingManager_WebGL;\n/**\n * レンダーテクスチャのリソースを定義する構造体\n * クリッピングマスクで使用する\n */\nclass CubismRenderTextureResource {\n    /**\n     * 引数付きコンストラクタ\n     * @param frameNo レンダラーのフレーム番号\n     * @param texture テクスチャのアドレス\n     */\n    constructor(frameNo, texture) {\n        this.frameNo = frameNo;\n        this.textures = texture;\n    }\n}\nexports.CubismRenderTextureResource = CubismRenderTextureResource;\n/**\n * クリッピングマスクのコンテキスト\n */\nclass CubismClippingContext {\n    /**\n     * 引数付きコンストラクタ\n     */\n    constructor(manager, clippingDrawableIndices, clipCount) {\n        this._owner = manager;\n        // クリップしている（＝マスク用の）Drawableのインデックスリスト\n        this._clippingIdList = clippingDrawableIndices;\n        // マスクの数\n        this._clippingIdCount = clipCount;\n        this._allClippedDrawRect = new csmrectf_1.csmRect();\n        this._layoutBounds = new csmrectf_1.csmRect();\n        this._clippedDrawableIndexList = [];\n        this._matrixForMask = new cubismmatrix44_1.CubismMatrix44();\n        this._matrixForDraw = new cubismmatrix44_1.CubismMatrix44();\n        this._bufferIndex = 0;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        if (this._layoutBounds != null) {\n            this._layoutBounds = null;\n        }\n        if (this._allClippedDrawRect != null) {\n            this._allClippedDrawRect = null;\n        }\n        if (this._clippedDrawableIndexList != null) {\n            this._clippedDrawableIndexList = null;\n        }\n    }\n    /**\n     * このマスクにクリップされる描画オブジェクトを追加する\n     *\n     * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス\n     */\n    addClippedDrawable(drawableIndex) {\n        this._clippedDrawableIndexList.push(drawableIndex);\n    }\n    /**\n     * このマスクを管理するマネージャのインスタンスを取得する\n     * @return クリッピングマネージャのインスタンス\n     */\n    getClippingManager() {\n        return this._owner;\n    }\n    setGl(gl) {\n        this._owner.setGL(gl);\n    }\n}\nexports.CubismClippingContext = CubismClippingContext;\nclass CubismRendererProfile_WebGL {\n    setGlEnable(index, enabled) {\n        if (enabled)\n            this.gl.enable(index);\n        else\n            this.gl.disable(index);\n    }\n    setGlEnableVertexAttribArray(index, enabled) {\n        if (enabled)\n            this.gl.enableVertexAttribArray(index);\n        else\n            this.gl.disableVertexAttribArray(index);\n    }\n    save() {\n        if (this.gl == null) {\n            (0, cubismdebug_1.CubismLogError)(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n            return;\n        }\n        //-- push state --\n        this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);\n        this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ELEMENT_ARRAY_BUFFER_BINDING);\n        this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n        this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);\n        this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1をアクティブに（以後の設定対象とする）\n        this._lastTexture1Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n        this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0をアクティブに（以後の設定対象とする）\n        this._lastTexture0Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n        this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(0, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(1, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(2, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(3, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);\n        this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);\n        this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);\n        this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);\n        this._lastBlend = this.gl.isEnabled(this.gl.BLEND);\n        this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);\n        this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);\n        // backup blending\n        this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);\n        this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);\n        this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);\n        this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);\n        // モデル描画直前のFBOとビューポートを保存\n        this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n        this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);\n    }\n    restore() {\n        if (this.gl == null) {\n            (0, cubismdebug_1.CubismLogError)(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n            return;\n        }\n        this.gl.useProgram(this._lastProgram);\n        this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);\n        this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);\n        this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);\n        this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);\n        this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);\n        this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);\n        this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);\n        this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);\n        this.setGlEnable(this.gl.BLEND, this._lastBlend);\n        this.gl.frontFace(this._lastFrontFace);\n        this.gl.colorMask(this._lastColorMask[0], this._lastColorMask[1], this._lastColorMask[2], this._lastColorMask[3]);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding); //前にバッファがバインドされていたら破棄する必要がある\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this._lastElementArrayBufferBinding);\n        this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1を復元\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);\n        this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0を復元\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);\n        this.gl.activeTexture(this._lastActiveTexture);\n        this.gl.blendFuncSeparate(this._lastBlending[0], this._lastBlending[1], this._lastBlending[2], this._lastBlending[3]);\n    }\n    setGl(gl) {\n        this.gl = gl;\n    }\n    constructor() {\n        this._lastVertexAttribArrayEnabled = new Array(4);\n        this._lastColorMask = new Array(4);\n        this._lastBlending = new Array(4);\n        this._lastViewport = new Array(4);\n    }\n}\nexports.CubismRendererProfile_WebGL = CubismRendererProfile_WebGL;\n/**\n * WebGL用のシェーダープログラムを生成・破棄するクラス\n * シングルトンなクラスであり、CubismShader_WebGL.getInstanceからアクセスする。\n */\nclass CubismShader_WebGL {\n    /**\n     * インスタンスを取得する（シングルトン）\n     * @return インスタンス\n     */\n    static getInstance() {\n        if (s_instance == null) {\n            s_instance = new CubismShader_WebGL();\n            return s_instance;\n        }\n        return s_instance;\n    }\n    /**\n     * インスタンスを開放する（シングルトン）\n     */\n    static deleteInstance() {\n        if (s_instance) {\n            s_instance.release();\n            s_instance = null;\n        }\n    }\n    /**\n     * privateなコンストラクタ\n     */\n    constructor() {\n        this._shaderSets = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        this.releaseShaderProgram();\n    }\n    /**\n     * シェーダープログラムの一連のセットアップを実行する\n     * @param renderer レンダラのインスタンス\n     * @param textureId GPUのテクスチャID\n     * @param vertexCount ポリゴンメッシュの頂点数\n     * @param vertexArray ポリゴンメッシュの頂点配列\n     * @param indexArray インデックスバッファの頂点配列\n     * @param uvArray uv配列\n     * @param opacity 不透明度\n     * @param colorBlendMode カラーブレンディングのタイプ\n     * @param baseColor ベースカラー\n     * @param isPremultipliedAlpha 乗算済みアルファかどうか\n     * @param matrix4x4 Model-View-Projection行列\n     * @param invertedMask マスクを反転して使用するフラグ\n     */\n    setupShaderProgram(renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, multiplyColor, screenColor, isPremultipliedAlpha, matrix4x4, invertedMask) {\n        if (!isPremultipliedAlpha) {\n            (0, cubismdebug_1.CubismLogError)('NoPremultipliedAlpha is not allowed');\n        }\n        if (this._shaderSets.getSize() == 0) {\n            this.generateShaders();\n        }\n        // Blending\n        let SRC_COLOR;\n        let DST_COLOR;\n        let SRC_ALPHA;\n        let DST_ALPHA;\n        if (renderer.getClippingContextBufferForMask() != null) {\n            // マスク生成時\n            const shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_SetupMask);\n            this.gl.useProgram(shaderSet.shaderProgram);\n            // テクスチャ設定\n            this.gl.activeTexture(this.gl.TEXTURE0);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n            // 頂点配列の設定(VBO)\n            if (bufferData.vertex == null) {\n                bufferData.vertex = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // テクスチャ頂点の設定\n            if (bufferData.uv == null) {\n                bufferData.uv = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // チャンネル\n            const channelNo = renderer.getClippingContextBufferForMask()._layoutChannelNo;\n            const colorChannel = renderer\n                .getClippingContextBufferForMask()\n                .getClippingManager()\n                .getChannelFlagAsColor(channelNo);\n            this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n            this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForMask()._matrixForMask.getArray());\n            const rect = renderer.getClippingContextBufferForMask()._layoutBounds;\n            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2.0 - 1.0, rect.y * 2.0 - 1.0, rect.getRight() * 2.0 - 1.0, rect.getBottom() * 2.0 - 1.0);\n            this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n            this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n            SRC_COLOR = this.gl.ZERO;\n            DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;\n            SRC_ALPHA = this.gl.ZERO;\n            DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n        } // マスク生成以外の場合\n        else {\n            const masked = renderer.getClippingContextBufferForDraw() != null; // この描画オブジェクトはマスク対象か\n            const offset = masked ? (invertedMask ? 2 : 1) : 0;\n            let shaderSet = new CubismShaderSet();\n            switch (colorBlendMode) {\n                case cubismrenderer_1.CubismBlendMode.CubismBlendMode_Normal:\n                default:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.ONE;\n                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n                    SRC_ALPHA = this.gl.ONE;\n                    DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n                    break;\n                case cubismrenderer_1.CubismBlendMode.CubismBlendMode_Additive:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_AddPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.ONE;\n                    DST_COLOR = this.gl.ONE;\n                    SRC_ALPHA = this.gl.ZERO;\n                    DST_ALPHA = this.gl.ONE;\n                    break;\n                case cubismrenderer_1.CubismBlendMode.CubismBlendMode_Multiplicative:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_MultPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.DST_COLOR;\n                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n                    SRC_ALPHA = this.gl.ZERO;\n                    DST_ALPHA = this.gl.ONE;\n                    break;\n            }\n            this.gl.useProgram(shaderSet.shaderProgram);\n            // 頂点配列の設定\n            if (bufferData.vertex == null) {\n                bufferData.vertex = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // テクスチャ頂点の設定\n            if (bufferData.uv == null) {\n                bufferData.uv = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n            if (masked) {\n                this.gl.activeTexture(this.gl.TEXTURE1);\n                const tex = renderer\n                    .getClippingContextBufferForDraw()\n                    .getClippingManager()\n                    .getColorBuffer()\n                    .at(renderer.getClippingContextBufferForDraw()._bufferIndex);\n                this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n                this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);\n                // view座標をClippingContextの座標に変換するための行列を設定\n                this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray());\n                // 使用するカラーチャンネルを設定\n                const channelNo = renderer.getClippingContextBufferForDraw()._layoutChannelNo;\n                const colorChannel = renderer\n                    .getClippingContextBufferForDraw()\n                    .getClippingManager()\n                    .getChannelFlagAsColor(channelNo);\n                this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n            }\n            // テクスチャ設定\n            this.gl.activeTexture(this.gl.TEXTURE0);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n            // 座標変換\n            this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());\n            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.R, baseColor.G, baseColor.B, baseColor.A);\n            this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n            this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n        }\n        // IBOを作成し、データを転送\n        if (bufferData.index == null) {\n            bufferData.index = this.gl.createBuffer();\n        }\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);\n        this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);\n    }\n    /**\n     * シェーダープログラムを解放する\n     */\n    releaseShaderProgram() {\n        for (let i = 0; i < this._shaderSets.getSize(); i++) {\n            this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);\n            this._shaderSets.at(i).shaderProgram = 0;\n            this._shaderSets.set(i, void 0);\n            this._shaderSets.set(i, null);\n        }\n    }\n    /**\n     * シェーダープログラムを初期化する\n     * @param vertShaderSrc 頂点シェーダのソース\n     * @param fragShaderSrc フラグメントシェーダのソース\n     */\n    generateShaders() {\n        for (let i = 0; i < ShaderCount; i++) {\n            this._shaderSets.pushBack(new CubismShaderSet());\n        }\n        this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(exports.vertexShaderSrcSetupMask, exports.fragmentShaderSrcsetupMask);\n        this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(exports.vertexShaderSrc, exports.fragmentShaderSrcPremultipliedAlpha);\n        this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(exports.vertexShaderSrcMasked, exports.fragmentShaderSrcMaskPremultipliedAlpha);\n        this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(exports.vertexShaderSrcMasked, exports.fragmentShaderSrcMaskInvertedPremultipliedAlpha);\n        // 加算も通常と同じシェーダーを利用する\n        this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;\n        this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;\n        this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;\n        // 乗算も通常と同じシェーダーを利用する\n        this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;\n        this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;\n        this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;\n        // SetupMask\n        this._shaderSets.at(0).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_position');\n        this._shaderSets.at(0).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 's_texture0');\n        this._shaderSets.at(0).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(0).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(0).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(0).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(0).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_screenColor');\n        // 通常（PremultipliedAlpha）\n        this._shaderSets.at(1).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_position');\n        this._shaderSets.at(1).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 's_texture0');\n        this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_matrix');\n        this._shaderSets.at(1).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(1).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(1).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_screenColor');\n        // 通常（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(2).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_position');\n        this._shaderSets.at(2).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture0');\n        this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture1');\n        this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_matrix');\n        this._shaderSets.at(2).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(2).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(2).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(2).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(2).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_screenColor');\n        // 通常（クリッピング・反転, PremultipliedAlpha）\n        this._shaderSets.at(3).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_position');\n        this._shaderSets.at(3).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture0');\n        this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture1');\n        this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_matrix');\n        this._shaderSets.at(3).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(3).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(3).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(3).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(3).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_screenColor');\n        // 加算（PremultipliedAlpha）\n        this._shaderSets.at(4).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_position');\n        this._shaderSets.at(4).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 's_texture0');\n        this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_matrix');\n        this._shaderSets.at(4).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(4).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(4).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_screenColor');\n        // 加算（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(5).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_position');\n        this._shaderSets.at(5).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture0');\n        this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture1');\n        this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_matrix');\n        this._shaderSets.at(5).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(5).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(5).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(5).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(5).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_screenColor');\n        // 加算（クリッピング・反転、PremultipliedAlpha）\n        this._shaderSets.at(6).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_position');\n        this._shaderSets.at(6).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture0');\n        this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture1');\n        this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_matrix');\n        this._shaderSets.at(6).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(6).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(6).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(6).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(6).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_screenColor');\n        // 乗算（PremultipliedAlpha）\n        this._shaderSets.at(7).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_position');\n        this._shaderSets.at(7).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 's_texture0');\n        this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_matrix');\n        this._shaderSets.at(7).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(7).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(7).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_screenColor');\n        // 乗算（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(8).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_position');\n        this._shaderSets.at(8).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture0');\n        this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture1');\n        this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_matrix');\n        this._shaderSets.at(8).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(8).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(8).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(8).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(8).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_screenColor');\n        // 乗算（クリッピング・反転、PremultipliedAlpha）\n        this._shaderSets.at(9).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_position');\n        this._shaderSets.at(9).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture0');\n        this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture1');\n        this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_matrix');\n        this._shaderSets.at(9).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(9).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(9).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(9).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(9).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_screenColor');\n    }\n    /**\n     * シェーダプログラムをロードしてアドレスを返す\n     * @param vertexShaderSource    頂点シェーダのソース\n     * @param fragmentShaderSource  フラグメントシェーダのソース\n     * @return シェーダプログラムのアドレス\n     */\n    loadShaderProgram(vertexShaderSource, fragmentShaderSource) {\n        // Create Shader Program\n        let shaderProgram = this.gl.createProgram();\n        let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);\n        if (!vertShader) {\n            (0, cubismdebug_1.CubismLogError)('Vertex shader compile error!');\n            return 0;\n        }\n        let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n        if (!fragShader) {\n            (0, cubismdebug_1.CubismLogError)('Vertex shader compile error!');\n            return 0;\n        }\n        // Attach vertex shader to program\n        this.gl.attachShader(shaderProgram, vertShader);\n        // Attach fragment shader to program\n        this.gl.attachShader(shaderProgram, fragShader);\n        // link program\n        this.gl.linkProgram(shaderProgram);\n        const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);\n        // リンクに失敗したらシェーダーを削除\n        if (!linkStatus) {\n            (0, cubismdebug_1.CubismLogError)('Failed to link program: {0}', shaderProgram);\n            this.gl.deleteShader(vertShader);\n            vertShader = 0;\n            this.gl.deleteShader(fragShader);\n            fragShader = 0;\n            if (shaderProgram) {\n                this.gl.deleteProgram(shaderProgram);\n                shaderProgram = 0;\n            }\n            return 0;\n        }\n        // Release vertex and fragment shaders.\n        this.gl.deleteShader(vertShader);\n        this.gl.deleteShader(fragShader);\n        return shaderProgram;\n    }\n    /**\n     * シェーダープログラムをコンパイルする\n     * @param shaderType シェーダタイプ(Vertex/Fragment)\n     * @param shaderSource シェーダソースコード\n     *\n     * @return コンパイルされたシェーダープログラム\n     */\n    compileShaderSource(shaderType, shaderSource) {\n        const source = shaderSource;\n        const shader = this.gl.createShader(shaderType);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!shader) {\n            const log = this.gl.getShaderInfoLog(shader);\n            (0, cubismdebug_1.CubismLogError)('Shader compile log: {0} ', log);\n        }\n        const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\n        if (!status) {\n            this.gl.deleteShader(shader);\n            return null;\n        }\n        return shader;\n    }\n    setGl(gl) {\n        this.gl = gl;\n    }\n}\nexports.CubismShader_WebGL = CubismShader_WebGL;\n/**\n * CubismShader_WebGLのインナークラス\n */\nclass CubismShaderSet {\n}\nexports.CubismShaderSet = CubismShaderSet;\nvar ShaderNames;\n(function (ShaderNames) {\n    // SetupMask\n    ShaderNames[ShaderNames[\"ShaderNames_SetupMask\"] = 0] = \"ShaderNames_SetupMask\";\n    // Normal\n    ShaderNames[ShaderNames[\"ShaderNames_NormalPremultipliedAlpha\"] = 1] = \"ShaderNames_NormalPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_NormalMaskedPremultipliedAlpha\"] = 2] = \"ShaderNames_NormalMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\"] = 3] = \"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\";\n    // Add\n    ShaderNames[ShaderNames[\"ShaderNames_AddPremultipliedAlpha\"] = 4] = \"ShaderNames_AddPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlpha\"] = 5] = \"ShaderNames_AddMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlphaInverted\"] = 6] = \"ShaderNames_AddMaskedPremultipliedAlphaInverted\";\n    // Mult\n    ShaderNames[ShaderNames[\"ShaderNames_MultPremultipliedAlpha\"] = 7] = \"ShaderNames_MultPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlpha\"] = 8] = \"ShaderNames_MultMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlphaInverted\"] = 9] = \"ShaderNames_MultMaskedPremultipliedAlphaInverted\";\n})(ShaderNames || (exports.ShaderNames = ShaderNames = {}));\nexports.vertexShaderSrcSetupMask = 'attribute vec4     a_position;' +\n    'attribute vec2     a_texCoord;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_myPos;' +\n    'uniform mat4       u_clipMatrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_clipMatrix * a_position;' +\n    '   v_myPos = u_clipMatrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\nexports.fragmentShaderSrcsetupMask = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_myPos;' +\n    'uniform vec4       u_baseColor;' +\n    'uniform vec4       u_channelFlag;' +\n    'uniform sampler2D  s_texture0;' +\n    'void main()' +\n    '{' +\n    '   float isInside = ' +\n    '       step(u_baseColor.x, v_myPos.x/v_myPos.w)' +\n    '       * step(u_baseColor.y, v_myPos.y/v_myPos.w)' +\n    '       * step(v_myPos.x/v_myPos.w, u_baseColor.z)' +\n    '       * step(v_myPos.y/v_myPos.w, u_baseColor.w);' +\n    '   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;' +\n    '}';\n//----- バーテックスシェーダプログラム -----\n// Normal & Add & Mult 共通\nexports.vertexShaderSrc = 'attribute vec4     a_position;' + //v.vertex\n    'attribute vec2     a_texCoord;' + //v.texcoord\n    'varying vec2       v_texCoord;' + //v2f.texcoord\n    'uniform mat4       u_matrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_matrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\n// Normal & Add & Mult 共通（クリッピングされたものの描画用）\nexports.vertexShaderSrcMasked = 'attribute vec4     a_position;' +\n    'attribute vec2     a_texCoord;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_clipPos;' +\n    'uniform mat4       u_matrix;' +\n    'uniform mat4       u_clipMatrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_matrix * a_position;' +\n    '   v_clipPos = u_clipMatrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\n//----- フラグメントシェーダプログラム -----\n// Normal & Add & Mult 共通 （PremultipliedAlpha）\nexports.fragmentShaderSrcPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' + //v2f.texcoord\n    'uniform vec4       u_baseColor;' +\n    'uniform sampler2D  s_texture0;' + //_MainTex\n    'uniform vec4       u_multiplyColor;' +\n    'uniform vec4       u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 color = texColor * u_baseColor;' +\n    '   gl_FragColor = vec4(color.rgb, color.a);' +\n    '}';\n// Normal （クリッピングされたものの描画用、PremultipliedAlpha兼用）\nexports.fragmentShaderSrcMaskPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_clipPos;' +\n    'uniform vec4       u_baseColor;' +\n    'uniform vec4       u_channelFlag;' +\n    'uniform sampler2D  s_texture0;' +\n    'uniform sampler2D  s_texture1;' +\n    'uniform vec4       u_multiplyColor;' +\n    'uniform vec4       u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 col_formask = texColor * u_baseColor;' +\n    '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n    '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n    '   col_formask = col_formask * maskVal;' +\n    '   gl_FragColor = col_formask;' +\n    '}';\n// Normal & Add & Mult 共通（クリッピングされて反転使用の描画用、PremultipliedAlphaの場合）\nexports.fragmentShaderSrcMaskInvertedPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2      v_texCoord;' +\n    'varying vec4      v_clipPos;' +\n    'uniform sampler2D s_texture0;' +\n    'uniform sampler2D s_texture1;' +\n    'uniform vec4      u_channelFlag;' +\n    'uniform vec4      u_baseColor;' +\n    'uniform vec4      u_multiplyColor;' +\n    'uniform vec4      u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 col_formask = texColor * u_baseColor;' +\n    '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n    '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n    '   col_formask = col_formask * (1.0 - maskVal);' +\n    '   gl_FragColor = col_formask;' +\n    '}';\n/**\n * WebGL用の描画命令を実装したクラス\n */\nclass CubismRenderer_WebGL extends cubismrenderer_1.CubismRenderer {\n    /**\n     * レンダラの初期化処理を実行する\n     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n     *\n     * @param model モデルのインスタンス\n     * @param maskBufferCount バッファの生成数\n     */\n    initialize(model, maskBufferCount = 1) {\n        if (model.isUsingMasking()) {\n            this._clippingManager = new CubismClippingManager_WebGL(); // クリッピングマスク・バッファ前処理方式を初期化\n            this._clippingManager.initialize(model, model.getDrawableCount(), model.getDrawableMasks(), model.getDrawableMaskCounts(), maskBufferCount);\n        }\n        this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);\n        super.initialize(model); // 親クラスの処理を呼ぶ\n    }\n    /**\n     * WebGLテクスチャのバインド処理\n     * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする\n     * @param modelTextureNo セットするモデルテクスチャの番号\n     * @param glTextureNo WebGLテクスチャの番号\n     */\n    bindTexture(modelTextureNo, glTexture) {\n        this._textures.setValue(modelTextureNo, glTexture);\n    }\n    /**\n     * WebGLにバインドされたテクスチャのリストを取得する\n     * @return テクスチャのリスト\n     */\n    getBindedTextures() {\n        return this._textures;\n    }\n    /**\n     * クリッピングマスクバッファのサイズを設定する\n     * マスク用のFrameBufferを破棄、再作成する為処理コストは高い\n     * @param size クリッピングマスクバッファのサイズ\n     */\n    setClippingMaskBufferSize(size) {\n        // クリッピングマスクを利用しない場合は早期リターン\n        if (!this._model.isUsingMasking()) {\n            return;\n        }\n        // インスタンス破棄前にレンダーテクスチャの数を保存\n        const renderTextureCount = this._clippingManager.getRenderTextureCount();\n        // FrameBufferのサイズを変更するためにインスタンスを破棄・再作成する\n        this._clippingManager.release();\n        this._clippingManager = void 0;\n        this._clippingManager = null;\n        this._clippingManager = new CubismClippingManager_WebGL();\n        this._clippingManager.setClippingMaskBufferSize(size);\n        this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts(), renderTextureCount // インスタンス破棄前に保存したレンダーテクスチャの数\n        );\n    }\n    /**\n     * クリッピングマスクバッファのサイズを取得する\n     * @return クリッピングマスクバッファのサイズ\n     */\n    getClippingMaskBufferSize() {\n        return this._model.isUsingMasking()\n            ? this._clippingManager.getClippingMaskBufferSize()\n            : -1;\n    }\n    /**\n     * レンダーテクスチャの枚数を取得する\n     * @return レンダーテクスチャの枚数\n     */\n    getRenderTextureCount() {\n        return this._model.isUsingMasking()\n            ? this._clippingManager.getRenderTextureCount()\n            : -1;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._clippingContextBufferForMask = null;\n        this._clippingContextBufferForDraw = null;\n        this._rendererProfile = new CubismRendererProfile_WebGL();\n        this.firstDraw = true;\n        this._textures = new csmmap_1.csmMap();\n        this._sortedDrawableIndexList = new csmvector_1.csmVector();\n        this._bufferData = {\n            vertex: (WebGLBuffer = null),\n            uv: (WebGLBuffer = null),\n            index: (WebGLBuffer = null),\n        };\n        // テクスチャ対応マップの容量を確保しておく\n        this._textures.prepareCapacity(32, true);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        if (this._clippingManager) {\n            this._clippingManager.release();\n            this._clippingManager = void 0;\n            this._clippingManager = null;\n        }\n        if (this.gl == null) {\n            return;\n        }\n        this.gl.deleteBuffer(this._bufferData.vertex);\n        this._bufferData.vertex = null;\n        this.gl.deleteBuffer(this._bufferData.uv);\n        this._bufferData.uv = null;\n        this.gl.deleteBuffer(this._bufferData.index);\n        this._bufferData.index = null;\n        this._bufferData = null;\n        this._textures = null;\n    }\n    /**\n     * モデルを描画する実際の処理\n     */\n    doDrawModel() {\n        if (this.gl == null) {\n            (0, cubismdebug_1.CubismLogError)(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n            return;\n        }\n        //------------ クリッピングマスク・バッファ前処理方式の場合 ------------\n        if (this._clippingManager != null) {\n            this.preDraw();\n            this._clippingManager.setupClippingContext(this.getModel(), this);\n        }\n        // 上記クリッピング処理内でも一度PreDrawを呼ぶので注意!!\n        this.preDraw();\n        const drawableCount = this.getModel().getDrawableCount();\n        const renderOrder = this.getModel().getDrawableRenderOrders();\n        // インデックスを描画順でソート\n        for (let i = 0; i < drawableCount; ++i) {\n            const order = renderOrder[i];\n            this._sortedDrawableIndexList.set(order, i);\n        }\n        // 描画\n        for (let i = 0; i < drawableCount; ++i) {\n            const drawableIndex = this._sortedDrawableIndexList.at(i);\n            // Drawableが表示状態でなければ処理をパスする\n            if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {\n                continue;\n            }\n            const clipContext = this._clippingManager != null\n                ? this._clippingManager\n                    .getClippingContextListForDraw()\n                    .at(drawableIndex)\n                : null;\n            if (clipContext != null && this.isUsingHighPrecisionMask()) {\n                // 描くことになっていた\n                if (clipContext._isUsing) {\n                    // 生成したFrameBufferと同じサイズでビューポートを設定\n                    this.gl.viewport(0, 0, this._clippingManager.getClippingMaskBufferSize(), this._clippingManager.getClippingMaskBufferSize());\n                    this.preDraw(); // バッファをクリアする\n                    // ---------- マスク描画処理 ----------\n                    // マスク用RenderTextureをactiveにセット\n                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, clipContext\n                        .getClippingManager()\n                        .getMaskRenderTexture()\n                        .at(clipContext._bufferIndex));\n                    // マスクをクリアする\n                    // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n                    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n                }\n                {\n                    const clipDrawCount = clipContext._clippingIdCount;\n                    for (let index = 0; index < clipDrawCount; index++) {\n                        const clipDrawIndex = clipContext._clippingIdList[index];\n                        // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n                        if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n                            continue;\n                        }\n                        this.setIsCulling(this._model.getDrawableCulling(clipDrawIndex) != false);\n                        // 今回専用の変換を適用して描く\n                        // チャンネルも切り替える必要がある(A,R,G,B)\n                        this.setClippingContextBufferForMask(clipContext);\n                        this.drawMesh(this.getModel().getDrawableTextureIndex(clipDrawIndex), this.getModel().getDrawableVertexIndexCount(clipDrawIndex), this.getModel().getDrawableVertexCount(clipDrawIndex), this.getModel().getDrawableVertexIndices(clipDrawIndex), this.getModel().getDrawableVertices(clipDrawIndex), this.getModel().getDrawableVertexUvs(clipDrawIndex), this.getModel().getMultiplyColor(clipDrawIndex), this.getModel().getScreenColor(clipDrawIndex), this.getModel().getDrawableOpacity(clipDrawIndex), cubismrenderer_1.CubismBlendMode.CubismBlendMode_Normal, // クリッピングは通常描画を強制\n                        false // マスク生成時はクリッピングの反転使用は全く関係がない\n                        );\n                    }\n                }\n                {\n                    // --- 後処理 ---\n                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n                    this.setClippingContextBufferForMask(null);\n                    this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n                    this.preDraw(); // バッファをクリアする\n                }\n            }\n            // クリッピングマスクをセットする\n            this.setClippingContextBufferForDraw(clipContext);\n            this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));\n            this.drawMesh(this.getModel().getDrawableTextureIndex(drawableIndex), this.getModel().getDrawableVertexIndexCount(drawableIndex), this.getModel().getDrawableVertexCount(drawableIndex), this.getModel().getDrawableVertexIndices(drawableIndex), this.getModel().getDrawableVertices(drawableIndex), this.getModel().getDrawableVertexUvs(drawableIndex), this.getModel().getMultiplyColor(drawableIndex), this.getModel().getScreenColor(drawableIndex), this.getModel().getDrawableOpacity(drawableIndex), this.getModel().getDrawableBlendMode(drawableIndex), this.getModel().getDrawableInvertedMaskBit(drawableIndex));\n        }\n    }\n    /**\n     * [オーバーライド]\n     * 描画オブジェクト（アートメッシュ）を描画する。\n     * ポリゴンメッシュとテクスチャ番号をセットで渡す。\n     * @param textureNo 描画するテクスチャ番号\n     * @param indexCount 描画オブジェクトのインデックス値\n     * @param vertexCount ポリゴンメッシュの頂点数\n     * @param indexArray ポリゴンメッシュのインデックス配列\n     * @param vertexArray ポリゴンメッシュの頂点配列\n     * @param uvArray uv配列\n     * @param opacity 不透明度\n     * @param colorBlendMode カラー合成タイプ\n     * @param invertedMask マスク使用時のマスクの反転使用\n     */\n    drawMesh(textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, multiplyColor, screenColor, opacity, colorBlendMode, invertedMask) {\n        // 裏面描画の有効・無効\n        if (this.isCulling()) {\n            this.gl.enable(this.gl.CULL_FACE);\n        }\n        else {\n            this.gl.disable(this.gl.CULL_FACE);\n        }\n        this.gl.frontFace(this.gl.CCW); // Cubism SDK OpenGLはマスク・アートメッシュ共にCCWが表面\n        const modelColorRGBA = this.getModelColor();\n        if (this.getClippingContextBufferForMask() == null) {\n            // マスク生成時以外\n            modelColorRGBA.A *= opacity;\n            if (this.isPremultipliedAlpha()) {\n                modelColorRGBA.R *= modelColorRGBA.A;\n                modelColorRGBA.G *= modelColorRGBA.A;\n                modelColorRGBA.B *= modelColorRGBA.A;\n            }\n        }\n        let drawtexture; // シェーダに渡すテクスチャ\n        // テクスチャマップからバインド済みテクスチャＩＤを取得\n        // バインドされていなければダミーのテクスチャIDをセットする\n        if (this._textures.getValue(textureNo) != null) {\n            drawtexture = this._textures.getValue(textureNo);\n        }\n        else {\n            drawtexture = null;\n        }\n        CubismShader_WebGL.getInstance().setupShaderProgram(this, drawtexture, vertexCount, vertexArray, indexArray, uvArray, this._bufferData, opacity, colorBlendMode, modelColorRGBA, multiplyColor, screenColor, this.isPremultipliedAlpha(), this.getMvpMatrix(), invertedMask);\n        // ポリゴンメッシュを描画する\n        this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);\n        // 後処理\n        this.gl.useProgram(null);\n        this.setClippingContextBufferForDraw(null);\n        this.setClippingContextBufferForMask(null);\n    }\n    saveProfile() {\n        this._rendererProfile.save();\n    }\n    restoreProfile() {\n        this._rendererProfile.restore();\n    }\n    /**\n     * レンダラが保持する静的なリソースを解放する\n     * WebGLの静的なシェーダープログラムを解放する\n     */\n    static doStaticRelease() {\n        CubismShader_WebGL.deleteInstance();\n    }\n    /**\n     * レンダーステートを設定する\n     * @param fbo アプリケーション側で指定しているフレームバッファ\n     * @param viewport ビューポート\n     */\n    setRenderState(fbo, viewport) {\n        s_fbo = fbo;\n        s_viewport = viewport;\n    }\n    /**\n     * 描画開始時の追加処理\n     * モデルを描画する前にクリッピングマスクに必要な処理を実装している\n     */\n    preDraw() {\n        if (this.firstDraw) {\n            this.firstDraw = false;\n        }\n        this.gl.disable(this.gl.SCISSOR_TEST);\n        this.gl.disable(this.gl.STENCIL_TEST);\n        this.gl.disable(this.gl.DEPTH_TEST);\n        // カリング（1.0beta3）\n        this.gl.frontFace(this.gl.CW);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.colorMask(true, true, true, true);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // 前にバッファがバインドされていたら破棄する必要がある\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n        // 異方性フィルタリングを適用する\n        if (this.getAnisotropy() > 0.0 && this._extension) {\n            for (let i = 0; i < this._textures.getSize(); ++i) {\n                this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));\n                this.gl.texParameterf(this.gl.TEXTURE_2D, this._extension.TEXTURE_MAX_ANISOTROPY_EXT, this.getAnisotropy());\n            }\n        }\n    }\n    /**\n     * マスクテクスチャに描画するクリッピングコンテキストをセットする\n     */\n    setClippingContextBufferForMask(clip) {\n        this._clippingContextBufferForMask = clip;\n    }\n    /**\n     * マスクテクスチャに描画するクリッピングコンテキストを取得する\n     * @return マスクテクスチャに描画するクリッピングコンテキスト\n     */\n    getClippingContextBufferForMask() {\n        return this._clippingContextBufferForMask;\n    }\n    /**\n     * 画面上に描画するクリッピングコンテキストをセットする\n     */\n    setClippingContextBufferForDraw(clip) {\n        this._clippingContextBufferForDraw = clip;\n    }\n    /**\n     * 画面上に描画するクリッピングコンテキストを取得する\n     * @return 画面上に描画するクリッピングコンテキスト\n     */\n    getClippingContextBufferForDraw() {\n        return this._clippingContextBufferForDraw;\n    }\n    /**\n     * glの設定\n     */\n    startUp(gl) {\n        this.gl = gl;\n        if (this._clippingManager) {\n            this._clippingManager.setGL(gl);\n        }\n        CubismShader_WebGL.getInstance().setGl(gl);\n        this._rendererProfile.setGl(gl);\n        // 異方性フィルタリングが使用できるかチェック\n        this._extension =\n            this.gl.getExtension('EXT_texture_filter_anisotropic') ||\n                this.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||\n                this.gl.getExtension('MOZ_EXT_texture_filter_anisotropic');\n    }\n}\nexports.CubismRenderer_WebGL = CubismRenderer_WebGL;\n/**\n * レンダラが保持する静的なリソースを開放する\n */\ncubismrenderer_1.CubismRenderer.staticRelease = () => {\n    CubismRenderer_WebGL.doStaticRelease();\n};\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismrenderer_webgl */ \"./cubism/Framework/src/rendering/cubismrenderer_webgl.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismClippingContext = $.CubismClippingContext;\n    Live2DCubismFramework.CubismClippingManager_WebGL = $.CubismClippingManager_WebGL;\n    Live2DCubismFramework.CubismRenderTextureResource = $.CubismRenderTextureResource;\n    Live2DCubismFramework.CubismRenderer_WebGL = $.CubismRenderer_WebGL;\n    Live2DCubismFramework.CubismShaderSet = $.CubismShaderSet;\n    Live2DCubismFramework.CubismShader_WebGL = $.CubismShader_WebGL;\n    Live2DCubismFramework.ShaderNames = $.ShaderNames;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/rendering/cubismrenderer_webgl.ts?");

/***/ }),

/***/ "./cubism/Framework/src/type/csmmap.ts":
/*!*********************************************!*\
  !*** ./cubism/Framework/src/type/csmmap.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.iterator = exports.csmMap = exports.csmPair = void 0;\nconst cubismdebug_1 = __webpack_require__(/*! ../utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\n/**\n * Key-Valueのペアを定義するクラス\n * csmMapクラスの内部データで使用する。\n */\nclass csmPair {\n    /**\n     * コンストラクタ\n     * @param key Keyとしてセットする値\n     * @param value Valueとしてセットする値\n     */\n    constructor(key, value) {\n        this.first = key == undefined ? null : key;\n        this.second = value == undefined ? null : value;\n    }\n}\nexports.csmPair = csmPair;\n/**\n * マップ型\n */\nclass csmMap {\n    /**\n     * 引数付きコンストラクタ\n     * @param size 初期化時点で確保するサイズ\n     */\n    constructor(size) {\n        if (size != undefined) {\n            if (size < 1) {\n                this._keyValues = [];\n                this._dummyValue = null;\n                this._size = 0;\n            }\n            else {\n                this._keyValues = new Array(size);\n                this._size = size;\n            }\n        }\n        else {\n            this._keyValues = [];\n            this._dummyValue = null;\n            this._size = 0;\n        }\n    }\n    /**\n     * デストラクタ\n     */\n    release() {\n        this.clear();\n    }\n    /**\n     * キーを追加する\n     * @param key 新たに追加するキー\n     */\n    appendKey(key) {\n        // 新しくKey/Valueのペアを作る\n        this.prepareCapacity(this._size + 1, false); // 1つ以上入る隙間を作る\n        // 新しいkey/valueのインデックスは_size\n        this._keyValues[this._size] = new csmPair(key);\n        this._size += 1;\n    }\n    /**\n     * 添字演算子[key]のオーバーロード(get)\n     * @param key 添字から特定されるValue値\n     */\n    getValue(key) {\n        let found = -1;\n        for (let i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                found = i;\n                break;\n            }\n        }\n        if (found >= 0) {\n            return this._keyValues[found].second;\n        }\n        else {\n            this.appendKey(key); // 新規キーを追加\n            return this._keyValues[this._size - 1].second;\n        }\n    }\n    /**\n     * 添字演算子[key]のオーバーロード(set)\n     * @param key 添字から特定されるValue値\n     * @param value 代入するValue値\n     */\n    setValue(key, value) {\n        let found = -1;\n        for (let i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                found = i;\n                break;\n            }\n        }\n        if (found >= 0) {\n            this._keyValues[found].second = value;\n        }\n        else {\n            this.appendKey(key); // 新規キーを追加\n            this._keyValues[this._size - 1].second = value;\n        }\n    }\n    /**\n     * 引数で渡したKeyを持つ要素が存在するか\n     * @param key 存在を確認するkey\n     * @return true 引数で渡したkeyを持つ要素が存在する\n     * @return false 引数で渡したkeyを持つ要素が存在しない\n     */\n    isExist(key) {\n        for (let i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * keyValueのポインタを全て解放する\n     */\n    clear() {\n        this._keyValues = void 0;\n        this._keyValues = null;\n        this._keyValues = [];\n        this._size = 0;\n    }\n    /**\n     * コンテナのサイズを取得する\n     *\n     * @return コンテナのサイズ\n     */\n    getSize() {\n        return this._size;\n    }\n    /**\n     * コンテナのキャパシティを確保する\n     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない。\n     * @param fitToSize trueなら指定したサイズに合わせる。falseならサイズを2倍確保しておく。\n     */\n    prepareCapacity(newSize, fitToSize) {\n        if (newSize > this._keyValues.length) {\n            if (this._keyValues.length == 0) {\n                if (!fitToSize && newSize < csmMap.DefaultSize)\n                    newSize = csmMap.DefaultSize;\n                this._keyValues.length = newSize;\n            }\n            else {\n                if (!fitToSize && newSize < this._keyValues.length * 2)\n                    newSize = this._keyValues.length * 2;\n                this._keyValues.length = newSize;\n            }\n        }\n    }\n    /**\n     * コンテナの先頭要素を返す\n     */\n    begin() {\n        const ite = new iterator(this, 0);\n        return ite;\n    }\n    /**\n     * コンテナの終端要素を返す\n     */\n    end() {\n        const ite = new iterator(this, this._size); // 終了\n        return ite;\n    }\n    /**\n     * コンテナから要素を削除する\n     *\n     * @param ite 削除する要素\n     */\n    erase(ite) {\n        const index = ite._index;\n        if (index < 0 || this._size <= index) {\n            return ite; // 削除範囲外\n        }\n        // 削除\n        this._keyValues.splice(index, 1);\n        --this._size;\n        const ite2 = new iterator(this, index); // 終了\n        return ite2;\n    }\n    /**\n     * コンテナの値を32ビット符号付き整数型でダンプする\n     */\n    dumpAsInt() {\n        for (let i = 0; i < this._size; i++) {\n            (0, cubismdebug_1.CubismLogDebug)('{0} ,', this._keyValues[i]);\n            (0, cubismdebug_1.CubismLogDebug)('\\n');\n        }\n    }\n}\nexports.csmMap = csmMap;\ncsmMap.DefaultSize = 10; // コンテナの初期化のデフォルトサイズ\n/**\n * csmMap<T>のイテレータ\n */\nclass iterator {\n    /**\n     * コンストラクタ\n     */\n    constructor(v, idx) {\n        this._map = v != undefined ? v : new csmMap();\n        this._index = idx != undefined ? idx : 0;\n    }\n    /**\n     * =演算子のオーバーロード\n     */\n    set(ite) {\n        this._index = ite._index;\n        this._map = ite._map;\n        return this;\n    }\n    /**\n     * 前置き++演算子のオーバーロード\n     */\n    preIncrement() {\n        ++this._index;\n        return this;\n    }\n    /**\n     * 前置き--演算子のオーバーロード\n     */\n    preDecrement() {\n        --this._index;\n        return this;\n    }\n    /**\n     * 後置き++演算子のオーバーロード\n     */\n    increment() {\n        const iteold = new iterator(this._map, this._index++); // 古い値を保存\n        return iteold;\n    }\n    /**\n     * 後置き--演算子のオーバーロード\n     */\n    decrement() {\n        const iteold = new iterator(this._map, this._index); // 古い値を保存\n        this._map = iteold._map;\n        this._index = iteold._index;\n        return this;\n    }\n    /**\n     * *演算子のオーバーロード\n     */\n    ptr() {\n        return this._map._keyValues[this._index];\n    }\n    /**\n     * !=演算\n     */\n    notEqual(ite) {\n        return this._index != ite._index || this._map != ite._map;\n    }\n}\nexports.iterator = iterator;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./csmmap */ \"./cubism/Framework/src/type/csmmap.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmMap = $.csmMap;\n    Live2DCubismFramework.csmPair = $.csmPair;\n    Live2DCubismFramework.iterator = $.iterator;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/type/csmmap.ts?");

/***/ }),

/***/ "./cubism/Framework/src/type/csmrectf.ts":
/*!***********************************************!*\
  !*** ./cubism/Framework/src/type/csmrectf.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.csmRect = void 0;\n/**\n * 矩形形状（座標・長さはfloat値）を定義するクラス\n */\nclass csmRect {\n    /**\n     * コンストラクタ\n     * @param x 左端X座標\n     * @param y 上端Y座標\n     * @param w 幅\n     * @param h 高さ\n     */\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n    }\n    /**\n     * 矩形中央のX座標を取得する\n     */\n    getCenterX() {\n        return this.x + 0.5 * this.width;\n    }\n    /**\n     * 矩形中央のY座標を取得する\n     */\n    getCenterY() {\n        return this.y + 0.5 * this.height;\n    }\n    /**\n     * 右側のX座標を取得する\n     */\n    getRight() {\n        return this.x + this.width;\n    }\n    /**\n     * 下端のY座標を取得する\n     */\n    getBottom() {\n        return this.y + this.height;\n    }\n    /**\n     * 矩形に値をセットする\n     * @param r 矩形のインスタンス\n     */\n    setRect(r) {\n        this.x = r.x;\n        this.y = r.y;\n        this.width = r.width;\n        this.height = r.height;\n    }\n    /**\n     * 矩形中央を軸にして縦横を拡縮する\n     * @param w 幅方向に拡縮する量\n     * @param h 高さ方向に拡縮する量\n     */\n    expand(w, h) {\n        this.x -= w;\n        this.y -= h;\n        this.width += w * 2.0;\n        this.height += h * 2.0;\n    }\n}\nexports.csmRect = csmRect;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./csmrectf */ \"./cubism/Framework/src/type/csmrectf.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmRect = $.csmRect;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/type/csmrectf.ts?");

/***/ }),

/***/ "./cubism/Framework/src/type/csmstring.ts":
/*!************************************************!*\
  !*** ./cubism/Framework/src/type/csmstring.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.csmString = void 0;\n/**\n * 文字列クラス。\n */\nclass csmString {\n    /**\n     * 文字列を後方に追加する\n     *\n     * @param c 追加する文字列\n     * @return 更新された文字列\n     */\n    append(c, length) {\n        this.s += length !== undefined ? c.substr(0, length) : c;\n        return this;\n    }\n    /**\n     * 文字サイズを拡張して文字を埋める\n     * @param length    拡張する文字数\n     * @param v         埋める文字\n     * @return 更新された文字列\n     */\n    expansion(length, v) {\n        for (let i = 0; i < length; i++) {\n            this.append(v);\n        }\n        return this;\n    }\n    /**\n     * 文字列の長さをバイト数で取得する\n     */\n    getBytes() {\n        return encodeURIComponent(this.s).replace(/%../g, 'x').length;\n    }\n    /**\n     * 文字列の長さを返す\n     */\n    getLength() {\n        return this.s.length;\n    }\n    /**\n     * 文字列比較 <\n     * @param s 比較する文字列\n     * @return true:    比較する文字列より小さい\n     * @return false:   比較する文字列より大きい\n     */\n    isLess(s) {\n        return this.s < s.s;\n    }\n    /**\n     * 文字列比較 >\n     * @param s 比較する文字列\n     * @return true:    比較する文字列より大きい\n     * @return false:   比較する文字列より小さい\n     */\n    isGreat(s) {\n        return this.s > s.s;\n    }\n    /**\n     * 文字列比較 ==\n     * @param s 比較する文字列\n     * @return true:    比較する文字列と等しい\n     * @return false:   比較する文字列と異なる\n     */\n    isEqual(s) {\n        return this.s == s;\n    }\n    /**\n     * 文字列が空かどうか\n     * @return true: 空の文字列\n     * @return false: 値が設定されている\n     */\n    isEmpty() {\n        return this.s.length == 0;\n    }\n    /**\n     * 引数付きコンストラクタ\n     */\n    constructor(s) {\n        this.s = s;\n    }\n}\nexports.csmString = csmString;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmString = $.csmString;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/type/csmstring.ts?");

/***/ }),

/***/ "./cubism/Framework/src/type/csmvector.ts":
/*!************************************************!*\
  !*** ./cubism/Framework/src/type/csmvector.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.iterator = exports.csmVector = void 0;\n/**\n * ベクター型（可変配列型）\n */\nclass csmVector {\n    /**\n     * 引数付きコンストラクタ\n     * @param iniitalCapacity 初期化後のキャパシティ。データサイズは_capacity * sizeof(T)\n     * @param zeroClear trueなら初期化時に確保した領域を0で埋める\n     */\n    constructor(initialCapacity = 0) {\n        if (initialCapacity < 1) {\n            this._ptr = [];\n            this._capacity = 0;\n            this._size = 0;\n        }\n        else {\n            this._ptr = new Array(initialCapacity);\n            this._capacity = initialCapacity;\n            this._size = 0;\n        }\n    }\n    /**\n     * インデックスで指定した要素を返す\n     */\n    at(index) {\n        return this._ptr[index];\n    }\n    /**\n     * 要素をセット\n     * @param index 要素をセットするインデックス\n     * @param value セットする要素\n     */\n    set(index, value) {\n        this._ptr[index] = value;\n    }\n    /**\n     * コンテナを取得する\n     */\n    get(offset = 0) {\n        const ret = new Array();\n        for (let i = offset; i < this._size; i++) {\n            ret.push(this._ptr[i]);\n        }\n        return ret;\n    }\n    /**\n     * pushBack処理、コンテナに新たな要素を追加する\n     * @param value PushBack処理で追加する値\n     */\n    pushBack(value) {\n        if (this._size >= this._capacity) {\n            this.prepareCapacity(this._capacity == 0 ? csmVector.s_defaultSize : this._capacity * 2);\n        }\n        this._ptr[this._size++] = value;\n    }\n    /**\n     * コンテナの全要素を解放する\n     */\n    clear() {\n        this._ptr.length = 0;\n        this._size = 0;\n    }\n    /**\n     * コンテナの要素数を返す\n     * @return コンテナの要素数\n     */\n    getSize() {\n        return this._size;\n    }\n    /**\n     * コンテナの全要素に対して代入処理を行う\n     * @param newSize 代入処理後のサイズ\n     * @param value 要素に代入する値\n     */\n    assign(newSize, value) {\n        const curSize = this._size;\n        if (curSize < newSize) {\n            this.prepareCapacity(newSize); // capacity更新\n        }\n        for (let i = 0; i < newSize; i++) {\n            this._ptr[i] = value;\n        }\n        this._size = newSize;\n    }\n    /**\n     * サイズ変更\n     */\n    resize(newSize, value = null) {\n        this.updateSize(newSize, value, true);\n    }\n    /**\n     * サイズ変更\n     */\n    updateSize(newSize, value = null, callPlacementNew = true) {\n        const curSize = this._size;\n        if (curSize < newSize) {\n            this.prepareCapacity(newSize); // capacity更新\n            if (callPlacementNew) {\n                for (let i = this._size; i < newSize; i++) {\n                    if (typeof value == 'function') {\n                        // new\n                        this._ptr[i] = JSON.parse(JSON.stringify(new value()));\n                    } // プリミティブ型なので値渡し\n                    else {\n                        this._ptr[i] = value;\n                    }\n                }\n            }\n            else {\n                for (let i = this._size; i < newSize; i++) {\n                    this._ptr[i] = value;\n                }\n            }\n        }\n        else {\n            // newSize <= this._size\n            //---\n            const sub = this._size - newSize;\n            this._ptr.splice(this._size - sub, sub); // 不要なので破棄する\n        }\n        this._size = newSize;\n    }\n    /**\n     * コンテナにコンテナ要素を挿入する\n     * @param position 挿入する位置\n     * @param begin 挿入するコンテナの開始位置\n     * @param end 挿入するコンテナの終端位置\n     */\n    insert(position, begin, end) {\n        let dstSi = position._index;\n        const srcSi = begin._index;\n        const srcEi = end._index;\n        const addCount = srcEi - srcSi;\n        this.prepareCapacity(this._size + addCount);\n        // 挿入用の既存データをシフトして隙間を作る\n        const addSize = this._size - dstSi;\n        if (addSize > 0) {\n            for (let i = 0; i < addSize; i++) {\n                this._ptr.splice(dstSi + i, 0, null);\n            }\n        }\n        for (let i = srcSi; i < srcEi; i++, dstSi++) {\n            this._ptr[dstSi] = begin._vector._ptr[i];\n        }\n        this._size = this._size + addCount;\n    }\n    /**\n     * コンテナからインデックスで指定した要素を削除する\n     * @param index インデックス値\n     * @return true 削除実行\n     * @return false 削除範囲外\n     */\n    remove(index) {\n        if (index < 0 || this._size <= index) {\n            return false; // 削除範囲外\n        }\n        this._ptr.splice(index, 1);\n        --this._size;\n        return true;\n    }\n    /**\n     * コンテナから要素を削除して他の要素をシフトする\n     * @param ite 削除する要素\n     */\n    erase(ite) {\n        const index = ite._index;\n        if (index < 0 || this._size <= index) {\n            return ite; // 削除範囲外\n        }\n        // 削除\n        this._ptr.splice(index, 1);\n        --this._size;\n        const ite2 = new iterator(this, index); // 終了\n        return ite2;\n    }\n    /**\n     * コンテナのキャパシティを確保する\n     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない.\n     */\n    prepareCapacity(newSize) {\n        if (newSize > this._capacity) {\n            if (this._capacity == 0) {\n                this._ptr = new Array(newSize);\n                this._capacity = newSize;\n            }\n            else {\n                this._ptr.length = newSize;\n                this._capacity = newSize;\n            }\n        }\n    }\n    /**\n     * コンテナの先頭要素を返す\n     */\n    begin() {\n        const ite = this._size == 0 ? this.end() : new iterator(this, 0);\n        return ite;\n    }\n    /**\n     * コンテナの終端要素を返す\n     */\n    end() {\n        const ite = new iterator(this, this._size);\n        return ite;\n    }\n    getOffset(offset) {\n        const newVector = new csmVector();\n        newVector._ptr = this.get(offset);\n        newVector._size = this.get(offset).length;\n        newVector._capacity = this.get(offset).length;\n        return newVector;\n    }\n}\nexports.csmVector = csmVector;\ncsmVector.s_defaultSize = 10; // コンテナ初期化のデフォルトサイズ\nclass iterator {\n    /**\n     * コンストラクタ\n     */\n    constructor(v, index) {\n        this._vector = v != undefined ? v : null;\n        this._index = index != undefined ? index : 0;\n    }\n    /**\n     * 代入\n     */\n    set(ite) {\n        this._index = ite._index;\n        this._vector = ite._vector;\n        return this;\n    }\n    /**\n     * 前置き++演算\n     */\n    preIncrement() {\n        ++this._index;\n        return this;\n    }\n    /**\n     * 前置き--演算\n     */\n    preDecrement() {\n        --this._index;\n        return this;\n    }\n    /**\n     * 後置き++演算子\n     */\n    increment() {\n        const iteold = new iterator(this._vector, this._index++); // 古い値を保存\n        return iteold;\n    }\n    /**\n     * 後置き--演算子\n     */\n    decrement() {\n        const iteold = new iterator(this._vector, this._index--); // 古い値を保存\n        return iteold;\n    }\n    /**\n     * ptr\n     */\n    ptr() {\n        return this._vector._ptr[this._index];\n    }\n    /**\n     * =演算子のオーバーロード\n     */\n    substitution(ite) {\n        this._index = ite._index;\n        this._vector = ite._vector;\n        return this;\n    }\n    /**\n     * !=演算子のオーバーロード\n     */\n    notEqual(ite) {\n        return this._index != ite._index || this._vector != ite._vector;\n    }\n}\nexports.iterator = iterator;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmVector = $.csmVector;\n    Live2DCubismFramework.iterator = $.iterator;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/type/csmvector.ts?");

/***/ }),

/***/ "./cubism/Framework/src/utils/cubismdebug.ts":
/*!***************************************************!*\
  !*** ./cubism/Framework/src/utils/cubismdebug.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.CubismDebug = exports.CubismLogError = exports.CubismLogWarning = exports.CubismLogInfo = exports.CubismLogDebug = exports.CubismLogVerbose = exports.CSM_ASSERT = exports.CubismLogPrintIn = exports.CubismLogPrint = void 0;\nconst cubismframeworkconfig_1 = __webpack_require__(/*! ../cubismframeworkconfig */ \"./cubism/Framework/src/cubismframeworkconfig.ts\");\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst CubismLogPrint = (level, fmt, args) => {\n    CubismDebug.print(level, '[CSM]' + fmt, args);\n};\nexports.CubismLogPrint = CubismLogPrint;\nconst CubismLogPrintIn = (level, fmt, args) => {\n    (0, exports.CubismLogPrint)(level, fmt + '\\n', args);\n};\nexports.CubismLogPrintIn = CubismLogPrintIn;\nconst CSM_ASSERT = (expr) => {\n    console.assert(expr);\n};\nexports.CSM_ASSERT = CSM_ASSERT;\nif (cubismframeworkconfig_1.CSM_LOG_LEVEL <= cubismframeworkconfig_1.CSM_LOG_LEVEL_VERBOSE) {\n    exports.CubismLogVerbose = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Verbose, '[V]' + fmt, args);\n    };\n    exports.CubismLogDebug = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Debug, '[D]' + fmt, args);\n    };\n    exports.CubismLogInfo = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    exports.CubismLogWarning = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    exports.CubismLogError = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (cubismframeworkconfig_1.CSM_LOG_LEVEL == cubismframeworkconfig_1.CSM_LOG_LEVEL_DEBUG) {\n    exports.CubismLogDebug = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Debug, '[D]' + fmt, args);\n    };\n    exports.CubismLogInfo = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    exports.CubismLogWarning = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    exports.CubismLogError = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (cubismframeworkconfig_1.CSM_LOG_LEVEL == cubismframeworkconfig_1.CSM_LOG_LEVEL_INFO) {\n    exports.CubismLogInfo = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    exports.CubismLogWarning = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    exports.CubismLogError = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (cubismframeworkconfig_1.CSM_LOG_LEVEL == cubismframeworkconfig_1.CSM_LOG_LEVEL_WARNING) {\n    exports.CubismLogWarning = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    exports.CubismLogError = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (cubismframeworkconfig_1.CSM_LOG_LEVEL == cubismframeworkconfig_1.CSM_LOG_LEVEL_ERROR) {\n    exports.CubismLogError = (fmt, ...args) => {\n        (0, exports.CubismLogPrintIn)(live2dcubismframework_1.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\n/**\n * デバッグ用のユーティリティクラス。\n * ログの出力、バイトのダンプなど\n */\nclass CubismDebug {\n    /**\n     * ログを出力する。第一引数にログレベルを設定する。\n     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。\n     *\n     * @param logLevel ログレベルの設定\n     * @param format 書式付き文字列\n     * @param args 可変長引数\n     */\n    static print(logLevel, format, args) {\n        // オプションで設定されたログ出力レベルを下回る場合はログに出さない\n        if (logLevel < live2dcubismframework_1.CubismFramework.getLoggingLevel()) {\n            return;\n        }\n        const logPrint = live2dcubismframework_1.CubismFramework.coreLogFunction;\n        if (!logPrint)\n            return;\n        const buffer = format.replace(/\\{(\\d+)\\}/g, (m, k) => {\n            return args[k];\n        });\n        logPrint(buffer);\n    }\n    /**\n     * データから指定した長さだけダンプ出力する。\n     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。\n     *\n     * @param logLevel ログレベルの設定\n     * @param data ダンプするデータ\n     * @param length ダンプする長さ\n     */\n    static dumpBytes(logLevel, data, length) {\n        for (let i = 0; i < length; i++) {\n            if (i % 16 == 0 && i > 0)\n                this.print(logLevel, '\\n');\n            else if (i % 8 == 0 && i > 0)\n                this.print(logLevel, '  ');\n            this.print(logLevel, '{0} ', [data[i] & 0xff]);\n        }\n        this.print(logLevel, '\\n');\n    }\n    /**\n     * private コンストラクタ\n     */\n    constructor() { }\n}\nexports.CubismDebug = CubismDebug;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismDebug = $.CubismDebug;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/utils/cubismdebug.ts?");

/***/ }),

/***/ "./cubism/Framework/src/utils/cubismjson.ts":
/*!**************************************************!*\
  !*** ./cubism/Framework/src/utils/cubismjson.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Live2DCubismFramework = exports.JsonMap = exports.JsonArray = exports.JsonNullvalue = exports.JsonError = exports.JsonString = exports.JsonBoolean = exports.JsonFloat = exports.CubismJson = exports.Value = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst csmmap_1 = __webpack_require__(/*! ../type/csmmap */ \"./cubism/Framework/src/type/csmmap.ts\");\nconst csmstring_1 = __webpack_require__(/*! ../type/csmstring */ \"./cubism/Framework/src/type/csmstring.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ./cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\n// StaticInitializeNotForClientCall()で初期化する\nconst CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\nconst CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\n/**\n * パースしたJSONエレメントの要素の基底クラス。\n */\nclass Value {\n    /**\n     * コンストラクタ\n     */\n    constructor() { }\n    /**\n     * 要素を文字列型で返す(string)\n     */\n    getRawString(defaultValue, indent) {\n        return this.getString(defaultValue, indent);\n    }\n    /**\n     * 要素を数値型で返す(number)\n     */\n    toInt(defaultValue = 0) {\n        return defaultValue;\n    }\n    /**\n     * 要素を数値型で返す(number)\n     */\n    toFloat(defaultValue = 0) {\n        return defaultValue;\n    }\n    /**\n     * 要素を真偽値で返す(boolean)\n     */\n    toBoolean(defaultValue = false) {\n        return defaultValue;\n    }\n    /**\n     * サイズを返す\n     */\n    getSize() {\n        return 0;\n    }\n    /**\n     * 要素を配列で返す(Value[])\n     */\n    getArray(defaultValue = null) {\n        return defaultValue;\n    }\n    /**\n     * 要素をコンテナで返す(array)\n     */\n    getVector(defaultValue = new csmvector_1.csmVector()) {\n        return defaultValue;\n    }\n    /**\n     * 要素をマップで返す(csmMap<csmString, Value>)\n     */\n    getMap(defaultValue) {\n        return defaultValue;\n    }\n    /**\n     * 添字演算子[index]\n     */\n    getValueByIndex(index) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n    /**\n     * 添字演算子[string | csmString]\n     */\n    getValueByString(s) {\n        return Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n    /**\n     * マップのキー一覧をコンテナで返す\n     *\n     * @return マップのキーの一覧\n     */\n    getKeys() {\n        return Value.s_dummyKeys;\n    }\n    /**\n     * Valueの種類がエラー値ならtrue\n     */\n    isError() {\n        return false;\n    }\n    /**\n     * Valueの種類がnullならtrue\n     */\n    isNull() {\n        return false;\n    }\n    /**\n     * Valueの種類が真偽値ならtrue\n     */\n    isBool() {\n        return false;\n    }\n    /**\n     * Valueの種類が数値型ならtrue\n     */\n    isFloat() {\n        return false;\n    }\n    /**\n     * Valueの種類が文字列ならtrue\n     */\n    isString() {\n        return false;\n    }\n    /**\n     * Valueの種類が配列ならtrue\n     */\n    isArray() {\n        return false;\n    }\n    /**\n     * Valueの種類がマップ型ならtrue\n     */\n    isMap() {\n        return false;\n    }\n    equals(value) {\n        return false;\n    }\n    /**\n     * Valueの値が静的ならtrue、静的なら解放しない\n     */\n    isStatic() {\n        return false;\n    }\n    /**\n     * Valueにエラー値をセットする\n     */\n    setErrorNotForClientCall(errorStr) {\n        return JsonError.errorValue;\n    }\n    /**\n     * 初期化用メソッド\n     */\n    static staticInitializeNotForClientCall() {\n        JsonBoolean.trueValue = new JsonBoolean(true);\n        JsonBoolean.falseValue = new JsonBoolean(false);\n        Value.errorValue = new JsonError('ERROR', true);\n        Value.nullValue = new JsonNullvalue();\n        Value.s_dummyKeys = new csmvector_1.csmVector();\n    }\n    /**\n     * リリース用メソッド\n     */\n    static staticReleaseNotForClientCall() {\n        JsonBoolean.trueValue = null;\n        JsonBoolean.falseValue = null;\n        Value.errorValue = null;\n        Value.nullValue = null;\n        Value.s_dummyKeys = null;\n    }\n}\nexports.Value = Value;\n/**\n * Ascii文字のみ対応した最小限の軽量JSONパーサ。\n * 仕様はJSONのサブセットとなる。\n * 設定ファイル(model3.json)などのロード用\n *\n * [未対応項目]\n * ・日本語などの非ASCII文字\n * ・eによる指数表現\n */\nclass CubismJson {\n    /**\n     * コンストラクタ\n     */\n    constructor(buffer, length) {\n        this._parseCallback = cubismjsonextension_1.CubismJsonExtension.parseJsonObject; // パース時に使う処理のコールバック関数\n        this._error = null;\n        this._lineCount = 0;\n        this._root = null;\n        if (buffer != undefined) {\n            this.parseBytes(buffer, length, this._parseCallback);\n        }\n    }\n    /**\n     * バイトデータから直接ロードしてパースする\n     *\n     * @param buffer バッファ\n     * @param size バッファサイズ\n     * @return CubismJsonクラスのインスタンス。失敗したらNULL\n     */\n    static create(buffer, size) {\n        const json = new CubismJson();\n        const succeeded = json.parseBytes(buffer, size, json._parseCallback);\n        if (!succeeded) {\n            CubismJson.delete(json);\n            return null;\n        }\n        else {\n            return json;\n        }\n    }\n    /**\n     * パースしたJSONオブジェクトの解放処理\n     *\n     * @param instance CubismJsonクラスのインスタンス\n     */\n    static delete(instance) {\n        instance = null;\n    }\n    /**\n     * パースしたJSONのルート要素を返す\n     */\n    getRoot() {\n        return this._root;\n    }\n    /**\n     *  UnicodeのバイナリをStringに変換\n     *\n     * @param buffer 変換するバイナリデータ\n     * @return 変換後の文字列\n     */\n    static arrayBufferToString(buffer) {\n        const uint8Array = new Uint8Array(buffer);\n        let str = '';\n        for (let i = 0, len = uint8Array.length; i < len; ++i) {\n            str += '%' + this.pad(uint8Array[i].toString(16));\n        }\n        str = decodeURIComponent(str);\n        return str;\n    }\n    /**\n     * エンコード、パディング\n     */\n    static pad(n) {\n        return n.length < 2 ? '0' + n : n;\n    }\n    /**\n     * JSONのパースを実行する\n     * @param buffer    パース対象のデータバイト\n     * @param size      データバイトのサイズ\n     * return true : 成功\n     * return false: 失敗\n     */\n    parseBytes(buffer, size, parseCallback) {\n        const endPos = new Array(1); // 参照渡しにするため配列\n        const decodeBuffer = CubismJson.arrayBufferToString(buffer);\n        if (parseCallback == undefined) {\n            this._root = this.parseValue(decodeBuffer, size, 0, endPos);\n        }\n        else {\n            // TypeScript標準のJSONパーサを使う\n            this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());\n        }\n        if (this._error) {\n            let strbuf = '\\0';\n            strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\n            this._root = new JsonString(strbuf);\n            (0, cubismdebug_1.CubismLogInfo)('{0}', this._root.getRawString());\n            return false;\n        }\n        else if (this._root == null) {\n            this._root = new JsonError(new csmstring_1.csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\n            return false;\n        }\n        return true;\n    }\n    /**\n     * パース時のエラー値を返す\n     */\n    getParseError() {\n        return this._error;\n    }\n    /**\n     * ルート要素の次の要素がファイルの終端だったらtrueを返す\n     */\n    checkEndOfFile() {\n        return this._root.getArray()[1].equals('EOF');\n    }\n    /**\n     * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\n     * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\n     *\n     * @param   buffer      JSONエレメントのバッファ\n     * @param   length      パースする長さ\n     * @param   begin       パースを開始する位置\n     * @param   outEndPos   パース終了時の位置\n     * @return      パースから取得したValueオブジェクト\n     */\n    parseValue(buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        let o = null;\n        let i = begin;\n        let f;\n        for (; i < length; i++) {\n            const c = buffer[i];\n            switch (c) {\n                case '-':\n                case '.':\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9': {\n                    const afterString = new Array(1); // 参照渡しにするため\n                    f = (0, live2dcubismframework_1.strtod)(buffer.slice(i), afterString);\n                    outEndPos[0] = buffer.indexOf(afterString[0]);\n                    return new JsonFloat(f);\n                }\n                case '\"':\n                    return new JsonString(this.parseString(buffer, length, i + 1, outEndPos)); // \\\"の次の文字から\n                case '[':\n                    o = this.parseArray(buffer, length, i + 1, outEndPos);\n                    return o;\n                case '{':\n                    o = this.parseObject(buffer, length, i + 1, outEndPos);\n                    return o;\n                case 'n': // null以外にない\n                    if (i + 3 < length) {\n                        o = new JsonNullvalue(); // 解放できるようにする\n                        outEndPos[0] = i + 4;\n                    }\n                    else {\n                        this._error = 'parse null';\n                    }\n                    return o;\n                case 't': // true以外にない\n                    if (i + 3 < length) {\n                        o = JsonBoolean.trueValue;\n                        outEndPos[0] = i + 4;\n                    }\n                    else {\n                        this._error = 'parse true';\n                    }\n                    return o;\n                case 'f': // false以外にない\n                    if (i + 4 < length) {\n                        o = JsonBoolean.falseValue;\n                        outEndPos[0] = i + 5;\n                    }\n                    else {\n                        this._error = \"illegal ',' position\";\n                    }\n                    return o;\n                case ',': // Array separator\n                    this._error = \"illegal ',' position\";\n                    return null;\n                case ']': // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\n                    outEndPos[0] = i; // 同じ文字を再処理\n                    return null;\n                case '\\n':\n                    this._lineCount++;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                default:\n                    // スキップ\n                    break;\n            }\n        }\n        this._error = 'illegal end of value';\n        return null;\n    }\n    /**\n     * 次の「\"」までの文字列をパースする。\n     *\n     * @param   string  ->  パース対象の文字列\n     * @param   length  ->  パースする長さ\n     * @param   begin   ->  パースを開始する位置\n     * @param  outEndPos   ->  パース終了時の位置\n     * @return      パースした文F字列要素\n     */\n    parseString(string, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        let i = begin;\n        let c, c2;\n        const ret = new csmstring_1.csmString('');\n        let bufStart = begin; // sbufに登録されていない文字の開始位置\n        for (; i < length; i++) {\n            c = string[i];\n            switch (c) {\n                case '\"': {\n                    // 終端の”、エスケープ文字は別に処理されるのでここに来ない\n                    outEndPos[0] = i + 1; // ”の次の文字\n                    ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n                    return ret.s;\n                }\n                case '//': {\n                    // エスケープの場合\n                    i++; // ２文字をセットで扱う\n                    if (i - 1 > bufStart) {\n                        ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n                    }\n                    bufStart = i + 1; // エスケープ（２文字)の次の文字から\n                    if (i < length) {\n                        c2 = string[i];\n                        switch (c2) {\n                            case '\\\\':\n                                ret.expansion(1, '\\\\');\n                                break;\n                            case '\"':\n                                ret.expansion(1, '\"');\n                                break;\n                            case '/':\n                                ret.expansion(1, '/');\n                                break;\n                            case 'b':\n                                ret.expansion(1, '\\b');\n                                break;\n                            case 'f':\n                                ret.expansion(1, '\\f');\n                                break;\n                            case 'n':\n                                ret.expansion(1, '\\n');\n                                break;\n                            case 'r':\n                                ret.expansion(1, '\\r');\n                                break;\n                            case 't':\n                                ret.expansion(1, '\\t');\n                                break;\n                            case 'u':\n                                this._error = 'parse string/unicord escape not supported';\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                    else {\n                        this._error = 'parse string/escape error';\n                    }\n                }\n                default: {\n                    break;\n                }\n            }\n        }\n        this._error = 'parse string/illegal end';\n        return null;\n    }\n    /**\n     * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\n     *\n     * @param buffer    JSONエレメントのバッファ\n     * @param length    パースする長さ\n     * @param begin     パースを開始する位置\n     * @param outEndPos パース終了時の位置\n     * @return パースから取得したValueオブジェクト\n     */\n    parseObject(buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        const ret = new JsonMap();\n        // Key: Value\n        let key = '';\n        let i = begin;\n        let c = '';\n        const localRetEndPos2 = Array(1);\n        let ok = false;\n        // , が続く限りループ\n        for (; i < length; i++) {\n            FOR_LOOP: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case '\"':\n                        key = this.parseString(buffer, length, i + 1, localRetEndPos2);\n                        if (this._error) {\n                            return null;\n                        }\n                        i = localRetEndPos2[0];\n                        ok = true;\n                        break FOR_LOOP; //-- loopから出る\n                    case '}': // 閉じカッコ\n                        outEndPos[0] = i + 1;\n                        return ret; // 空\n                    case ':':\n                        this._error = \"illegal ':' position\";\n                        break;\n                    case '\\n':\n                        this._lineCount++;\n                    default:\n                        break; // スキップする文字\n                }\n            }\n            if (!ok) {\n                this._error = 'key not found';\n                return null;\n            }\n            ok = false;\n            // : をチェック\n            FOR_LOOP2: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ':':\n                        ok = true;\n                        i++;\n                        break FOR_LOOP2;\n                    case '}':\n                        this._error = \"illegal '}' position\";\n                        break;\n                    case '\\n':\n                        this._lineCount++;\n                    // case ' ': case '\\t' : case '\\r':\n                    default:\n                        break; // スキップする文字\n                }\n            }\n            if (!ok) {\n                this._error = \"':' not found\";\n                return null;\n            }\n            // 値をチェック\n            const value = this.parseValue(buffer, length, i, localRetEndPos2);\n            if (this._error) {\n                return null;\n            }\n            i = localRetEndPos2[0];\n            // ret.put(key, value);\n            ret.put(key, value);\n            FOR_LOOP3: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ',':\n                        break FOR_LOOP3;\n                    case '}':\n                        outEndPos[0] = i + 1;\n                        return ret; // 正常終了\n                    case '\\n':\n                        this._lineCount++;\n                    default:\n                        break; // スキップ\n                }\n            }\n        }\n        this._error = 'illegal end of perseObject';\n        return null;\n    }\n    /**\n     * 次の「\"」までの文字列をパースする。\n     * @param buffer    JSONエレメントのバッファ\n     * @param length    パースする長さ\n     * @param begin     パースを開始する位置\n     * @param outEndPos パース終了時の位置\n     * @return パースから取得したValueオブジェクト\n     */\n    parseArray(buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        let ret = new JsonArray();\n        // key : value\n        let i = begin;\n        let c;\n        const localRetEndpos2 = new Array(1);\n        // , が続く限りループ\n        for (; i < length; i++) {\n            // : をチェック\n            const value = this.parseValue(buffer, length, i, localRetEndpos2);\n            if (this._error) {\n                return null;\n            }\n            i = localRetEndpos2[0];\n            if (value) {\n                ret.add(value);\n            }\n            // FOR_LOOP3:\n            // boolean breakflag = false;\n            FOR_LOOP: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ',':\n                        // breakflag = true;\n                        // break; // 次のKEY, VAlUEへ\n                        break FOR_LOOP;\n                    case ']':\n                        outEndPos[0] = i + 1;\n                        return ret; // 終了\n                    case '\\n':\n                        ++this._lineCount;\n                    //case ' ': case '\\t': case '\\r':\n                    default:\n                        break; // スキップ\n                }\n            }\n        }\n        ret = void 0;\n        this._error = 'illegal end of parseObject';\n        return null;\n    }\n}\nexports.CubismJson = CubismJson;\n/**\n * パースしたJSONの要素をfloat値として扱う\n */\nclass JsonFloat extends Value {\n    /**\n     * コンストラクタ\n     */\n    constructor(v) {\n        super();\n        this._value = v;\n    }\n    /**\n     * Valueの種類が数値型ならtrue\n     */\n    isFloat() {\n        return true;\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        const strbuf = '\\0';\n        this._value = parseFloat(strbuf);\n        this._stringBuffer = strbuf;\n        return this._stringBuffer;\n    }\n    /**\n     * 要素を数値型で返す(number)\n     */\n    toInt(defaultValue = 0) {\n        return parseInt(this._value.toString());\n    }\n    /**\n     * 要素を数値型で返す(number)\n     */\n    toFloat(defaultValue = 0.0) {\n        return this._value;\n    }\n    equals(value) {\n        if ('number' === typeof value) {\n            // int\n            if (Math.round(value)) {\n                return false;\n            }\n            // float\n            else {\n                return value == this._value;\n            }\n        }\n        return false;\n    }\n}\nexports.JsonFloat = JsonFloat;\n/**\n * パースしたJSONの要素を真偽値として扱う\n */\nclass JsonBoolean extends Value {\n    /**\n     * Valueの種類が真偽値ならtrue\n     */\n    isBool() {\n        return true;\n    }\n    /**\n     * 要素を真偽値で返す(boolean)\n     */\n    toBoolean(defaultValue = false) {\n        return this._boolValue;\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        this._stringBuffer = this._boolValue ? 'true' : 'false';\n        return this._stringBuffer;\n    }\n    equals(value) {\n        if ('boolean' === typeof value) {\n            return value == this._boolValue;\n        }\n        return false;\n    }\n    /**\n     * Valueの値が静的ならtrue, 静的なら解放しない\n     */\n    isStatic() {\n        return true;\n    }\n    /**\n     * 引数付きコンストラクタ\n     */\n    constructor(v) {\n        super();\n        this._boolValue = v;\n    }\n}\nexports.JsonBoolean = JsonBoolean;\n/**\n * パースしたJSONの要素を文字列として扱う\n */\nclass JsonString extends Value {\n    constructor(s) {\n        super();\n        if ('string' === typeof s) {\n            this._stringBuffer = s;\n        }\n        if (s instanceof csmstring_1.csmString) {\n            this._stringBuffer = s.s;\n        }\n    }\n    /**\n     * Valueの種類が文字列ならtrue\n     */\n    isString() {\n        return true;\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        return this._stringBuffer;\n    }\n    equals(value) {\n        if ('string' === typeof value) {\n            return this._stringBuffer == value;\n        }\n        if (value instanceof csmstring_1.csmString) {\n            return this._stringBuffer == value.s;\n        }\n        return false;\n    }\n}\nexports.JsonString = JsonString;\n/**\n * JSONパース時のエラー結果。文字列型のようにふるまう\n */\nclass JsonError extends JsonString {\n    /**\n     * Valueの値が静的ならtrue、静的なら解放しない\n     */\n    isStatic() {\n        return this._isStatic;\n    }\n    /**\n     * エラー情報をセットする\n     */\n    setErrorNotForClientCall(s) {\n        this._stringBuffer = s;\n        return this;\n    }\n    /**\n     * 引数付きコンストラクタ\n     */\n    constructor(s, isStatic) {\n        if ('string' === typeof s) {\n            super(s);\n        }\n        else {\n            super(s);\n        }\n        this._isStatic = isStatic;\n    }\n    /**\n     * Valueの種類がエラー値ならtrue\n     */\n    isError() {\n        return true;\n    }\n}\nexports.JsonError = JsonError;\n/**\n * パースしたJSONの要素をNULL値として持つ\n */\nclass JsonNullvalue extends Value {\n    /**\n     * Valueの種類がNULL値ならtrue\n     */\n    isNull() {\n        return true;\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        return this._stringBuffer;\n    }\n    /**\n     * Valueの値が静的ならtrue, 静的なら解放しない\n     */\n    isStatic() {\n        return true;\n    }\n    /**\n     * Valueにエラー値をセットする\n     */\n    setErrorNotForClientCall(s) {\n        this._stringBuffer = s;\n        return JsonError.nullValue;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._stringBuffer = 'NullValue';\n    }\n}\nexports.JsonNullvalue = JsonNullvalue;\n/**\n * パースしたJSONの要素を配列として持つ\n */\nclass JsonArray extends Value {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._array = new csmvector_1.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {\n            let v = ite.ptr();\n            if (v && !v.isStatic()) {\n                v = void 0;\n                v = null;\n            }\n        }\n    }\n    /**\n     * Valueの種類が配列ならtrue\n     */\n    isArray() {\n        return true;\n    }\n    /**\n     * 添字演算子[index]\n     */\n    getValueByIndex(index) {\n        if (index < 0 || this._array.getSize() <= index) {\n            return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);\n        }\n        const v = this._array.at(index);\n        if (v == null) {\n            return Value.nullValue;\n        }\n        return v;\n    }\n    /**\n     * 添字演算子[string | csmString]\n     */\n    getValueByString(s) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        const stringBuffer = indent + '[\\n';\n        for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {\n            const v = ite.ptr();\n            this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\n        }\n        this._stringBuffer = stringBuffer + indent + ']\\n';\n        return this._stringBuffer;\n    }\n    /**\n     * 配列要素を追加する\n     * @param v 追加する要素\n     */\n    add(v) {\n        this._array.pushBack(v);\n    }\n    /**\n     * 要素をコンテナで返す(csmVector<Value>)\n     */\n    getVector(defaultValue = null) {\n        return this._array;\n    }\n    /**\n     * 要素の数を返す\n     */\n    getSize() {\n        return this._array.getSize();\n    }\n}\nexports.JsonArray = JsonArray;\n/**\n * パースしたJSONの要素をマップとして持つ\n */\nclass JsonMap extends Value {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._map = new csmmap_1.csmMap();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    release() {\n        const ite = this._map.begin();\n        while (ite.notEqual(this._map.end())) {\n            let v = ite.ptr().second;\n            if (v && !v.isStatic()) {\n                v = void 0;\n                v = null;\n            }\n            ite.preIncrement();\n        }\n    }\n    /**\n     * Valueの値がMap型ならtrue\n     */\n    isMap() {\n        return true;\n    }\n    /**\n     * 添字演算子[string | csmString]\n     */\n    getValueByString(s) {\n        if (s instanceof csmstring_1.csmString) {\n            const ret = this._map.getValue(s.s);\n            if (ret == null) {\n                return Value.nullValue;\n            }\n            return ret;\n        }\n        for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {\n            if (iter.ptr().first == s) {\n                if (iter.ptr().second == null) {\n                    return Value.nullValue;\n                }\n                return iter.ptr().second;\n            }\n        }\n        return Value.nullValue;\n    }\n    /**\n     * 添字演算子[index]\n     */\n    getValueByIndex(index) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    getString(defaultValue, indent) {\n        this._stringBuffer = indent + '{\\n';\n        const ite = this._map.begin();\n        while (ite.notEqual(this._map.end())) {\n            const key = ite.ptr().first;\n            const v = ite.ptr().second;\n            this._stringBuffer +=\n                indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\n            ite.preIncrement();\n        }\n        this._stringBuffer += indent + '}\\n';\n        return this._stringBuffer;\n    }\n    /**\n     * 要素をMap型で返す\n     */\n    getMap(defaultValue) {\n        return this._map;\n    }\n    /**\n     * Mapに要素を追加する\n     */\n    put(key, v) {\n        this._map.setValue(key, v);\n    }\n    /**\n     * Mapからキーのリストを取得する\n     */\n    getKeys() {\n        if (!this._keys) {\n            this._keys = new csmvector_1.csmVector();\n            const ite = this._map.begin();\n            while (ite.notEqual(this._map.end())) {\n                const key = ite.ptr().first;\n                this._keys.pushBack(key);\n                ite.preIncrement();\n            }\n        }\n        return this._keys;\n    }\n    /**\n     * Mapの要素数を取得する\n     */\n    getSize() {\n        return this._keys.getSize();\n    }\n}\nexports.JsonMap = JsonMap;\n// Namespace definition for compatibility.\nconst $ = __webpack_require__(/*! ./cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\nconst cubismjsonextension_1 = __webpack_require__(/*! ./cubismjsonextension */ \"./cubism/Framework/src/utils/cubismjsonextension.ts\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismJson = $.CubismJson;\n    Live2DCubismFramework.JsonArray = $.JsonArray;\n    Live2DCubismFramework.JsonBoolean = $.JsonBoolean;\n    Live2DCubismFramework.JsonError = $.JsonError;\n    Live2DCubismFramework.JsonFloat = $.JsonFloat;\n    Live2DCubismFramework.JsonMap = $.JsonMap;\n    Live2DCubismFramework.JsonNullvalue = $.JsonNullvalue;\n    Live2DCubismFramework.JsonString = $.JsonString;\n    Live2DCubismFramework.Value = $.Value;\n})(Live2DCubismFramework || (exports.Live2DCubismFramework = Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/utils/cubismjson.ts?");

/***/ }),

/***/ "./cubism/Framework/src/utils/cubismjsonextension.ts":
/*!***********************************************************!*\
  !*** ./cubism/Framework/src/utils/cubismjsonextension.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CubismJsonExtension = void 0;\nconst cubismjson_1 = __webpack_require__(/*! ./cubismjson */ \"./cubism/Framework/src/utils/cubismjson.ts\");\n/**\n * CubismJsonで実装されているJsonパーサを使用せず、\n * TypeScript標準のJsonパーサなどを使用し出力された結果を\n * Cubism SDKで定義されているJSONエレメントの要素に\n * 置き換える処理をするクラス。\n */\nclass CubismJsonExtension {\n    static parseJsonObject(obj, map) {\n        Object.keys(obj).forEach((key) => {\n            if (typeof obj[key] == 'boolean') {\n                const convValue = Boolean(obj[key]);\n                map.put(key, new cubismjson_1.JsonBoolean(convValue));\n            }\n            else if (typeof obj[key] == 'string') {\n                const convValue = String(obj[key]);\n                map.put(key, new cubismjson_1.JsonString(convValue));\n            }\n            else if (typeof obj[key] == 'number') {\n                const convValue = Number(obj[key]);\n                map.put(key, new cubismjson_1.JsonFloat(convValue));\n            }\n            else if (obj[key] instanceof Array) {\n                map.put(key, CubismJsonExtension.parseJsonArray(obj[key]));\n            }\n            else if (obj[key] instanceof Object) {\n                map.put(key, CubismJsonExtension.parseJsonObject(obj[key], new cubismjson_1.JsonMap()));\n            }\n            else if (obj[key] == null) {\n                map.put(key, new cubismjson_1.JsonNullvalue());\n            }\n            else {\n                // どれにも当てはまらない場合でも処理する\n                map.put(key, obj[key]);\n            }\n        });\n        return map;\n    }\n    static parseJsonArray(obj) {\n        const arr = new cubismjson_1.JsonArray();\n        Object.keys(obj).forEach((key) => {\n            const convKey = Number(key);\n            if (typeof convKey == 'number') {\n                if (typeof obj[key] == 'boolean') {\n                    const convValue = Boolean(obj[key]);\n                    arr.add(new cubismjson_1.JsonBoolean(convValue));\n                }\n                else if (typeof obj[key] == 'string') {\n                    const convValue = String(obj[key]);\n                    arr.add(new cubismjson_1.JsonString(convValue));\n                }\n                else if (typeof obj[key] == 'number') {\n                    const convValue = Number(obj[key]);\n                    arr.add(new cubismjson_1.JsonFloat(convValue));\n                }\n                else if (obj[key] instanceof Array) {\n                    arr.add(this.parseJsonArray(obj[key]));\n                }\n                else if (obj[key] instanceof Object) {\n                    arr.add(this.parseJsonObject(obj[key], new cubismjson_1.JsonMap()));\n                }\n                else if (obj[key] == null) {\n                    arr.add(new cubismjson_1.JsonNullvalue());\n                }\n                else {\n                    // どれにも当てはまらない場合でも処理する\n                    arr.add(obj[key]);\n                }\n            }\n            else if (obj[key] instanceof Array) {\n                arr.add(this.parseJsonArray(obj[key]));\n            }\n            else if (obj[key] instanceof Object) {\n                arr.add(this.parseJsonObject(obj[key], new cubismjson_1.JsonMap()));\n            }\n            else if (obj[key] == null) {\n                arr.add(new cubismjson_1.JsonNullvalue());\n            }\n            else {\n                const convValue = Array(obj[key]);\n                // 配列ともObjectとも判定できなかった場合でも処理する\n                for (let i = 0; i < convValue.length; i++) {\n                    arr.add(convValue[i]);\n                }\n            }\n        });\n        return arr;\n    }\n}\nexports.CubismJsonExtension = CubismJsonExtension;\n\n\n//# sourceURL=webpack:///./cubism/Framework/src/utils/cubismjsonextension.ts?");

/***/ }),

/***/ "./src/live2d/lappdefine.ts":
/*!**********************************!*\
  !*** ./src/live2d/lappdefine.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderTargetHeight = exports.RenderTargetWidth = exports.CubismLoggingLevel = exports.DebugTouchLogEnable = exports.DebugLogEnable = exports.MOCConsistencyValidationEnable = exports.PriorityForce = exports.PriorityNormal = exports.PriorityIdle = exports.PriorityNone = exports.HitAreaNameBody = exports.HitAreaNameHead = exports.MotionGroupTapBody = exports.MotionGroupIdle = exports.ModelDirSize = exports.ModelDir = exports.PowerImageName = exports.GearImageName = exports.BackImageName = exports.ResourcesPath = exports.ViewLogicalMaxTop = exports.ViewLogicalMaxBottom = exports.ViewLogicalMaxRight = exports.ViewLogicalMaxLeft = exports.ViewLogicalTop = exports.ViewLogicalBottom = exports.ViewLogicalRight = exports.ViewLogicalLeft = exports.ViewMinScale = exports.ViewMaxScale = exports.ViewScale = exports.CanvasSize = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../../cubism/Framework/src/live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\n/**\n * Sample Appで使用する定数\n */\n// Canvas width and height pixel values, or dynamic screen size ('auto').\nexports.CanvasSize = 'auto';\n// 画面\nexports.ViewScale = 1.0;\nexports.ViewMaxScale = 2.0;\nexports.ViewMinScale = 0.8;\nexports.ViewLogicalLeft = -1.0;\nexports.ViewLogicalRight = 1.0;\nexports.ViewLogicalBottom = -1.0;\nexports.ViewLogicalTop = 1.0;\nexports.ViewLogicalMaxLeft = -2.0;\nexports.ViewLogicalMaxRight = 2.0;\nexports.ViewLogicalMaxBottom = -2.0;\nexports.ViewLogicalMaxTop = 2.0;\n// 相対パス\nexports.ResourcesPath = '/assets/';\n// モデルの後ろにある背景の画像ファイル\nexports.BackImageName = 'back_class_normal.png';\n// 歯車\nexports.GearImageName = 'icon_gear.png';\n// 終了ボタン\nexports.PowerImageName = 'CloseNormal.png';\n// モデル定義---------------------------------------------\n// モデルを配置したディレクトリ名の配列\n// ディレクトリ名とmodel3.jsonの名前を一致させておくこと\nexports.ModelDir = [\n    'hgkoazarasi',\n    'Haru',\n    'Hiyori',\n    'Mark',\n    'Natori',\n    'Rice',\n    'Mao'\n];\nexports.ModelDirSize = exports.ModelDir.length;\n// 外部定義ファイル（json）と合わせる\nexports.MotionGroupIdle = 'Idle'; // アイドリング\nexports.MotionGroupTapBody = 'TapBody'; // 体をタップしたとき\n// 外部定義ファイル（json）と合わせる\nexports.HitAreaNameHead = 'Head';\nexports.HitAreaNameBody = 'Body';\n// モーションの優先度定数\nexports.PriorityNone = 0;\nexports.PriorityIdle = 1;\nexports.PriorityNormal = 2;\nexports.PriorityForce = 3;\n// MOC3の一貫性検証オプション\nexports.MOCConsistencyValidationEnable = true;\n// デバッグ用ログの表示オプション\nexports.DebugLogEnable = true;\nexports.DebugTouchLogEnable = false;\n// Frameworkから出力するログのレベル設定\nexports.CubismLoggingLevel = live2dcubismframework_1.LogLevel.LogLevel_Verbose;\n// デフォルトのレンダーターゲットサイズ\nexports.RenderTargetWidth = 1900;\nexports.RenderTargetHeight = 1000;\n\n\n//# sourceURL=webpack:///./src/live2d/lappdefine.ts?");

/***/ }),

/***/ "./src/live2d/lappdelegate.ts":
/*!************************************!*\
  !*** ./src/live2d/lappdelegate.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.onTouchCancel = exports.onTouchEnded = exports.onTouchMoved = exports.onTouchBegan = exports.onClickEnded = exports.onMouseMoved = exports.onClickBegan = exports.LAppDelegate = exports.s_instance = void 0;\nconst live2dcubismframework_1 = __webpack_require__(/*! ../../cubism/Framework/src/live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst LAppDefine = __webpack_require__(/*! ./lappdefine */ \"./src/live2d/lappdefine.ts\");\nconst lapplive2dmanager_1 = __webpack_require__(/*! ./lapplive2dmanager */ \"./src/live2d/lapplive2dmanager.ts\");\nconst lapppal_1 = __webpack_require__(/*! ./lapppal */ \"./src/live2d/lapppal.ts\");\nconst lapptexturemanager_1 = __webpack_require__(/*! ./lapptexturemanager */ \"./src/live2d/lapptexturemanager.ts\");\nconst lappview_1 = __webpack_require__(/*! ./lappview */ \"./src/live2d/lappview.ts\");\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\n//export let canvas: HTMLCanvasElement = null;\nexports.s_instance = null;\n//export let gl: WebGLRenderingContext = null;\n//export let frameBuffer: WebGLFramebuffer = null;\n/**\n * アプリケーションクラス。\n * Cubism SDKの管理を行う。\n */\nclass LAppDelegate {\n    /**\n     * クラスのインスタンス（シングルトン）を返す。\n     * インスタンスが生成されていない場合は内部でインスタンスを生成する。\n     *\n     * @return クラスのインスタンス\n     */\n    static getInstance() {\n        if (exports.s_instance == null) {\n            exports.s_instance = new LAppDelegate();\n        }\n        return exports.s_instance;\n    }\n    /**\n     * クラスのインスタンス（シングルトン）を解放する。\n     */\n    static releaseInstance() {\n        if (exports.s_instance != null) {\n            exports.s_instance.release();\n        }\n        exports.s_instance = null;\n    }\n    initialize() {\n        // キャンバスの作成\n        //  canvas = document.createElement('canvas');\n        // if (LAppDefine.CanvasSize === 'auto') {\n        this._resizeCanvas();\n        // } else {\n        //   canvas.width = LAppDefine.CanvasSize.width;\n        //   canvas.height = LAppDefine.CanvasSize.height;\n        // }\n        // glコンテキストを初期化\n        // @ts-ignore\n        //gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        /*\n        if (!gl) {\n          alert('Cannot initialize WebGL. This browser does not support.');\n          gl = null;\n    \n          document.body.innerHTML =\n            'This browser does not support the <code>&lt;canvas&gt;</code> element.';\n    \n          // gl初期化失敗\n          return false;\n        }\n        */\n        // キャンバスを DOM に追加\n        //document.body.appendChild(canvas);\n        /*\n            if (!frameBuffer) {\n              frameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n            }\n        \n            // 透過設定\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        \n            const supportTouch: boolean = 'ontouchend' in canvas;\n        \n            if (supportTouch) {\n              // タッチ関連コールバック関数登録\n              canvas.ontouchstart = onTouchBegan;\n              canvas.ontouchmove = onTouchMoved;\n              canvas.ontouchend = onTouchEnded;\n              canvas.ontouchcancel = onTouchCancel;\n            } else {\n              // マウス関連コールバック関数登録\n              canvas.onmousedown = onClickBegan;\n              canvas.onmousemove = onMouseMoved;\n              canvas.onmouseup = onClickEnded;\n            }\n        */\n        // AppViewの初期化\n        this._view.initialize();\n        // Cubism SDKの初期化\n        this.initializeCubism();\n        return true;\n    }\n    /**\n     * Resize canvas and re-initialize view.\n     */\n    onResize() {\n        this._resizeCanvas();\n        this._view.initialize();\n        this._view.initializeSprite();\n        // キャンバスサイズを渡す\n        const viewport = [0, 0, main_1.canvas.width, main_1.canvas.height];\n        main_1.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);\n    }\n    /**\n     * 解放する。\n     */\n    release() {\n        this._textureManager.release();\n        this._textureManager = null;\n        this._view.release();\n        this._view = null;\n        // リソースを解放\n        lapplive2dmanager_1.LAppLive2DManager.releaseInstance();\n        // Cubism SDKの解放\n        live2dcubismframework_1.CubismFramework.dispose();\n    }\n    /**\n     * 実行処理。\n     */\n    /* public run(): void {\n       // メインループ\n       const loop = (): void => {\n         // インスタンスの有無の確認\n         if (s_instance == null) {\n           return;\n         }\n   \n         // 時間更新\n         LAppPal.updateTime();\n   \n         // 画面の初期化\n         gl.clearColor(0.0, 0.0, 0.0, 1.0);\n   \n         // 深度テストを有効化\n         gl.enable(gl.DEPTH_TEST);\n   \n         // 近くにある物体は、遠くにある物体を覆い隠す\n         gl.depthFunc(gl.LEQUAL);\n   \n         // カラーバッファや深度バッファをクリアする\n         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n   \n         gl.clearDepth(1.0);\n   \n         // 透過設定\n         gl.enable(gl.BLEND);\n         gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n   \n         // 描画更新\n         this._view.render();\n   \n         // ループのために再帰呼び出し\n         requestAnimationFrame(loop);\n       };\n       loop();\n     } */\n    render() {\n        // 時間更新\n        lapppal_1.LAppPal.updateTime();\n        // 透過設定\n        main_1.gl.enable(main_1.gl.BLEND);\n        main_1.gl.blendFunc(main_1.gl.SRC_ALPHA, main_1.gl.ONE_MINUS_SRC_ALPHA);\n        // 描画更新\n        this._view.render();\n    }\n    /**\n     * シェーダーを登録する。\n     */\n    createShader() {\n        // バーテックスシェーダーのコンパイル\n        const vertexShaderId = main_1.gl.createShader(main_1.gl.VERTEX_SHADER);\n        if (vertexShaderId == null) {\n            lapppal_1.LAppPal.printMessage('failed to create vertexShader');\n            return null;\n        }\n        const vertexShader = 'precision mediump float;' +\n            'attribute vec3 position;' +\n            'attribute vec2 uv;' +\n            'varying vec2 vuv;' +\n            'void main(void)' +\n            '{' +\n            '   gl_Position = vec4(position, 1.0);' +\n            '   vuv = uv;' +\n            '}';\n        main_1.gl.shaderSource(vertexShaderId, vertexShader);\n        main_1.gl.compileShader(vertexShaderId);\n        // フラグメントシェーダのコンパイル\n        const fragmentShaderId = main_1.gl.createShader(main_1.gl.FRAGMENT_SHADER);\n        if (fragmentShaderId == null) {\n            lapppal_1.LAppPal.printMessage('failed to create fragmentShader');\n            return null;\n        }\n        const fragmentShader = 'precision mediump float;' +\n            'varying vec2 vuv;' +\n            'uniform sampler2D texture;' +\n            'void main(void)' +\n            '{' +\n            '   gl_FragColor = texture2D(texture, vuv);' +\n            '}';\n        main_1.gl.shaderSource(fragmentShaderId, fragmentShader);\n        main_1.gl.compileShader(fragmentShaderId);\n        // プログラムオブジェクトの作成\n        const programId = main_1.gl.createProgram();\n        main_1.gl.attachShader(programId, vertexShaderId);\n        main_1.gl.attachShader(programId, fragmentShaderId);\n        main_1.gl.deleteShader(vertexShaderId);\n        main_1.gl.deleteShader(fragmentShaderId);\n        // リンク\n        main_1.gl.linkProgram(programId);\n        main_1.gl.useProgram(programId);\n        return programId;\n    }\n    /**\n     * View情報を取得する。\n     */\n    getView() {\n        return this._view;\n    }\n    getTextureManager() {\n        return this._textureManager;\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._captured = false;\n        this._mouseX = 0.0;\n        this._mouseY = 0.0;\n        this._isEnd = false;\n        this._cubismOption = new live2dcubismframework_1.Option();\n        this._view = new lappview_1.LAppView();\n        this._textureManager = new lapptexturemanager_1.LAppTextureManager();\n    }\n    /**\n     * Cubism SDKの初期化\n     */\n    initializeCubism() {\n        // setup cubism\n        this._cubismOption.logFunction = lapppal_1.LAppPal.printMessage;\n        this._cubismOption.loggingLevel = LAppDefine.CubismLoggingLevel;\n        live2dcubismframework_1.CubismFramework.startUp(this._cubismOption);\n        // initialize cubism\n        live2dcubismframework_1.CubismFramework.initialize();\n        // load model\n        lapplive2dmanager_1.LAppLive2DManager.getInstance();\n        lapppal_1.LAppPal.updateTime();\n        this._view.initializeSprite();\n    }\n    /**\n     * Resize the canvas to fill the screen.\n     */\n    _resizeCanvas() {\n        main_1.canvas.width = window.innerWidth;\n        main_1.canvas.height = window.innerHeight;\n    }\n}\nexports.LAppDelegate = LAppDelegate;\n/**\n * クリックしたときに呼ばれる。\n */\nfunction onClickBegan(e) {\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    LAppDelegate.getInstance()._captured = true;\n    const posX = e.pageX;\n    const posY = e.pageY;\n    LAppDelegate.getInstance()._view.onTouchesBegan(posX, posY);\n}\nexports.onClickBegan = onClickBegan;\n/**\n * マウスポインタが動いたら呼ばれる。\n */\nfunction onMouseMoved(e) {\n    if (!LAppDelegate.getInstance()._captured) {\n        return;\n    }\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const posX = e.clientX - rect.left;\n    const posY = e.clientY - rect.top;\n    LAppDelegate.getInstance()._view.onTouchesMoved(posX, posY);\n}\nexports.onMouseMoved = onMouseMoved;\n/**\n * クリックが終了したら呼ばれる。\n */\nfunction onClickEnded(e) {\n    LAppDelegate.getInstance()._captured = false;\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const posX = e.clientX - rect.left;\n    const posY = e.clientY - rect.top;\n    LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);\n}\nexports.onClickEnded = onClickEnded;\n/**\n * タッチしたときに呼ばれる。\n */\nfunction onTouchBegan(e) {\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    LAppDelegate.getInstance()._captured = true;\n    const posX = e.changedTouches[0].pageX;\n    const posY = e.changedTouches[0].pageY;\n    LAppDelegate.getInstance()._view.onTouchesBegan(posX, posY);\n}\nexports.onTouchBegan = onTouchBegan;\n/**\n * スワイプすると呼ばれる。\n */\nfunction onTouchMoved(e) {\n    if (!LAppDelegate.getInstance()._captured) {\n        return;\n    }\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const posX = e.changedTouches[0].clientX - rect.left;\n    const posY = e.changedTouches[0].clientY - rect.top;\n    LAppDelegate.getInstance()._view.onTouchesMoved(posX, posY);\n}\nexports.onTouchMoved = onTouchMoved;\n/**\n * タッチが終了したら呼ばれる。\n */\nfunction onTouchEnded(e) {\n    LAppDelegate.getInstance()._captured = false;\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const posX = e.changedTouches[0].clientX - rect.left;\n    const posY = e.changedTouches[0].clientY - rect.top;\n    LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);\n}\nexports.onTouchEnded = onTouchEnded;\n/**\n * タッチがキャンセルされると呼ばれる。\n */\nfunction onTouchCancel(e) {\n    LAppDelegate.getInstance()._captured = false;\n    if (!LAppDelegate.getInstance()._view) {\n        lapppal_1.LAppPal.printMessage('view notfound');\n        return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const posX = e.changedTouches[0].clientX - rect.left;\n    const posY = e.changedTouches[0].clientY - rect.top;\n    LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);\n}\nexports.onTouchCancel = onTouchCancel;\n\n\n//# sourceURL=webpack:///./src/live2d/lappdelegate.ts?");

/***/ }),

/***/ "./src/live2d/lapplive2dmanager.ts":
/*!*****************************************!*\
  !*** ./src/live2d/lapplive2dmanager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LAppLive2DManager = exports.s_instance = void 0;\nconst cubismmatrix44_1 = __webpack_require__(/*! ../../cubism/Framework/src/math/cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../../cubism/Framework/src/type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst LAppDefine = __webpack_require__(/*! ./lappdefine */ \"./src/live2d/lappdefine.ts\");\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\nconst lappmodel_1 = __webpack_require__(/*! ./lappmodel */ \"./src/live2d/lappmodel.ts\");\nconst lapppal_1 = __webpack_require__(/*! ./lapppal */ \"./src/live2d/lapppal.ts\");\nexports.s_instance = null;\n/**\n * サンプルアプリケーションにおいてCubismModelを管理するクラス\n * モデル生成と破棄、タップイベントの処理、モデル切り替えを行う。\n */\nclass LAppLive2DManager {\n    /**\n     * クラスのインスタンス（シングルトン）を返す。\n     * インスタンスが生成されていない場合は内部でインスタンスを生成する。\n     *\n     * @return クラスのインスタンス\n     */\n    static getInstance() {\n        if (exports.s_instance == null) {\n            exports.s_instance = new LAppLive2DManager();\n        }\n        return exports.s_instance;\n    }\n    /**\n     * クラスのインスタンス（シングルトン）を解放する。\n     */\n    static releaseInstance() {\n        if (exports.s_instance != null) {\n            exports.s_instance = void 0;\n        }\n        exports.s_instance = null;\n    }\n    /**\n     * 現在のシーンで保持しているモデルを返す。\n     *\n     * @param no モデルリストのインデックス値\n     * @return モデルのインスタンスを返す。インデックス値が範囲外の場合はNULLを返す。\n     */\n    getModel(no) {\n        if (no < this._models.getSize()) {\n            return this._models.at(no);\n        }\n        return null;\n    }\n    /**\n     * 現在のシーンで保持しているすべてのモデルを解放する\n     */\n    releaseAllModel() {\n        for (let i = 0; i < this._models.getSize(); i++) {\n            this._models.at(i).release();\n            this._models.set(i, null);\n        }\n        this._models.clear();\n    }\n    /**\n     * 画面をドラッグした時の処理\n     *\n     * @param x 画面のX座標\n     * @param y 画面のY座標\n     */\n    onDrag(x, y) {\n        for (let i = 0; i < this._models.getSize(); i++) {\n            const model = this.getModel(i);\n            if (model) {\n                model.setDragging(x, y);\n            }\n        }\n    }\n    /**\n     * 画面をタップした時の処理\n     *\n     * @param x 画面のX座標\n     * @param y 画面のY座標\n     */\n    onTap(x, y) {\n        if (LAppDefine.DebugLogEnable) {\n            lapppal_1.LAppPal.printMessage(`[APP]tap point: {x: ${x.toFixed(2)} y: ${y.toFixed(2)}}`);\n        }\n        for (let i = 0; i < this._models.getSize(); i++) {\n            if (this._models.at(i).hitTest(LAppDefine.HitAreaNameHead, x, y)) {\n                if (LAppDefine.DebugLogEnable) {\n                    lapppal_1.LAppPal.printMessage(`[APP]hit area: [${LAppDefine.HitAreaNameHead}]`);\n                }\n                this._models.at(i).setRandomExpression();\n            }\n            else if (this._models.at(i).hitTest(LAppDefine.HitAreaNameBody, x, y)) {\n                if (LAppDefine.DebugLogEnable) {\n                    lapppal_1.LAppPal.printMessage(`[APP]hit area: [${LAppDefine.HitAreaNameBody}]`);\n                }\n                this._models\n                    .at(i)\n                    .startRandomMotion(LAppDefine.MotionGroupTapBody, LAppDefine.PriorityNormal, this._finishedMotion);\n            }\n        }\n    }\n    /**\n     * 画面を更新するときの処理\n     * モデルの更新処理及び描画処理を行う\n     */\n    onUpdate() {\n        const { width, height } = main_1.canvas;\n        const modelCount = this._models.getSize();\n        for (let i = 0; i < modelCount; ++i) {\n            const projection = new cubismmatrix44_1.CubismMatrix44();\n            const model = this.getModel(i);\n            if (model.getModel()) {\n                if (model.getModel().getCanvasWidth() > 1.0 && width < height) {\n                    // 横に長いモデルを縦長ウィンドウに表示する際モデルの横サイズでscaleを算出する\n                    model.getModelMatrix().setWidth(2.0);\n                    projection.scale(1.0, width / height);\n                }\n                else {\n                    projection.scale(height / width, 1.0);\n                }\n                // 必要があればここで乗算\n                if (this._viewMatrix != null) {\n                    projection.multiplyByMatrix(this._viewMatrix);\n                }\n            }\n            model.update();\n            model.draw(projection); // 参照渡しなのでprojectionは変質する。\n        }\n    }\n    /**\n     * 次のシーンに切りかえる\n     * サンプルアプリケーションではモデルセットの切り替えを行う。\n     */\n    nextScene() {\n        const no = (this._sceneIndex + 1) % LAppDefine.ModelDirSize;\n        this.changeScene(no);\n    }\n    /**\n     * シーンを切り替える\n     * サンプルアプリケーションではモデルセットの切り替えを行う。\n     */\n    changeScene(index) {\n        this._sceneIndex = index;\n        if (LAppDefine.DebugLogEnable) {\n            lapppal_1.LAppPal.printMessage(`[APP]model index: ${this._sceneIndex}`);\n        }\n        // ModelDir[]に保持したディレクトリ名から\n        // model3.jsonのパスを決定する。\n        // ディレクトリ名とmodel3.jsonの名前を一致させておくこと。\n        const model = LAppDefine.ModelDir[index];\n        const modelPath = LAppDefine.ResourcesPath + model + '/';\n        let modelJsonName = LAppDefine.ModelDir[index];\n        modelJsonName += '.model3.json';\n        this.releaseAllModel();\n        this._models.pushBack(new lappmodel_1.LAppModel());\n        this._models.at(0).loadAssets(modelPath, modelJsonName);\n    }\n    setViewMatrix(m) {\n        for (let i = 0; i < 16; i++) {\n            this._viewMatrix.getArray()[i] = m.getArray()[i];\n        }\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        // モーション再生終了のコールバック関数\n        this._finishedMotion = (self) => {\n            lapppal_1.LAppPal.printMessage('Motion Finished:');\n            console.log(self);\n        };\n        this._viewMatrix = new cubismmatrix44_1.CubismMatrix44();\n        this._models = new csmvector_1.csmVector();\n        this._sceneIndex = 0;\n        this.changeScene(this._sceneIndex);\n    }\n}\nexports.LAppLive2DManager = LAppLive2DManager;\n\n\n//# sourceURL=webpack:///./src/live2d/lapplive2dmanager.ts?");

/***/ }),

/***/ "./src/live2d/lappmodel.ts":
/*!*********************************!*\
  !*** ./src/live2d/lappmodel.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LAppModel = void 0;\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\nconst cubismdefaultparameterid_1 = __webpack_require__(/*! ../../cubism/Framework/src/cubismdefaultparameterid */ \"./cubism/Framework/src/cubismdefaultparameterid.ts\");\nconst cubismmodelsettingjson_1 = __webpack_require__(/*! ../../cubism/Framework/src/cubismmodelsettingjson */ \"./cubism/Framework/src/cubismmodelsettingjson.ts\");\nconst cubismbreath_1 = __webpack_require__(/*! ../../cubism/Framework/src/effect/cubismbreath */ \"./cubism/Framework/src/effect/cubismbreath.ts\");\nconst cubismeyeblink_1 = __webpack_require__(/*! ../../cubism/Framework/src/effect/cubismeyeblink */ \"./cubism/Framework/src/effect/cubismeyeblink.ts\");\nconst live2dcubismframework_1 = __webpack_require__(/*! ../../cubism/Framework/src/live2dcubismframework */ \"./cubism/Framework/src/live2dcubismframework.ts\");\nconst cubismusermodel_1 = __webpack_require__(/*! ../../cubism/Framework/src/model/cubismusermodel */ \"./cubism/Framework/src/model/cubismusermodel.ts\");\nconst acubismmotion_1 = __webpack_require__(/*! ../../cubism/Framework/src/motion/acubismmotion */ \"./cubism/Framework/src/motion/acubismmotion.ts\");\nconst cubismmotionqueuemanager_1 = __webpack_require__(/*! ../../cubism/Framework/src/motion/cubismmotionqueuemanager */ \"./cubism/Framework/src/motion/cubismmotionqueuemanager.ts\");\nconst csmmap_1 = __webpack_require__(/*! ../../cubism/Framework/src/type/csmmap */ \"./cubism/Framework/src/type/csmmap.ts\");\nconst csmvector_1 = __webpack_require__(/*! ../../cubism/Framework/src/type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst cubismdebug_1 = __webpack_require__(/*! ../../cubism/Framework/src/utils/cubismdebug */ \"./cubism/Framework/src/utils/cubismdebug.ts\");\nconst LAppDefine = __webpack_require__(/*! ./lappdefine */ \"./src/live2d/lappdefine.ts\");\nconst lappdelegate_1 = __webpack_require__(/*! ./lappdelegate */ \"./src/live2d/lappdelegate.ts\");\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\nconst lapppal_1 = __webpack_require__(/*! ./lapppal */ \"./src/live2d/lapppal.ts\");\nconst lappwavfilehandler_1 = __webpack_require__(/*! ./lappwavfilehandler */ \"./src/live2d/lappwavfilehandler.ts\");\nconst cubismmoc_1 = __webpack_require__(/*! ../../cubism/Framework/src/model/cubismmoc */ \"./cubism/Framework/src/model/cubismmoc.ts\");\nvar LoadStep;\n(function (LoadStep) {\n    LoadStep[LoadStep[\"LoadAssets\"] = 0] = \"LoadAssets\";\n    LoadStep[LoadStep[\"LoadModel\"] = 1] = \"LoadModel\";\n    LoadStep[LoadStep[\"WaitLoadModel\"] = 2] = \"WaitLoadModel\";\n    LoadStep[LoadStep[\"LoadExpression\"] = 3] = \"LoadExpression\";\n    LoadStep[LoadStep[\"WaitLoadExpression\"] = 4] = \"WaitLoadExpression\";\n    LoadStep[LoadStep[\"LoadPhysics\"] = 5] = \"LoadPhysics\";\n    LoadStep[LoadStep[\"WaitLoadPhysics\"] = 6] = \"WaitLoadPhysics\";\n    LoadStep[LoadStep[\"LoadPose\"] = 7] = \"LoadPose\";\n    LoadStep[LoadStep[\"WaitLoadPose\"] = 8] = \"WaitLoadPose\";\n    LoadStep[LoadStep[\"SetupEyeBlink\"] = 9] = \"SetupEyeBlink\";\n    LoadStep[LoadStep[\"SetupBreath\"] = 10] = \"SetupBreath\";\n    LoadStep[LoadStep[\"LoadUserData\"] = 11] = \"LoadUserData\";\n    LoadStep[LoadStep[\"WaitLoadUserData\"] = 12] = \"WaitLoadUserData\";\n    LoadStep[LoadStep[\"SetupEyeBlinkIds\"] = 13] = \"SetupEyeBlinkIds\";\n    LoadStep[LoadStep[\"SetupLipSyncIds\"] = 14] = \"SetupLipSyncIds\";\n    LoadStep[LoadStep[\"SetupLayout\"] = 15] = \"SetupLayout\";\n    LoadStep[LoadStep[\"LoadMotion\"] = 16] = \"LoadMotion\";\n    LoadStep[LoadStep[\"WaitLoadMotion\"] = 17] = \"WaitLoadMotion\";\n    LoadStep[LoadStep[\"CompleteInitialize\"] = 18] = \"CompleteInitialize\";\n    LoadStep[LoadStep[\"CompleteSetupModel\"] = 19] = \"CompleteSetupModel\";\n    LoadStep[LoadStep[\"LoadTexture\"] = 20] = \"LoadTexture\";\n    LoadStep[LoadStep[\"WaitLoadTexture\"] = 21] = \"WaitLoadTexture\";\n    LoadStep[LoadStep[\"CompleteSetup\"] = 22] = \"CompleteSetup\";\n})(LoadStep || (LoadStep = {}));\n/**\n * ユーザーが実際に使用するモデルの実装クラス<br>\n * モデル生成、機能コンポーネント生成、更新処理とレンダリングの呼び出しを行う。\n */\nclass LAppModel extends cubismusermodel_1.CubismUserModel {\n    /**\n     * model3.jsonが置かれたディレクトリとファイルパスからモデルを生成する\n     * @param dir\n     * @param fileName\n     */\n    loadAssets(dir, fileName) {\n        this._modelHomeDir = dir;\n        fetch(`${this._modelHomeDir}${fileName}`)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => {\n            const setting = new cubismmodelsettingjson_1.CubismModelSettingJson(arrayBuffer, arrayBuffer.byteLength);\n            // ステートを更新\n            this._state = LoadStep.LoadModel;\n            // 結果を保存\n            this.setupModel(setting);\n        });\n    }\n    /**\n     * model3.jsonからモデルを生成する。\n     * model3.jsonの記述に従ってモデル生成、モーション、物理演算などのコンポーネント生成を行う。\n     *\n     * @param setting ICubismModelSettingのインスタンス\n     */\n    setupModel(setting) {\n        this._updating = true;\n        this._initialized = false;\n        this._modelSetting = setting;\n        // CubismModel\n        if (this._modelSetting.getModelFileName() != '') {\n            const modelFileName = this._modelSetting.getModelFileName();\n            fetch(`${this._modelHomeDir}${modelFileName}`)\n                .then(response => response.arrayBuffer())\n                .then(arrayBuffer => {\n                this.loadModel(arrayBuffer, this._mocConsistency);\n                this._state = LoadStep.LoadExpression;\n                // callback\n                loadCubismExpression();\n            });\n            this._state = LoadStep.WaitLoadModel;\n        }\n        else {\n            lapppal_1.LAppPal.printMessage('Model data does not exist.');\n        }\n        // Expression\n        const loadCubismExpression = () => {\n            if (this._modelSetting.getExpressionCount() > 0) {\n                const count = this._modelSetting.getExpressionCount();\n                for (let i = 0; i < count; i++) {\n                    const expressionName = this._modelSetting.getExpressionName(i);\n                    const expressionFileName = this._modelSetting.getExpressionFileName(i);\n                    fetch(`${this._modelHomeDir}${expressionFileName}`)\n                        .then(response => response.arrayBuffer())\n                        .then(arrayBuffer => {\n                        const motion = this.loadExpression(arrayBuffer, arrayBuffer.byteLength, expressionName);\n                        if (this._expressions.getValue(expressionName) != null) {\n                            acubismmotion_1.ACubismMotion.delete(this._expressions.getValue(expressionName));\n                            this._expressions.setValue(expressionName, null);\n                        }\n                        this._expressions.setValue(expressionName, motion);\n                        this._expressionCount++;\n                        if (this._expressionCount >= count) {\n                            this._state = LoadStep.LoadPhysics;\n                            // callback\n                            loadCubismPhysics();\n                        }\n                    });\n                }\n                this._state = LoadStep.WaitLoadExpression;\n            }\n            else {\n                this._state = LoadStep.LoadPhysics;\n                // callback\n                loadCubismPhysics();\n            }\n        };\n        // Physics\n        const loadCubismPhysics = () => {\n            if (this._modelSetting.getPhysicsFileName() != '') {\n                const physicsFileName = this._modelSetting.getPhysicsFileName();\n                fetch(`${this._modelHomeDir}${physicsFileName}`)\n                    .then(response => response.arrayBuffer())\n                    .then(arrayBuffer => {\n                    this.loadPhysics(arrayBuffer, arrayBuffer.byteLength);\n                    this._state = LoadStep.LoadPose;\n                    // callback\n                    loadCubismPose();\n                });\n                this._state = LoadStep.WaitLoadPhysics;\n            }\n            else {\n                this._state = LoadStep.LoadPose;\n                // callback\n                loadCubismPose();\n            }\n        };\n        // Pose\n        const loadCubismPose = () => {\n            if (this._modelSetting.getPoseFileName() != '') {\n                const poseFileName = this._modelSetting.getPoseFileName();\n                fetch(`${this._modelHomeDir}${poseFileName}`)\n                    .then(response => response.arrayBuffer())\n                    .then(arrayBuffer => {\n                    this.loadPose(arrayBuffer, arrayBuffer.byteLength);\n                    this._state = LoadStep.SetupEyeBlink;\n                    // callback\n                    setupEyeBlink();\n                });\n                this._state = LoadStep.WaitLoadPose;\n            }\n            else {\n                this._state = LoadStep.SetupEyeBlink;\n                // callback\n                setupEyeBlink();\n            }\n        };\n        // EyeBlink\n        const setupEyeBlink = () => {\n            if (this._modelSetting.getEyeBlinkParameterCount() > 0) {\n                this._eyeBlink = cubismeyeblink_1.CubismEyeBlink.create(this._modelSetting);\n                this._state = LoadStep.SetupBreath;\n            }\n            // callback\n            setupBreath();\n        };\n        // Breath\n        const setupBreath = () => {\n            this._breath = cubismbreath_1.CubismBreath.create();\n            const breathParameters = new csmvector_1.csmVector();\n            breathParameters.pushBack(new cubismbreath_1.BreathParameterData(this._idParamAngleX, 0.0, 15.0, 6.5345, 0.5));\n            breathParameters.pushBack(new cubismbreath_1.BreathParameterData(this._idParamAngleY, 0.0, 8.0, 3.5345, 0.5));\n            breathParameters.pushBack(new cubismbreath_1.BreathParameterData(this._idParamAngleZ, 0.0, 10.0, 5.5345, 0.5));\n            breathParameters.pushBack(new cubismbreath_1.BreathParameterData(this._idParamBodyAngleX, 0.0, 4.0, 15.5345, 0.5));\n            breathParameters.pushBack(new cubismbreath_1.BreathParameterData(live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamBreath), 0.5, 0.5, 3.2345, 1));\n            this._breath.setParameters(breathParameters);\n            this._state = LoadStep.LoadUserData;\n            // callback\n            loadUserData();\n        };\n        // UserData\n        const loadUserData = () => {\n            if (this._modelSetting.getUserDataFile() != '') {\n                const userDataFile = this._modelSetting.getUserDataFile();\n                fetch(`${this._modelHomeDir}${userDataFile}`)\n                    .then(response => response.arrayBuffer())\n                    .then(arrayBuffer => {\n                    this.loadUserData(arrayBuffer, arrayBuffer.byteLength);\n                    this._state = LoadStep.SetupEyeBlinkIds;\n                    // callback\n                    setupEyeBlinkIds();\n                });\n                this._state = LoadStep.WaitLoadUserData;\n            }\n            else {\n                this._state = LoadStep.SetupEyeBlinkIds;\n                // callback\n                setupEyeBlinkIds();\n            }\n        };\n        // EyeBlinkIds\n        const setupEyeBlinkIds = () => {\n            const eyeBlinkIdCount = this._modelSetting.getEyeBlinkParameterCount();\n            for (let i = 0; i < eyeBlinkIdCount; ++i) {\n                this._eyeBlinkIds.pushBack(this._modelSetting.getEyeBlinkParameterId(i));\n            }\n            this._state = LoadStep.SetupLipSyncIds;\n            // callback\n            setupLipSyncIds();\n        };\n        // LipSyncIds\n        const setupLipSyncIds = () => {\n            const lipSyncIdCount = this._modelSetting.getLipSyncParameterCount();\n            for (let i = 0; i < lipSyncIdCount; ++i) {\n                this._lipSyncIds.pushBack(this._modelSetting.getLipSyncParameterId(i));\n            }\n            this._state = LoadStep.SetupLayout;\n            // callback\n            setupLayout();\n        };\n        // Layout\n        const setupLayout = () => {\n            const layout = new csmmap_1.csmMap();\n            if (this._modelSetting == null || this._modelMatrix == null) {\n                (0, cubismdebug_1.CubismLogError)('Failed to setupLayout().');\n                return;\n            }\n            this._modelSetting.getLayoutMap(layout);\n            this._modelMatrix.setupFromLayout(layout);\n            this._state = LoadStep.LoadMotion;\n            // callback\n            loadCubismMotion();\n        };\n        // Motion\n        const loadCubismMotion = () => {\n            this._state = LoadStep.WaitLoadMotion;\n            this._model.saveParameters();\n            this._allMotionCount = 0;\n            this._motionCount = 0;\n            const group = [];\n            const motionGroupCount = this._modelSetting.getMotionGroupCount();\n            // モーションの総数を求める\n            for (let i = 0; i < motionGroupCount; i++) {\n                group[i] = this._modelSetting.getMotionGroupName(i);\n                this._allMotionCount += this._modelSetting.getMotionCount(group[i]);\n            }\n            // モーションの読み込み\n            for (let i = 0; i < motionGroupCount; i++) {\n                this.preLoadMotionGroup(group[i]);\n            }\n            // モーションがない場合\n            if (motionGroupCount == 0) {\n                this._state = LoadStep.LoadTexture;\n                // 全てのモーションを停止する\n                this._motionManager.stopAllMotions();\n                this._updating = false;\n                this._initialized = true;\n                this.createRenderer();\n                this.setupTextures();\n                this.getRenderer().startUp(main_1.gl);\n            }\n        };\n    }\n    /**\n     * テクスチャユニットにテクスチャをロードする\n     */\n    setupTextures() {\n        // iPhoneでのアルファ品質向上のためTypescriptではpremultipliedAlphaを採用\n        const usePremultiply = true;\n        if (this._state == LoadStep.LoadTexture) {\n            // テクスチャ読み込み用\n            const textureCount = this._modelSetting.getTextureCount();\n            for (let modelTextureNumber = 0; modelTextureNumber < textureCount; modelTextureNumber++) {\n                // テクスチャ名が空文字だった場合はロード・バインド処理をスキップ\n                if (this._modelSetting.getTextureFileName(modelTextureNumber) == '') {\n                    console.log('getTextureFileName null');\n                    continue;\n                }\n                // WebGLのテクスチャユニットにテクスチャをロードする\n                let texturePath = this._modelSetting.getTextureFileName(modelTextureNumber);\n                texturePath = this._modelHomeDir + texturePath;\n                // ロード完了時に呼び出すコールバック関数\n                const onLoad = (textureInfo) => {\n                    this.getRenderer().bindTexture(modelTextureNumber, textureInfo.id);\n                    this._textureCount++;\n                    if (this._textureCount >= textureCount) {\n                        // ロード完了\n                        this._state = LoadStep.CompleteSetup;\n                    }\n                };\n                // 読み込み\n                lappdelegate_1.LAppDelegate.getInstance()\n                    .getTextureManager()\n                    .createTextureFromPngFile(texturePath, usePremultiply, onLoad);\n                this.getRenderer().setIsPremultipliedAlpha(usePremultiply);\n            }\n            this._state = LoadStep.WaitLoadTexture;\n        }\n    }\n    /**\n     * レンダラを再構築する\n     */\n    reloadRenderer() {\n        this.deleteRenderer();\n        this.createRenderer();\n        this.setupTextures();\n    }\n    /**\n     * 更新\n     */\n    update() {\n        if (this._state != LoadStep.CompleteSetup)\n            return;\n        const deltaTimeSeconds = lapppal_1.LAppPal.getDeltaTime();\n        this._userTimeSeconds += deltaTimeSeconds;\n        this._dragManager.update(deltaTimeSeconds);\n        this._dragX = this._dragManager.getX();\n        this._dragY = this._dragManager.getY();\n        // モーションによるパラメータ更新の有無\n        let motionUpdated = false;\n        //--------------------------------------------------------------------------\n        this._model.loadParameters(); // 前回セーブされた状態をロード\n        if (this._motionManager.isFinished()) {\n            // モーションの再生がない場合、待機モーションの中からランダムで再生する\n            this.startRandomMotion(LAppDefine.MotionGroupIdle, LAppDefine.PriorityIdle);\n        }\n        else {\n            motionUpdated = this._motionManager.updateMotion(this._model, deltaTimeSeconds); // モーションを更新\n        }\n        this._model.saveParameters(); // 状態を保存\n        //--------------------------------------------------------------------------\n        // まばたき\n        if (!motionUpdated) {\n            if (this._eyeBlink != null) {\n                // メインモーションの更新がないとき\n                this._eyeBlink.updateParameters(this._model, deltaTimeSeconds); // 目パチ\n            }\n        }\n        if (this._expressionManager != null) {\n            this._expressionManager.updateMotion(this._model, deltaTimeSeconds); // 表情でパラメータ更新（相対変化）\n        }\n        // ドラッグによる変化\n        // ドラッグによる顔の向きの調整\n        this._model.addParameterValueById(this._idParamAngleX, this._dragX * 30); // -30から30の値を加える\n        this._model.addParameterValueById(this._idParamAngleY, this._dragY * 30);\n        this._model.addParameterValueById(this._idParamAngleZ, this._dragX * this._dragY * -30);\n        // ドラッグによる体の向きの調整\n        this._model.addParameterValueById(this._idParamBodyAngleX, this._dragX * 10); // -10から10の値を加える\n        // ドラッグによる目の向きの調整\n        this._model.addParameterValueById(this._idParamEyeBallX, this._dragX); // -1から1の値を加える\n        this._model.addParameterValueById(this._idParamEyeBallY, this._dragY);\n        // 呼吸など\n        if (this._breath != null) {\n            this._breath.updateParameters(this._model, deltaTimeSeconds);\n        }\n        // 物理演算の設定\n        if (this._physics != null) {\n            this._physics.evaluate(this._model, deltaTimeSeconds);\n        }\n        // リップシンクの設定\n        if (this._lipsync) {\n            let value = 0.0; // リアルタイムでリップシンクを行う場合、システムから音量を取得して、0~1の範囲で値を入力します。\n            this._wavFileHandler.update(deltaTimeSeconds);\n            value = this._wavFileHandler.getRms();\n            for (let i = 0; i < this._lipSyncIds.getSize(); ++i) {\n                this._model.addParameterValueById(this._lipSyncIds.at(i), value, 0.8);\n            }\n        }\n        // ポーズの設定\n        if (this._pose != null) {\n            this._pose.updateParameters(this._model, deltaTimeSeconds);\n        }\n        this._model.update();\n    }\n    /**\n     * 引数で指定したモーションの再生を開始する\n     * @param group モーショングループ名\n     * @param no グループ内の番号\n     * @param priority 優先度\n     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n     * @return 開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するisFinished()の引数で使用する。開始できない時は[-1]\n     */\n    startMotion(group, no, priority, onFinishedMotionHandler) {\n        if (priority == LAppDefine.PriorityForce) {\n            this._motionManager.setReservePriority(priority);\n        }\n        else if (!this._motionManager.reserveMotion(priority)) {\n            if (this._debugMode) {\n                lapppal_1.LAppPal.printMessage(\"[APP]can't start motion.\");\n            }\n            return cubismmotionqueuemanager_1.InvalidMotionQueueEntryHandleValue;\n        }\n        const motionFileName = this._modelSetting.getMotionFileName(group, no);\n        // ex) idle_0\n        const name = `${group}_${no}`;\n        let motion = this._motions.getValue(name);\n        let autoDelete = false;\n        if (motion == null) {\n            fetch(`${this._modelHomeDir}${motionFileName}`)\n                .then(response => response.arrayBuffer())\n                .then(arrayBuffer => {\n                motion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, null, onFinishedMotionHandler);\n                let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, no);\n                if (fadeTime >= 0.0) {\n                    motion.setFadeInTime(fadeTime);\n                }\n                fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, no);\n                if (fadeTime >= 0.0) {\n                    motion.setFadeOutTime(fadeTime);\n                }\n                motion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);\n                autoDelete = true; // 終了時にメモリから削除\n            });\n        }\n        else {\n            motion.setFinishedMotionHandler(onFinishedMotionHandler);\n        }\n        //voice\n        const voice = this._modelSetting.getMotionSoundFileName(group, no);\n        if (voice.localeCompare('') != 0) {\n            let path = voice;\n            path = this._modelHomeDir + path;\n            this._wavFileHandler.start(path);\n        }\n        if (this._debugMode) {\n            lapppal_1.LAppPal.printMessage(`[APP]start motion: [${group}_${no}`);\n        }\n        return this._motionManager.startMotionPriority(motion, autoDelete, priority);\n    }\n    /**\n     * ランダムに選ばれたモーションの再生を開始する。\n     * @param group モーショングループ名\n     * @param priority 優先度\n     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n     * @return 開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するisFinished()の引数で使用する。開始できない時は[-1]\n     */\n    startRandomMotion(group, priority, onFinishedMotionHandler) {\n        if (this._modelSetting.getMotionCount(group) == 0) {\n            return cubismmotionqueuemanager_1.InvalidMotionQueueEntryHandleValue;\n        }\n        const no = Math.floor(Math.random() * this._modelSetting.getMotionCount(group));\n        return this.startMotion(group, no, priority, onFinishedMotionHandler);\n    }\n    /**\n     * 引数で指定した表情モーションをセットする\n     *\n     * @param expressionId 表情モーションのID\n     */\n    setExpression(expressionId) {\n        const motion = this._expressions.getValue(expressionId);\n        if (this._debugMode) {\n            lapppal_1.LAppPal.printMessage(`[APP]expression: [${expressionId}]`);\n        }\n        if (motion != null) {\n            this._expressionManager.startMotionPriority(motion, false, LAppDefine.PriorityForce);\n        }\n        else {\n            if (this._debugMode) {\n                lapppal_1.LAppPal.printMessage(`[APP]expression[${expressionId}] is null`);\n            }\n        }\n    }\n    /**\n     * ランダムに選ばれた表情モーションをセットする\n     */\n    setRandomExpression() {\n        if (this._expressions.getSize() == 0) {\n            return;\n        }\n        const no = Math.floor(Math.random() * this._expressions.getSize());\n        for (let i = 0; i < this._expressions.getSize(); i++) {\n            if (i == no) {\n                const name = this._expressions._keyValues[i].first;\n                this.setExpression(name);\n                return;\n            }\n        }\n    }\n    /**\n     * イベントの発火を受け取る\n     */\n    motionEventFired(eventValue) {\n        (0, cubismdebug_1.CubismLogInfo)('{0} is fired on LAppModel!!', eventValue.s);\n    }\n    /**\n     * 当たり判定テスト\n     * 指定ＩＤの頂点リストから矩形を計算し、座標をが矩形範囲内か判定する。\n     *\n     * @param hitArenaName  当たり判定をテストする対象のID\n     * @param x             判定を行うX座標\n     * @param y             判定を行うY座標\n     */\n    hitTest(hitArenaName, x, y) {\n        // 透明時は当たり判定無し。\n        if (this._opacity < 1) {\n            return false;\n        }\n        const count = this._modelSetting.getHitAreasCount();\n        for (let i = 0; i < count; i++) {\n            if (this._modelSetting.getHitAreaName(i) == hitArenaName) {\n                const drawId = this._modelSetting.getHitAreaId(i);\n                return this.isHit(drawId, x, y);\n            }\n        }\n        return false;\n    }\n    /**\n     * モーションデータをグループ名から一括でロードする。\n     * モーションデータの名前は内部でModelSettingから取得する。\n     *\n     * @param group モーションデータのグループ名\n     */\n    preLoadMotionGroup(group) {\n        for (let i = 0; i < this._modelSetting.getMotionCount(group); i++) {\n            const motionFileName = this._modelSetting.getMotionFileName(group, i);\n            // ex) idle_0\n            const name = `${group}_${i}`;\n            if (this._debugMode) {\n                lapppal_1.LAppPal.printMessage(`[APP]load motion: ${motionFileName} => [${name}]`);\n            }\n            fetch(`${this._modelHomeDir}${motionFileName}`)\n                .then(response => response.arrayBuffer())\n                .then(arrayBuffer => {\n                const tmpMotion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, name);\n                let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, i);\n                if (fadeTime >= 0.0) {\n                    tmpMotion.setFadeInTime(fadeTime);\n                }\n                fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, i);\n                if (fadeTime >= 0.0) {\n                    tmpMotion.setFadeOutTime(fadeTime);\n                }\n                tmpMotion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);\n                if (this._motions.getValue(name) != null) {\n                    acubismmotion_1.ACubismMotion.delete(this._motions.getValue(name));\n                }\n                this._motions.setValue(name, tmpMotion);\n                this._motionCount++;\n                if (this._motionCount >= this._allMotionCount) {\n                    this._state = LoadStep.LoadTexture;\n                    // 全てのモーションを停止する\n                    this._motionManager.stopAllMotions();\n                    this._updating = false;\n                    this._initialized = true;\n                    this.createRenderer();\n                    this.setupTextures();\n                    this.getRenderer().startUp(main_1.gl);\n                }\n            });\n        }\n    }\n    /**\n     * すべてのモーションデータを解放する。\n     */\n    releaseMotions() {\n        this._motions.clear();\n    }\n    /**\n     * 全ての表情データを解放する。\n     */\n    releaseExpressions() {\n        this._expressions.clear();\n    }\n    /**\n     * モデルを描画する処理。モデルを描画する空間のView-Projection行列を渡す。\n     */\n    doDraw() {\n        if (this._model == null)\n            return;\n        // キャンバスサイズを渡す\n        const viewport = [0, 0, main_1.canvas.width, main_1.canvas.height];\n        this.getRenderer().setRenderState(main_1.frameBuffer, viewport);\n        this.getRenderer().drawModel();\n    }\n    /**\n     * モデルを描画する処理。モデルを描画する空間のView-Projection行列を渡す。\n     */\n    draw(matrix) {\n        if (this._model == null) {\n            return;\n        }\n        // 各読み込み終了後\n        if (this._state == LoadStep.CompleteSetup) {\n            matrix.multiplyByMatrix(this._modelMatrix);\n            this.getRenderer().setMvpMatrix(matrix);\n            this.doDraw();\n        }\n    }\n    hasMocConsistencyFromFile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, cubismdebug_1.CSM_ASSERT)(this._modelSetting.getModelFileName().localeCompare(``));\n            // CubismModel\n            if (this._modelSetting.getModelFileName() != '') {\n                const modelFileName = this._modelSetting.getModelFileName();\n                const response = yield fetch(`${this._modelHomeDir}${modelFileName}`);\n                const arrayBuffer = yield response.arrayBuffer();\n                this._consistency = cubismmoc_1.CubismMoc.hasMocConsistency(arrayBuffer);\n                if (!this._consistency) {\n                    (0, cubismdebug_1.CubismLogInfo)('Inconsistent MOC3.');\n                }\n                else {\n                    (0, cubismdebug_1.CubismLogInfo)('Consistent MOC3.');\n                }\n                return this._consistency;\n            }\n            else {\n                lapppal_1.LAppPal.printMessage('Model data does not exist.');\n            }\n        });\n    }\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        super();\n        this._modelSetting = null;\n        this._modelHomeDir = null;\n        this._userTimeSeconds = 0.0;\n        this._eyeBlinkIds = new csmvector_1.csmVector();\n        this._lipSyncIds = new csmvector_1.csmVector();\n        this._motions = new csmmap_1.csmMap();\n        this._expressions = new csmmap_1.csmMap();\n        this._hitArea = new csmvector_1.csmVector();\n        this._userArea = new csmvector_1.csmVector();\n        this._idParamAngleX = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamAngleX);\n        this._idParamAngleY = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamAngleY);\n        this._idParamAngleZ = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamAngleZ);\n        this._idParamEyeBallX = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamEyeBallX);\n        this._idParamEyeBallY = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamEyeBallY);\n        this._idParamBodyAngleX = live2dcubismframework_1.CubismFramework.getIdManager().getId(cubismdefaultparameterid_1.CubismDefaultParameterId.ParamBodyAngleX);\n        if (LAppDefine.MOCConsistencyValidationEnable) {\n            this._mocConsistency = true;\n        }\n        this._state = LoadStep.LoadAssets;\n        this._expressionCount = 0;\n        this._textureCount = 0;\n        this._motionCount = 0;\n        this._allMotionCount = 0;\n        this._wavFileHandler = new lappwavfilehandler_1.LAppWavFileHandler();\n        this._consistency = false;\n    }\n}\nexports.LAppModel = LAppModel;\n\n\n//# sourceURL=webpack:///./src/live2d/lappmodel.ts?");

/***/ }),

/***/ "./src/live2d/lapppal.ts":
/*!*******************************!*\
  !*** ./src/live2d/lapppal.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LAppPal = void 0;\n/**\n * プラットフォーム依存機能を抽象化する Cubism Platform Abstraction Layer.\n *\n * ファイル読み込みや時刻取得等のプラットフォームに依存する関数をまとめる。\n */\nclass LAppPal {\n    /**\n     * ファイルをバイトデータとして読みこむ\n     *\n     * @param filePath 読み込み対象ファイルのパス\n     * @return\n     * {\n     *      buffer,   読み込んだバイトデータ\n     *      size        ファイルサイズ\n     * }\n     */\n    static loadFileAsBytes(filePath, callback) {\n        fetch(filePath)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => callback(arrayBuffer, arrayBuffer.byteLength));\n    }\n    /**\n     * デルタ時間（前回フレームとの差分）を取得する\n     * @return デルタ時間[ms]\n     */\n    static getDeltaTime() {\n        return this.s_deltaTime;\n    }\n    static updateTime() {\n        this.s_currentFrame = Date.now();\n        this.s_deltaTime = (this.s_currentFrame - this.s_lastFrame) / 1000;\n        this.s_lastFrame = this.s_currentFrame;\n    }\n    /**\n     * メッセージを出力する\n     * @param message 文字列\n     */\n    static printMessage(message) {\n        console.log(message);\n    }\n}\nexports.LAppPal = LAppPal;\nLAppPal.lastUpdate = Date.now();\nLAppPal.s_currentFrame = 0.0;\nLAppPal.s_lastFrame = 0.0;\nLAppPal.s_deltaTime = 0.0;\n\n\n//# sourceURL=webpack:///./src/live2d/lapppal.ts?");

/***/ }),

/***/ "./src/live2d/lappsprite.ts":
/*!**********************************!*\
  !*** ./src/live2d/lappsprite.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rect = exports.LAppSprite = void 0;\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\n/**\n * スプライトを実装するクラス\n *\n * テクスチャＩＤ、Rectの管理\n */\nclass LAppSprite {\n    /**\n     * コンストラクタ\n     * @param x            x座標\n     * @param y            y座標\n     * @param width        横幅\n     * @param height       高さ\n     * @param textureId    テクスチャ\n     */\n    constructor(x, y, width, height, textureId) {\n        this._rect = new Rect();\n        this._rect.left = x - width * 0.5;\n        this._rect.right = x + width * 0.5;\n        this._rect.up = y + height * 0.5;\n        this._rect.down = y - height * 0.5;\n        this._texture = textureId;\n        this._vertexBuffer = null;\n        this._uvBuffer = null;\n        this._indexBuffer = null;\n        this._positionLocation = null;\n        this._uvLocation = null;\n        this._textureLocation = null;\n        this._positionArray = null;\n        this._uvArray = null;\n        this._indexArray = null;\n        this._firstDraw = true;\n    }\n    /**\n     * 解放する。\n     */\n    release() {\n        this._rect = null;\n        main_1.gl.deleteTexture(this._texture);\n        this._texture = null;\n        main_1.gl.deleteBuffer(this._uvBuffer);\n        this._uvBuffer = null;\n        main_1.gl.deleteBuffer(this._vertexBuffer);\n        this._vertexBuffer = null;\n        main_1.gl.deleteBuffer(this._indexBuffer);\n        this._indexBuffer = null;\n    }\n    /**\n     * テクスチャを返す\n     */\n    getTexture() {\n        return this._texture;\n    }\n    /**\n     * 描画する。\n     * @param programId シェーダープログラム\n     * @param canvas 描画するキャンパス情報\n     */\n    render(programId) {\n        if (this._texture == null) {\n            // ロードが完了していない\n            return;\n        }\n        // 初回描画時\n        if (this._firstDraw) {\n            // 何番目のattribute変数か取得\n            this._positionLocation = main_1.gl.getAttribLocation(programId, 'position');\n            main_1.gl.enableVertexAttribArray(this._positionLocation);\n            this._uvLocation = main_1.gl.getAttribLocation(programId, 'uv');\n            main_1.gl.enableVertexAttribArray(this._uvLocation);\n            // 何番目のuniform変数か取得\n            this._textureLocation = main_1.gl.getUniformLocation(programId, 'texture');\n            // uniform属性の登録\n            main_1.gl.uniform1i(this._textureLocation, 0);\n            // uvバッファ、座標初期化\n            {\n                this._uvArray = new Float32Array([\n                    1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0\n                ]);\n                // uvバッファを作成\n                this._uvBuffer = main_1.gl.createBuffer();\n            }\n            // 頂点バッファ、座標初期化\n            {\n                const maxWidth = main_1.canvas.width;\n                const maxHeight = main_1.canvas.height;\n                // 頂点データ\n                this._positionArray = new Float32Array([\n                    (this._rect.right - maxWidth * 0.5) / (maxWidth * 0.5),\n                    (this._rect.up - maxHeight * 0.5) / (maxHeight * 0.5),\n                    (this._rect.left - maxWidth * 0.5) / (maxWidth * 0.5),\n                    (this._rect.up - maxHeight * 0.5) / (maxHeight * 0.5),\n                    (this._rect.left - maxWidth * 0.5) / (maxWidth * 0.5),\n                    (this._rect.down - maxHeight * 0.5) / (maxHeight * 0.5),\n                    (this._rect.right - maxWidth * 0.5) / (maxWidth * 0.5),\n                    (this._rect.down - maxHeight * 0.5) / (maxHeight * 0.5)\n                ]);\n                // 頂点バッファを作成\n                this._vertexBuffer = main_1.gl.createBuffer();\n            }\n            // 頂点インデックスバッファ、初期化\n            {\n                // インデックスデータ\n                this._indexArray = new Uint16Array([0, 1, 2, 3, 2, 0]);\n                // インデックスバッファを作成\n                this._indexBuffer = main_1.gl.createBuffer();\n            }\n            this._firstDraw = false;\n        }\n        // UV座標登録\n        main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, this._uvBuffer);\n        main_1.gl.bufferData(main_1.gl.ARRAY_BUFFER, this._uvArray, main_1.gl.STATIC_DRAW);\n        // attribute属性を登録\n        main_1.gl.vertexAttribPointer(this._uvLocation, 2, main_1.gl.FLOAT, false, 0, 0);\n        // 頂点座標を登録\n        main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, this._vertexBuffer);\n        main_1.gl.bufferData(main_1.gl.ARRAY_BUFFER, this._positionArray, main_1.gl.STATIC_DRAW);\n        // attribute属性を登録\n        main_1.gl.vertexAttribPointer(this._positionLocation, 2, main_1.gl.FLOAT, false, 0, 0);\n        // 頂点インデックスを作成\n        main_1.gl.bindBuffer(main_1.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n        main_1.gl.bufferData(main_1.gl.ELEMENT_ARRAY_BUFFER, this._indexArray, main_1.gl.DYNAMIC_DRAW);\n        // モデルの描画\n        main_1.gl.bindTexture(main_1.gl.TEXTURE_2D, this._texture);\n        main_1.gl.drawElements(main_1.gl.TRIANGLES, this._indexArray.length, main_1.gl.UNSIGNED_SHORT, 0);\n    }\n    /**\n     * 当たり判定\n     * @param pointX x座標\n     * @param pointY y座標\n     */\n    isHit(pointX, pointY) {\n        // 画面サイズを取得する。\n        const { height } = main_1.canvas;\n        // Y座標は変換する必要あり\n        const y = height - pointY;\n        return (pointX >= this._rect.left &&\n            pointX <= this._rect.right &&\n            y <= this._rect.up &&\n            y >= this._rect.down);\n    }\n}\nexports.LAppSprite = LAppSprite;\nclass Rect {\n}\nexports.Rect = Rect;\n\n\n//# sourceURL=webpack:///./src/live2d/lappsprite.ts?");

/***/ }),

/***/ "./src/live2d/lapptexturemanager.ts":
/*!******************************************!*\
  !*** ./src/live2d/lapptexturemanager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureInfo = exports.LAppTextureManager = void 0;\nconst csmvector_1 = __webpack_require__(/*! ../../cubism/Framework/src/type/csmvector */ \"./cubism/Framework/src/type/csmvector.ts\");\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\n/**\n * テクスチャ管理クラス\n * 画像読み込み、管理を行うクラス。\n */\nclass LAppTextureManager {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._textures = new csmvector_1.csmVector();\n    }\n    /**\n     * 解放する。\n     */\n    release() {\n        for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {\n            main_1.gl.deleteTexture(ite.ptr().id);\n        }\n        this._textures = null;\n    }\n    /**\n     * 画像読み込み\n     *\n     * @param fileName 読み込む画像ファイルパス名\n     * @param usePremultiply Premult処理を有効にするか\n     * @return 画像情報、読み込み失敗時はnullを返す\n     */\n    createTextureFromPngFile(fileName, usePremultiply, callback) {\n        // search loaded texture already\n        for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {\n            if (ite.ptr().fileName == fileName &&\n                ite.ptr().usePremultply == usePremultiply) {\n                // 2回目以降はキャッシュが使用される(待ち時間なし)\n                // WebKitでは同じImageのonloadを再度呼ぶには再インスタンスが必要\n                // 詳細：https://stackoverflow.com/a/5024181\n                ite.ptr().img = new Image();\n                ite.ptr().img.onload = () => callback(ite.ptr());\n                ite.ptr().img.src = fileName;\n                return;\n            }\n        }\n        // データのオンロードをトリガーにする\n        const img = new Image();\n        img.onload = () => {\n            // テクスチャオブジェクトの作成\n            const tex = main_1.gl.createTexture();\n            // テクスチャを選択\n            main_1.gl.bindTexture(main_1.gl.TEXTURE_2D, tex);\n            // テクスチャにピクセルを書き込む\n            main_1.gl.texParameteri(main_1.gl.TEXTURE_2D, main_1.gl.TEXTURE_MIN_FILTER, main_1.gl.LINEAR_MIPMAP_LINEAR);\n            main_1.gl.texParameteri(main_1.gl.TEXTURE_2D, main_1.gl.TEXTURE_MAG_FILTER, main_1.gl.LINEAR);\n            // Premult処理を行わせる\n            if (usePremultiply) {\n                main_1.gl.pixelStorei(main_1.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n            }\n            // テクスチャにピクセルを書き込む\n            main_1.gl.texImage2D(main_1.gl.TEXTURE_2D, 0, main_1.gl.RGBA, main_1.gl.RGBA, main_1.gl.UNSIGNED_BYTE, img);\n            // ミップマップを生成\n            main_1.gl.generateMipmap(main_1.gl.TEXTURE_2D);\n            // テクスチャをバインド\n            main_1.gl.bindTexture(main_1.gl.TEXTURE_2D, null);\n            const textureInfo = new TextureInfo();\n            if (textureInfo != null) {\n                textureInfo.fileName = fileName;\n                textureInfo.width = img.width;\n                textureInfo.height = img.height;\n                textureInfo.id = tex;\n                textureInfo.img = img;\n                textureInfo.usePremultply = usePremultiply;\n                this._textures.pushBack(textureInfo);\n            }\n            callback(textureInfo);\n        };\n        img.src = fileName;\n    }\n    /**\n     * 画像の解放\n     *\n     * 配列に存在する画像全てを解放する。\n     */\n    releaseTextures() {\n        for (let i = 0; i < this._textures.getSize(); i++) {\n            this._textures.set(i, null);\n        }\n        this._textures.clear();\n    }\n    /**\n     * 画像の解放\n     *\n     * 指定したテクスチャの画像を解放する。\n     * @param texture 解放するテクスチャ\n     */\n    releaseTextureByTexture(texture) {\n        for (let i = 0; i < this._textures.getSize(); i++) {\n            if (this._textures.at(i).id != texture) {\n                continue;\n            }\n            this._textures.set(i, null);\n            this._textures.remove(i);\n            break;\n        }\n    }\n    /**\n     * 画像の解放\n     *\n     * 指定した名前の画像を解放する。\n     * @param fileName 解放する画像ファイルパス名\n     */\n    releaseTextureByFilePath(fileName) {\n        for (let i = 0; i < this._textures.getSize(); i++) {\n            if (this._textures.at(i).fileName == fileName) {\n                this._textures.set(i, null);\n                this._textures.remove(i);\n                break;\n            }\n        }\n    }\n}\nexports.LAppTextureManager = LAppTextureManager;\n/**\n * 画像情報構造体\n */\nclass TextureInfo {\n    constructor() {\n        this.id = null; // テクスチャ\n        this.width = 0; // 横幅\n        this.height = 0; // 高さ\n    }\n}\nexports.TextureInfo = TextureInfo;\n\n\n//# sourceURL=webpack:///./src/live2d/lapptexturemanager.ts?");

/***/ }),

/***/ "./src/live2d/lappview.ts":
/*!********************************!*\
  !*** ./src/live2d/lappview.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LAppView = void 0;\nconst cubismmatrix44_1 = __webpack_require__(/*! ../../cubism/Framework/src/math/cubismmatrix44 */ \"./cubism/Framework/src/math/cubismmatrix44.ts\");\nconst cubismviewmatrix_1 = __webpack_require__(/*! ../../cubism/Framework/src/math/cubismviewmatrix */ \"./cubism/Framework/src/math/cubismviewmatrix.ts\");\nconst LAppDefine = __webpack_require__(/*! ./lappdefine */ \"./src/live2d/lappdefine.ts\");\nconst lappdelegate_1 = __webpack_require__(/*! ./lappdelegate */ \"./src/live2d/lappdelegate.ts\");\nconst main_1 = __webpack_require__(/*! ../main */ \"./src/main.ts\");\nconst lapplive2dmanager_1 = __webpack_require__(/*! ./lapplive2dmanager */ \"./src/live2d/lapplive2dmanager.ts\");\nconst lapppal_1 = __webpack_require__(/*! ./lapppal */ \"./src/live2d/lapppal.ts\");\nconst lappsprite_1 = __webpack_require__(/*! ./lappsprite */ \"./src/live2d/lappsprite.ts\");\nconst touchmanager_1 = __webpack_require__(/*! ./touchmanager */ \"./src/live2d/touchmanager.ts\");\n/**\n * 描画クラス。\n */\nclass LAppView {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._programId = null;\n        this._back = null;\n        this._gear = null;\n        // タッチ関係のイベント管理\n        this._touchManager = new touchmanager_1.TouchManager();\n        // デバイス座標からスクリーン座標に変換するための\n        this._deviceToScreen = new cubismmatrix44_1.CubismMatrix44();\n        // 画面の表示の拡大縮小や移動の変換を行う行列\n        this._viewMatrix = new cubismviewmatrix_1.CubismViewMatrix();\n    }\n    /**\n     * 初期化する。\n     */\n    initialize() {\n        const { width, height } = main_1.canvas;\n        const ratio = width / height;\n        const left = -ratio;\n        const right = ratio;\n        const bottom = LAppDefine.ViewLogicalLeft;\n        const top = LAppDefine.ViewLogicalRight;\n        this._viewMatrix.setScreenRect(left, right, bottom, top); // デバイスに対応する画面の範囲。 Xの左端、Xの右端、Yの下端、Yの上端\n        this._viewMatrix.scale(LAppDefine.ViewScale, LAppDefine.ViewScale);\n        this._deviceToScreen.loadIdentity();\n        if (width > height) {\n            const screenW = Math.abs(right - left);\n            this._deviceToScreen.scaleRelative(screenW / width, -screenW / width);\n        }\n        else {\n            const screenH = Math.abs(top - bottom);\n            this._deviceToScreen.scaleRelative(screenH / height, -screenH / height);\n        }\n        this._deviceToScreen.translateRelative(-width * 0.5, -height * 0.5);\n        // 表示範囲の設定\n        this._viewMatrix.setMaxScale(LAppDefine.ViewMaxScale); // 限界拡張率\n        this._viewMatrix.setMinScale(LAppDefine.ViewMinScale); // 限界縮小率\n        // 表示できる最大範囲\n        this._viewMatrix.setMaxScreenRect(LAppDefine.ViewLogicalMaxLeft, LAppDefine.ViewLogicalMaxRight, LAppDefine.ViewLogicalMaxBottom, LAppDefine.ViewLogicalMaxTop);\n    }\n    /**\n     * 解放する\n     */\n    release() {\n        this._viewMatrix = null;\n        this._touchManager = null;\n        this._deviceToScreen = null;\n        this._gear.release();\n        this._gear = null;\n        this._back.release();\n        this._back = null;\n        main_1.gl.deleteProgram(this._programId);\n        this._programId = null;\n    }\n    /**\n     * 描画する。\n     */\n    render() {\n        main_1.gl.useProgram(this._programId);\n        if (this._back) {\n            this._back.render(this._programId);\n        }\n        if (this._gear) {\n            this._gear.render(this._programId);\n        }\n        //  gl.flush();\n        const live2DManager = lapplive2dmanager_1.LAppLive2DManager.getInstance();\n        live2DManager.setViewMatrix(this._viewMatrix);\n        live2DManager.onUpdate();\n    }\n    /**\n     * 画像の初期化を行う。\n     */\n    initializeSprite() {\n        const width = main_1.canvas.width;\n        const height = main_1.canvas.height;\n        const textureManager = lappdelegate_1.LAppDelegate.getInstance().getTextureManager();\n        const resourcesPath = LAppDefine.ResourcesPath;\n        let imageName = '';\n        // 背景画像初期化\n        imageName = LAppDefine.BackImageName;\n        // 非同期なのでコールバック関数を作成\n        const initBackGroundTexture = (textureInfo) => {\n            const x = width * 0.5;\n            const y = height * 0.5;\n            const fwidth = textureInfo.width * 2.0;\n            const fheight = height * 0.95;\n            this._back = new lappsprite_1.LAppSprite(x, y, fwidth, fheight, textureInfo.id);\n        };\n        textureManager.createTextureFromPngFile(resourcesPath + imageName, false, initBackGroundTexture);\n        // 歯車画像初期化\n        imageName = LAppDefine.GearImageName;\n        const initGearTexture = (textureInfo) => {\n            const x = width - textureInfo.width * 0.5;\n            const y = height - textureInfo.height * 0.5;\n            const fwidth = textureInfo.width;\n            const fheight = textureInfo.height;\n            this._gear = new lappsprite_1.LAppSprite(x, y, fwidth, fheight, textureInfo.id);\n        };\n        textureManager.createTextureFromPngFile(resourcesPath + imageName, false, initGearTexture);\n        // シェーダーを作成\n        if (this._programId == null) {\n            this._programId = lappdelegate_1.LAppDelegate.getInstance().createShader();\n        }\n    }\n    /**\n     * タッチされた時に呼ばれる。\n     *\n     * @param pointX スクリーンX座標\n     * @param pointY スクリーンY座標\n     */\n    onTouchesBegan(pointX, pointY) {\n        this._touchManager.touchesBegan(pointX, pointY);\n    }\n    /**\n     * タッチしているときにポインタが動いたら呼ばれる。\n     *\n     * @param pointX スクリーンX座標\n     * @param pointY スクリーンY座標\n     */\n    onTouchesMoved(pointX, pointY) {\n        const viewX = this.transformViewX(this._touchManager.getX());\n        const viewY = this.transformViewY(this._touchManager.getY());\n        this._touchManager.touchesMoved(pointX, pointY);\n        const live2DManager = lapplive2dmanager_1.LAppLive2DManager.getInstance();\n        live2DManager.onDrag(viewX, viewY);\n    }\n    /**\n     * タッチが終了したら呼ばれる。\n     *\n     * @param pointX スクリーンX座標\n     * @param pointY スクリーンY座標\n     */\n    onTouchesEnded(pointX, pointY) {\n        // タッチ終了\n        const live2DManager = lapplive2dmanager_1.LAppLive2DManager.getInstance();\n        live2DManager.onDrag(0.0, 0.0);\n        {\n            // シングルタップ\n            const x = this._deviceToScreen.transformX(this._touchManager.getX()); // 論理座標変換した座標を取得。\n            const y = this._deviceToScreen.transformY(this._touchManager.getY()); // 論理座標変化した座標を取得。\n            if (LAppDefine.DebugTouchLogEnable) {\n                lapppal_1.LAppPal.printMessage(`[APP]touchesEnded x: ${x} y: ${y}`);\n            }\n            live2DManager.onTap(x, y);\n            // 歯車にタップしたか\n            if (this._gear.isHit(pointX, pointY)) {\n                live2DManager.nextScene();\n            }\n        }\n    }\n    /**\n     * X座標をView座標に変換する。\n     *\n     * @param deviceX デバイスX座標\n     */\n    transformViewX(deviceX) {\n        const screenX = this._deviceToScreen.transformX(deviceX); // 論理座標変換した座標を取得。\n        return this._viewMatrix.invertTransformX(screenX); // 拡大、縮小、移動後の値。\n    }\n    /**\n     * Y座標をView座標に変換する。\n     *\n     * @param deviceY デバイスY座標\n     */\n    transformViewY(deviceY) {\n        const screenY = this._deviceToScreen.transformY(deviceY); // 論理座標変換した座標を取得。\n        return this._viewMatrix.invertTransformY(screenY);\n    }\n    /**\n     * X座標をScreen座標に変換する。\n     * @param deviceX デバイスX座標\n     */\n    transformScreenX(deviceX) {\n        return this._deviceToScreen.transformX(deviceX);\n    }\n    /**\n     * Y座標をScreen座標に変換する。\n     *\n     * @param deviceY デバイスY座標\n     */\n    transformScreenY(deviceY) {\n        return this._deviceToScreen.transformY(deviceY);\n    }\n}\nexports.LAppView = LAppView;\n\n\n//# sourceURL=webpack:///./src/live2d/lappview.ts?");

/***/ }),

/***/ "./src/live2d/lappwavfilehandler.ts":
/*!******************************************!*\
  !*** ./src/live2d/lappwavfilehandler.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ByteReader = exports.WavFileInfo = exports.LAppWavFileHandler = exports.s_instance = void 0;\nexports.s_instance = null;\nclass LAppWavFileHandler {\n    /**\n     * クラスのインスタンス（シングルトン）を返す。\n     * インスタンスが生成されていない場合は内部でインスタンスを生成する。\n     *\n     * @return クラスのインスタンス\n     */\n    static getInstance() {\n        if (exports.s_instance == null) {\n            exports.s_instance = new LAppWavFileHandler();\n        }\n        return exports.s_instance;\n    }\n    /**\n     * クラスのインスタンス（シングルトン）を解放する。\n     */\n    static releaseInstance() {\n        if (exports.s_instance != null) {\n            exports.s_instance = void 0;\n        }\n        exports.s_instance = null;\n    }\n    update(deltaTimeSeconds) {\n        let goalOffset;\n        let rms;\n        // データロード前/ファイル末尾に達した場合は更新しない\n        if (this._pcmData == null ||\n            this._sampleOffset >= this._wavFileInfo._samplesPerChannel) {\n            this._lastRms = 0.0;\n            return false;\n        }\n        // 経過時間後の状態を保持\n        this._userTimeSeconds += deltaTimeSeconds;\n        goalOffset = Math.floor(this._userTimeSeconds * this._wavFileInfo._samplingRate);\n        if (goalOffset > this._wavFileInfo._samplesPerChannel) {\n            goalOffset = this._wavFileInfo._samplesPerChannel;\n        }\n        // RMS計測\n        rms = 0.0;\n        for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n            for (let sampleCount = this._sampleOffset; sampleCount < goalOffset; sampleCount++) {\n                const pcm = this._pcmData[channelCount][sampleCount];\n                rms += pcm * pcm;\n            }\n        }\n        rms = Math.sqrt(rms /\n            (this._wavFileInfo._numberOfChannels *\n                (goalOffset - this._sampleOffset)));\n        this._lastRms = rms;\n        this._sampleOffset = goalOffset;\n        return true;\n    }\n    start(filePath) {\n        // サンプル位参照位置を初期化\n        this._sampleOffset = 0;\n        this._userTimeSeconds = 0.0;\n        // RMS値をリセット\n        this._lastRms = 0.0;\n        if (!this.loadWavFile(filePath)) {\n            return;\n        }\n    }\n    getRms() {\n        return this._lastRms;\n    }\n    loadWavFile(filePath) {\n        let ret = false;\n        if (this._pcmData != null) {\n            this.releasePcmData();\n        }\n        // ファイルロード\n        const asyncFileLoad = () => __awaiter(this, void 0, void 0, function* () {\n            return fetch(filePath).then(responce => {\n                return responce.arrayBuffer();\n            });\n        });\n        const asyncWavFileManager = (() => __awaiter(this, void 0, void 0, function* () {\n            this._byteReader._fileByte = yield asyncFileLoad();\n            this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n            this._byteReader._fileSize = this._byteReader._fileByte.byteLength;\n            this._byteReader._readOffset = 0;\n            // ファイルロードに失敗しているか、先頭のシグネチャ\"RIFF\"を入れるサイズもない場合は失敗\n            if (this._byteReader._fileByte == null ||\n                this._byteReader._fileSize < 4) {\n                return false;\n            }\n            // ファイル名\n            this._wavFileInfo._fileName = filePath;\n            try {\n                // シグネチャ \"RIFF\"\n                if (!this._byteReader.getCheckSignature('RIFF')) {\n                    ret = false;\n                    throw new Error('Cannot find Signeture \"RIFF\".');\n                }\n                // ファイルサイズ-8（読み飛ばし）\n                this._byteReader.get32LittleEndian();\n                // シグネチャ \"WAVE\"\n                if (!this._byteReader.getCheckSignature('WAVE')) {\n                    ret = false;\n                    throw new Error('Cannot find Signeture \"WAVE\".');\n                }\n                // シグネチャ \"fmt \"\n                if (!this._byteReader.getCheckSignature('fmt ')) {\n                    ret = false;\n                    throw new Error('Cannot find Signeture \"fmt\".');\n                }\n                // fmtチャンクサイズ\n                const fmtChunkSize = this._byteReader.get32LittleEndian();\n                // フォーマットIDは1（リニアPCM）以外受け付けない\n                if (this._byteReader.get16LittleEndian() != 1) {\n                    ret = false;\n                    throw new Error('File is not linear PCM.');\n                }\n                // チャンネル数\n                this._wavFileInfo._numberOfChannels =\n                    this._byteReader.get16LittleEndian();\n                // サンプリングレート\n                this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();\n                // データ速度[byte/sec]（読み飛ばし）\n                this._byteReader.get32LittleEndian();\n                // ブロックサイズ（読み飛ばし）\n                this._byteReader.get16LittleEndian();\n                // 量子化ビット数\n                this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();\n                // fmtチャンクの拡張部分の読み飛ばし\n                if (fmtChunkSize > 16) {\n                    this._byteReader._readOffset += fmtChunkSize - 16;\n                }\n                // \"data\"チャンクが出現するまで読み飛ばし\n                while (!this._byteReader.getCheckSignature('data') &&\n                    this._byteReader._readOffset < this._byteReader._fileSize) {\n                    this._byteReader._readOffset +=\n                        this._byteReader.get32LittleEndian() + 4;\n                }\n                // ファイル内に\"data\"チャンクが出現しなかった\n                if (this._byteReader._readOffset >= this._byteReader._fileSize) {\n                    ret = false;\n                    throw new Error('Cannot find \"data\" Chunk.');\n                }\n                // サンプル数\n                {\n                    const dataChunkSize = this._byteReader.get32LittleEndian();\n                    this._wavFileInfo._samplesPerChannel =\n                        (dataChunkSize * 8) /\n                            (this._wavFileInfo._bitsPerSample *\n                                this._wavFileInfo._numberOfChannels);\n                }\n                // 領域確保\n                this._pcmData = new Array(this._wavFileInfo._numberOfChannels);\n                for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n                    this._pcmData[channelCount] = new Float32Array(this._wavFileInfo._samplesPerChannel);\n                }\n                // 波形データ取得\n                for (let sampleCount = 0; sampleCount < this._wavFileInfo._samplesPerChannel; sampleCount++) {\n                    for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n                        this._pcmData[channelCount][sampleCount] = this.getPcmSample();\n                    }\n                }\n                ret = true;\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }))();\n        return ret;\n    }\n    getPcmSample() {\n        let pcm32;\n        // 32ビット幅に拡張してから-1～1の範囲に丸める\n        switch (this._wavFileInfo._bitsPerSample) {\n            case 8:\n                pcm32 = this._byteReader.get8() - 128;\n                pcm32 <<= 24;\n                break;\n            case 16:\n                pcm32 = this._byteReader.get16LittleEndian() << 16;\n                break;\n            case 24:\n                pcm32 = this._byteReader.get24LittleEndian() << 8;\n                break;\n            default:\n                // 対応していないビット幅\n                pcm32 = 0;\n                break;\n        }\n        return pcm32 / 2147483647; //Number.MAX_VALUE;\n    }\n    releasePcmData() {\n        for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n            delete this._pcmData[channelCount];\n        }\n        delete this._pcmData;\n        this._pcmData = null;\n    }\n    constructor() {\n        this._loadFiletoBytes = (arrayBuffer, length) => {\n            this._byteReader._fileByte = arrayBuffer;\n            this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n            this._byteReader._fileSize = length;\n        };\n        this._pcmData = null;\n        this._userTimeSeconds = 0.0;\n        this._lastRms = 0.0;\n        this._sampleOffset = 0.0;\n        this._wavFileInfo = new WavFileInfo();\n        this._byteReader = new ByteReader();\n    }\n}\nexports.LAppWavFileHandler = LAppWavFileHandler;\nclass WavFileInfo {\n    constructor() {\n        this._fileName = '';\n        this._numberOfChannels = 0;\n        this._bitsPerSample = 0;\n        this._samplingRate = 0;\n        this._samplesPerChannel = 0;\n    }\n}\nexports.WavFileInfo = WavFileInfo;\nclass ByteReader {\n    constructor() {\n        this._fileByte = null;\n        this._fileDataView = null;\n        this._fileSize = 0;\n        this._readOffset = 0;\n    }\n    /**\n     * @brief 8ビット読み込み\n     * @return Csm::csmUint8 読み取った8ビット値\n     */\n    get8() {\n        const ret = this._fileDataView.getUint8(this._readOffset);\n        this._readOffset++;\n        return ret;\n    }\n    /**\n     * @brief 16ビット読み込み（リトルエンディアン）\n     * @return Csm::csmUint16 読み取った16ビット値\n     */\n    get16LittleEndian() {\n        const ret = (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n            this._fileDataView.getUint8(this._readOffset);\n        this._readOffset += 2;\n        return ret;\n    }\n    /**\n     * @brief 24ビット読み込み（リトルエンディアン）\n     * @return Csm::csmUint32 読み取った24ビット値（下位24ビットに設定）\n     */\n    get24LittleEndian() {\n        const ret = (this._fileDataView.getUint8(this._readOffset + 2) << 16) |\n            (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n            this._fileDataView.getUint8(this._readOffset);\n        this._readOffset += 3;\n        return ret;\n    }\n    /**\n     * @brief 32ビット読み込み（リトルエンディアン）\n     * @return Csm::csmUint32 読み取った32ビット値\n     */\n    get32LittleEndian() {\n        const ret = (this._fileDataView.getUint8(this._readOffset + 3) << 24) |\n            (this._fileDataView.getUint8(this._readOffset + 2) << 16) |\n            (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n            this._fileDataView.getUint8(this._readOffset);\n        this._readOffset += 4;\n        return ret;\n    }\n    /**\n     * @brief シグネチャの取得と参照文字列との一致チェック\n     * @param[in] reference 検査対象のシグネチャ文字列\n     * @retval  true    一致している\n     * @retval  false   一致していない\n     */\n    getCheckSignature(reference) {\n        const getSignature = new Uint8Array(4);\n        const referenceString = new TextEncoder().encode(reference);\n        if (reference.length != 4) {\n            return false;\n        }\n        for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {\n            getSignature[signatureOffset] = this.get8();\n        }\n        return (getSignature[0] == referenceString[0] &&\n            getSignature[1] == referenceString[1] &&\n            getSignature[2] == referenceString[2] &&\n            getSignature[3] == referenceString[3]);\n    }\n}\nexports.ByteReader = ByteReader;\n\n\n//# sourceURL=webpack:///./src/live2d/lappwavfilehandler.ts?");

/***/ }),

/***/ "./src/live2d/live2d.ts":
/*!******************************!*\
  !*** ./src/live2d/live2d.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.release = exports.render = exports.initialize = void 0;\nconst lappdelegate_1 = __webpack_require__(/*! ./lappdelegate */ \"./src/live2d/lappdelegate.ts\");\nfunction initialize() {\n    if (lappdelegate_1.LAppDelegate.getInstance().initialize() == false) {\n        throw Error(\"failed to initialize live2d\");\n    }\n}\nexports.initialize = initialize;\nfunction render() {\n    lappdelegate_1.LAppDelegate.getInstance().render();\n}\nexports.render = render;\nfunction release() {\n    lappdelegate_1.LAppDelegate.releaseInstance();\n}\nexports.release = release;\n/**\n * ブラウザロード後の処理\n */\n/*\nwindow.onload = (): void => {\n  // create the application instance\n  if (LAppDelegate.getInstance().initialize() == false) {\n    return;\n  }\n\n  LAppDelegate.getInstance().run();\n};*/\n/**\n * 終了時の処理\n */\n//window.onbeforeunload = (): void => LAppDelegate.releaseInstance();\n/**\n * Process when changing screen size.\n */\n/*\nwindow.onresize = () => {\n  if (LAppDefine.CanvasSize === 'auto') {\n    LAppDelegate.getInstance().onResize();\n  }\n};\n*/ \n\n\n//# sourceURL=webpack:///./src/live2d/live2d.ts?");

/***/ }),

/***/ "./src/live2d/touchmanager.ts":
/*!************************************!*\
  !*** ./src/live2d/touchmanager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TouchManager = void 0;\nclass TouchManager {\n    /**\n     * コンストラクタ\n     */\n    constructor() {\n        this._startX = 0.0;\n        this._startY = 0.0;\n        this._lastX = 0.0;\n        this._lastY = 0.0;\n        this._lastX1 = 0.0;\n        this._lastY1 = 0.0;\n        this._lastX2 = 0.0;\n        this._lastY2 = 0.0;\n        this._lastTouchDistance = 0.0;\n        this._deltaX = 0.0;\n        this._deltaY = 0.0;\n        this._scale = 1.0;\n        this._touchSingle = false;\n        this._flipAvailable = false;\n    }\n    getCenterX() {\n        return this._lastX;\n    }\n    getCenterY() {\n        return this._lastY;\n    }\n    getDeltaX() {\n        return this._deltaX;\n    }\n    getDeltaY() {\n        return this._deltaY;\n    }\n    getStartX() {\n        return this._startX;\n    }\n    getStartY() {\n        return this._startY;\n    }\n    getScale() {\n        return this._scale;\n    }\n    getX() {\n        return this._lastX;\n    }\n    getY() {\n        return this._lastY;\n    }\n    getX1() {\n        return this._lastX1;\n    }\n    getY1() {\n        return this._lastY1;\n    }\n    getX2() {\n        return this._lastX2;\n    }\n    getY2() {\n        return this._lastY2;\n    }\n    isSingleTouch() {\n        return this._touchSingle;\n    }\n    isFlickAvailable() {\n        return this._flipAvailable;\n    }\n    disableFlick() {\n        this._flipAvailable = false;\n    }\n    /**\n     * タッチ開始時イベント\n     * @param deviceX タッチした画面のxの値\n     * @param deviceY タッチした画面のyの値\n     */\n    touchesBegan(deviceX, deviceY) {\n        this._lastX = deviceX;\n        this._lastY = deviceY;\n        this._startX = deviceX;\n        this._startY = deviceY;\n        this._lastTouchDistance = -1.0;\n        this._flipAvailable = true;\n        this._touchSingle = true;\n    }\n    /**\n     * ドラッグ時のイベント\n     * @param deviceX タッチした画面のxの値\n     * @param deviceY タッチした画面のyの値\n     */\n    touchesMoved(deviceX, deviceY) {\n        this._lastX = deviceX;\n        this._lastY = deviceY;\n        this._lastTouchDistance = -1.0;\n        this._touchSingle = true;\n    }\n    /**\n     * フリックの距離測定\n     * @return フリック距離\n     */\n    getFlickDistance() {\n        return this.calculateDistance(this._startX, this._startY, this._lastX, this._lastY);\n    }\n    /**\n     * 点１から点２への距離を求める\n     *\n     * @param x1 １つ目のタッチした画面のxの値\n     * @param y1 １つ目のタッチした画面のyの値\n     * @param x2 ２つ目のタッチした画面のxの値\n     * @param y2 ２つ目のタッチした画面のyの値\n     */\n    calculateDistance(x1, y1, x2, y2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n    /**\n     * ２つ目の値から、移動量を求める。\n     * 違う方向の場合は移動量０。同じ方向の場合は、絶対値が小さい方の値を参照する。\n     *\n     * @param v1 １つ目の移動量\n     * @param v2 ２つ目の移動量\n     *\n     * @return 小さい方の移動量\n     */\n    calculateMovingAmount(v1, v2) {\n        if (v1 > 0.0 != v2 > 0.0) {\n            return 0.0;\n        }\n        const sign = v1 > 0.0 ? 1.0 : -1.0;\n        const absoluteValue1 = Math.abs(v1);\n        const absoluteValue2 = Math.abs(v2);\n        return (sign * (absoluteValue1 < absoluteValue2 ? absoluteValue1 : absoluteValue2));\n    }\n}\nexports.TouchManager = TouchManager;\n\n\n//# sourceURL=webpack:///./src/live2d/touchmanager.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.frameBuffer = exports.gl = exports.canvas = void 0;\nconst lappdelegate_1 = __webpack_require__(/*! ./live2d/lappdelegate */ \"./src/live2d/lappdelegate.ts\");\nconst live2d_1 = __webpack_require__(/*! ./live2d/live2d */ \"./src/live2d/live2d.ts\");\nexports.canvas = null;\nexports.gl = null;\nexports.frameBuffer = null;\nfunction initializeGL() {\n    exports.canvas = document.createElement('canvas');\n    exports.gl = exports.canvas.getContext('webgl');\n    if (!exports.gl) {\n        alert('Cannot initialize WebGL. This browser does not support.');\n        exports.gl = null;\n        document.body.innerHTML =\n            'This browser does not support the <code>&lt;canvas&gt;</code> element.';\n        // gl初期化失敗\n        throw Error('This browser does not support the <code>&lt;canvas&gt;</code> element.');\n    }\n    // キャンバスを DOM に追加\n    document.body.appendChild(exports.canvas);\n    if (!exports.frameBuffer) {\n        exports.frameBuffer = exports.gl.getParameter(exports.gl.FRAMEBUFFER_BINDING);\n    }\n    // 透過設定\n    exports.gl.enable(exports.gl.BLEND);\n    exports.gl.blendFunc(exports.gl.SRC_ALPHA, exports.gl.ONE_MINUS_SRC_ALPHA);\n    const supportTouch = 'ontouchend' in exports.canvas;\n    if (supportTouch) {\n        // タッチ関連コールバック関数登録\n        exports.canvas.ontouchstart = onTouchStart;\n        exports.canvas.ontouchmove = onTouchMove;\n        exports.canvas.ontouchend = onTouchEnd;\n        exports.canvas.ontouchcancel = onTouchCancel;\n    }\n    else {\n        // マウス関連コールバック関数登録\n        exports.canvas.onmousedown = onMouseDown;\n        exports.canvas.onmousemove = onMouseMove;\n        exports.canvas.onmouseup = onMouseUp;\n    }\n}\nfunction initialize() {\n    initializeGL();\n    lappdelegate_1.LAppDelegate.getInstance().initialize();\n}\nfunction onTouchStart(e) {\n    (0, lappdelegate_1.onTouchBegan)(e);\n}\nfunction onTouchMove(e) {\n    (0, lappdelegate_1.onTouchMoved)(e);\n}\nfunction onTouchEnd(e) {\n    (0, lappdelegate_1.onTouchEnded)(e);\n}\nfunction onTouchCancel(e) {\n    (0, lappdelegate_1.onTouchCancel)(e);\n}\nfunction onMouseDown(e) {\n    (0, lappdelegate_1.onClickBegan)(e);\n}\nfunction onMouseMove(e) {\n    (0, lappdelegate_1.onMouseMoved)(e);\n}\nfunction onMouseUp(e) {\n    (0, lappdelegate_1.onClickEnded)(e);\n}\nfunction run() {\n    const loop = () => {\n        // 画面の初期化\n        exports.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        // 深度テストを有効化\n        exports.gl.enable(exports.gl.DEPTH_TEST);\n        // 近くにある物体は、遠くにある物体を覆い隠す\n        exports.gl.depthFunc(exports.gl.LEQUAL);\n        // カラーバッファや深度バッファをクリアする\n        exports.gl.clear(exports.gl.COLOR_BUFFER_BIT | exports.gl.DEPTH_BUFFER_BIT);\n        exports.gl.clearDepth(1.0);\n        lappdelegate_1.LAppDelegate.getInstance().render();\n        requestAnimationFrame(loop);\n    };\n    loop();\n}\nwindow.onload = () => {\n    initialize();\n    run();\n};\nwindow.onbeforeunload = () => {\n    (0, live2d_1.release)();\n};\nwindow.onresize = () => {\n    lappdelegate_1.LAppDelegate.getInstance().onResize();\n};\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMException: () => (/* binding */ DOMException),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* eslint-disable no-prototype-builtins */\nvar g =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  // eslint-disable-next-line no-undef\n  (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||\n  {}\n\nvar support = {\n  searchParams: 'URLSearchParams' in g,\n  iterable: 'Symbol' in g && 'iterator' in Symbol,\n  blob:\n    'FileReader' in g &&\n    'Blob' in g &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in g,\n  arrayBuffer: 'ArrayBuffer' in g\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      if (header.length != 2) {\n        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)\n      }\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body._noBody) return\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)\n  var encoding = match ? match[1] : 'utf-8'\n  reader.readAsText(blob, encoding)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    // eslint-disable-next-line no-self-assign\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._noBody = true;\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n  }\n\n  this.arrayBuffer = function() {\n    if (this._bodyArrayBuffer) {\n      var isConsumed = consumed(this)\n      if (isConsumed) {\n        return isConsumed\n      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        return Promise.resolve(\n          this._bodyArrayBuffer.buffer.slice(\n            this._bodyArrayBuffer.byteOffset,\n            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n          )\n        )\n      } else {\n        return Promise.resolve(this._bodyArrayBuffer)\n      }\n    } else if (support.blob) {\n      return this.blob().then(readBlobAsArrayBuffer)\n    } else {\n      throw new Error('could not read as ArrayBuffer')\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal || (function () {\n    if ('AbortController' in g) {\n      var ctrl = new AbortController();\n      return ctrl.signal;\n    }\n  }());\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split('\\r')\n    .map(function(header) {\n      return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        try {\n          headers.append(key, value)\n        } catch (error) {\n          console.warn('Response ' + error.message)\n        }\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  if (this.status < 200 || this.status > 599) {\n    throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\")\n  }\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? '' : '' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 200, statusText: ''})\n  response.status = 0\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = g.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && g.location.href ? g.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {\n      var names = [];\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        names.push(normalizeName(name))\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n      request.headers.forEach(function(value, name) {\n        if (names.indexOf(name) === -1) {\n          xhr.setRequestHeader(name, value)\n        }\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!g.fetch) {\n  g.fetch = fetch\n  g.Headers = Headers\n  g.Request = Request\n  g.Response = Response\n}\n\n\n//# sourceURL=webpack:///./node_modules/whatwg-fetch/fetch.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;